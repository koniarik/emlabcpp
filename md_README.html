<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emlabcpp: emlabcpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emlabcpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_README.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">emlabcpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/koniarik/emlabcpp/actions/workflows/tests.yml"><object type="image/svg+xml" data="https://github.com/koniarik/emlabcpp/actions/workflows/tests.yml/badge.svg" style="pointer-events: none;">Tests</object></a></p>
<p>A C++20 header-only library that focuses on embedded development. It is by product of your development of robotics hardware.</p>
<p>It provides a wide set of tools, from complex mechanisms (protocol library) to simple utilites (view). The library is heavily used our core project and spread itself into other smaller projects.</p>
<ul>
<li><a href="#Installation">Installation</a></li>
<li><a href="#Components">Components</a><ul>
<li><a href="#algorithmh">algorithm.h</a></li>
<li><a href="#eitherh">either.h</a></li>
<li><a href="#viewh">view.h</a></li>
<li><a href="#boundedh">bounded.h</a></li>
<li><a href="#protocolh">protocol.h</a></li>
<li><a href="#iteratorh">iterator.h</a></li>
<li><a href="#quantityh">quantity.h</a></li>
<li><a href="#pidh">pid.h</a></li>
<li><a href="#static_circular_bufferh">static_circular_buffer.h</a></li>
<li><a href="#static_vectorh">static_vector.h</a></li>
<li><a href="#typesh">types.h</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<p>Repository is at <a href="https://github.com/koniarik/emlabcpp">https://github.com/koniarik/emlabcpp</a> The prefered of getting the library for now is via fetchcontent:</p>
<div class="fragment"><div class="line">FetchContent_Declare(</div>
<div class="line">  emlabcpp</div>
<div class="line">  GIT_REPOSITORY https://github.com/koniarik/emlabcpp</div>
<div class="line">  GIT_TAG v1.1</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(emlabcpp)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md2"></a>
Components</h1>
<p>The library can be view as a set of components. These are organized based on the root header file for the said component.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
algorithm.h</h2>
<p>Contains a set of algorithms similar to &lt;algorithm&gt; standard library, with a major change. Functions take as an argument a container itself, rather than iterators. Most of the functions are also able to work with <code>std::tuple</code>. This is expanded with other short functions representing simple algorithms.</p>
<p>The two core functions are <code>find_if</code> and <code>for_each</code>, both are implemented with variant over containers and tuples.</p>
<div class="fragment"><div class="line">std::tuple&lt; int, std::string &gt; tpl_data;</div>
<div class="line">std::vector&lt; int &gt; vec_data;</div>
<div class="line">for_each(tpl_data, [&amp;]( <span class="keyword">const</span> <span class="keyword">auto</span> &amp; item ){</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="line">for_each(vec_data, [&amp;]( <span class="keywordtype">int</span> item ){</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::size_t index = find_if(tpl_data, [&amp;]( <span class="keyword">auto</span> item ){</div>
<div class="line">    <span class="keywordflow">return</span> std::is_same_v&lt; decltype(item), std::string &gt;(item);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> iter = find_if(vec_data, [&amp;]( <span class="keywordtype">int</span> i ){</div>
<div class="line">    <span class="keywordflow">return</span> i != 0;</div>
<div class="line">});</div>
</div><!-- fragment --><p>See examples for an overview of algorithms.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
either.h</h2>
<p><code>either&lt;A,B&gt;</code> is <code>std::variant</code> alternative able to hold only two types. Either however contains multiple methods to transform it's state and type. This makes it possible to chain the changes in the code.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> error = std::string;</div>
<div class="line"> </div>
<div class="line">either&lt;U, error&gt; fuu();</div>
<div class="line"> </div>
<div class="line">either&lt;T, error&gt; foo(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fuu()</div>
<div class="line">        .convert_left([&amp;](U val) -&gt; T{</div>
<div class="line">            T res{val};</div>
<div class="line">            T.do_magic(i);</div>
<div class="line">            <span class="keywordflow">return</span> res;</div>
<div class="line">        })</div>
<div class="line">        .convert_right([&amp;](error e){</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;Magic was not done :(, sub error is: &quot;</span> + e;</div>
<div class="line">        });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">foo(42).match(</div>
<div class="line">    [&amp;](T val){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;T happend\o/: &quot;</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    },[&amp;](error e){</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;error happend :(: &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    })</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
view.h</h2>
<p>Simple container storing a pair of iterators - non-owning container of data. This make it possible to pass a subset of container to API expecting a container itself. It is also more sensible for functions that would return <code>std::pair</code> of iterators.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data{1,2,3,4,5,6};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : view{vec_data})</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : view{vec_data.begin() + 2, vec_data.end()})</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : view_n(vec_data, 4))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : reversed(vec_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
bounded.h</h2>
<p>Simple overlay type for constraing value within specified range. Makes it possible to create clear API that does not have to check the sanity of values. <code>bounded&lt;int,0,42&gt;</code> means that the <code>bounded</code> class contains <code>int</code> type that is constrained within <code>0</code> and <code>42</code>.</p>
<p>The API with <code>bounded</code> has more clear intent: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(bounded&lt;int,0,42&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md7"></a>
protocol.h</h2>
<p>The protocol library serializes and deserialize C++ data structures into binary messages. The principle is that the protocol is defined with library types. Based on the definition, <code>protocol_handler&lt;Def&gt;</code> provides routines for serialization and deserialization of data structures corresponding to said definition.</p>
<p>In case of work with simple robot, we can create simple protocol: </p><div class="fragment"><div class="line"><span class="keyword">using</span> distance = unsigned;</div>
<div class="line"><span class="keyword">using</span> angle = int;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> robot_cmds : uint8_t</div>
<div class="line">{</div>
<div class="line">    FORWARD = 0,</div>
<div class="line">    LEFT = 1,</div>
<div class="line">    RIGHT = 2</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>robot_cmd_group</div>
<div class="line">  : protocol_command_group&lt; PROTOCOL_LITTLE_ENDIAN &gt;::with_commands&lt;</div>
<div class="line">      protocol_command&lt; FORWARD &gt;::with_args&lt; distance &gt;,</div>
<div class="line">      protocol_command&lt; LEFT &gt;::with_args&lt; angle &gt;,</div>
<div class="line">      protocol_command&lt; RIGHT &gt;::with_args&lt; angle &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{};</div>
</div><!-- fragment --><p>See examples for more detailed explanation.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
iterator.h</h2>
<p>Contains <code>generic_iterator&lt;Derived&gt;</code> CRTP baseclass. This simplifies implementation of custom iterators, as most of the methods/operators we expect of iterators can be implemented based on a small set of functions. (operator+, operator++(int), operator++ can be implemetned with operator+=)</p>
<p>For implementing iterator, you only provide the basic subset for this class and it takes care of the rest. Keep in mind that this is for "general" use case, and for optimallity you may be better served with fully custom iterator.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
iterators/numeric.h</h3>
<p>Iterator that mimics real data container of sequence of numbers. The number is stored inside the iterator and when iterator is advanced, so is the internal value changed. Contains also functions like <code>range(from,to)</code> that creates a range from this iterators.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i : range(vec_data.size()-1))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; vec_data[i] &lt;&lt; <span class="charliteral">&#39;-&#39;</span> &lt;&lt; vec_data[i+1] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md10"></a>
iterators/subscript.h</h3>
<p>Iterator over datatype that implemented operator[] but does not have iterators.</p>
<div class="fragment"><div class="line">std::bitset&lt;32&gt; bit_data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">bool</span> b : subscript_view(bit_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; (b ? <span class="charliteral">&#39;a&#39;</span> : <span class="charliteral">&#39;b&#39;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md11"></a>
iterators/access.h</h3>
<p>Iterators overlays the data stored in input container, and provides access only to 'reference' provided by function out of item in the container.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo{</div>
<div class="line">    std::string attr;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;foo&gt; vec_data;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> acview = access_view(vec_data,</div>
<div class="line">                          [](<span class="keyword">const</span> foo&amp; item) -&gt; <span class="keyword">const</span> std::string&amp; { </div>
<div class="line">                            <span class="keywordflow">return</span> item.attr;</div>
<div class="line">                          });</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> std::string &amp; item : acview)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
quantity.h</h2>
<p>Simple thin overlay over numeric types, that gives abillity to implement strongly typed numeric types. This is handy in case you want to enforce correctness on type level. See implementation of <code>physical_quantity</code> as an example.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
physical_quantity.h</h2>
<p>System of physical quantities based on <code>quantity.h</code>. These represent physical quantity that stores it's unit in it's own type (templated).</p>
<p>This makes it possible to have velocity/length/time represented as distinct types. Also, the result type of operations like length divided by time is of type velocity.</p>
<p>This increases safety of physical computations, as it enforces correct units in the math. The <code>operator&lt;&lt;</code> is overloaded to output units for the type, such as: <code>0.25m</code></p>
<div class="fragment"><div class="line">position uniform_accel(position s0, velocity v0, acceleration a, timeq t)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s0 + v0*t + 0.5*a*t*t;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; position{0.25};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
pid.h</h2>
<p>Basic PID regulator implementation using floats, templated based on the time type;</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> time_t = uint32_t;</div>
<div class="line">pid&lt;time_t&gt;::config conf = {</div>
<div class="line">    .p = 0.5f, </div>
<div class="line">    .i = 0.005f, </div>
<div class="line">    .d = 0.2f, </div>
<div class="line">    .min = 0.0f, </div>
<div class="line">    .max = 256.0f</div>
<div class="line">    };</div>
<div class="line">pid&lt;time_t&gt; regulator{time{0}, conf};</div>
<div class="line"> </div>
<div class="line">time_t time = 0;</div>
<div class="line"><span class="keywordtype">float</span> state = 0.0f;</div>
<div class="line"><span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">{</div>
<div class="line">    regulator.update(time, state, std::cos(time*0.05f));</div>
<div class="line">    state = regulator.output();</div>
<div class="line"> </div>
<div class="line">    time += 1;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md15"></a>
static_circular_buffer.h</h2>
<p>Basic implementation of circular buffer with static maximal size, that can store non-default constructible elements. No dynamic allocation is used.</p>
<div class="fragment"><div class="line">static_circular_buffer&lt;std::byte, 256&gt; buffr;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : {0,1,2,3,4,5,6})</div>
<div class="line">{</div>
<div class="line">    buffr.push_back(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : buffr)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(!buffr.empty())</div>
<div class="line">{</div>
<div class="line">    buffr.pop_front();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
static_vector.h</h2>
<p>Basic implementation of vector with static maximal size, that can store non-default constructible elements. No dynamic allocation is used.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
types.h</h2>
<p>A library of helpers for type inspection, this contains types similar to <code>type_traits</code> of standard library. This follows the pattern of <code>std::</code> library - type check is structure with <code>::value</code>/<code>::type</code> attributes and using for <code>_v</code>/<code>_t</code> suffixed aliases exists.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> data = std::vector&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> fun = [](<span class="keywordtype">int</span> i) -&gt; std::string</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(i)</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> fun = decltype(fun);</div>
<div class="line"> </div>
<div class="line">static_assert(std::is_same_v&lt;mapped_t&lt;data, fun&gt;, std::string&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md18"></a>
zip.h</h2>
<p>zip iterator over multiple data containers, which dereference value is tuple of references to provided containers.</p>
<p>This is especially handy in combination with numeric iterator. Example is <code>enumerate(cont)</code> which returns zip of range over cont size and cont itself, which behaves same as enumerate on python.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data{-1,1,-1,1,-1,1};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> [i,val] : enumerate(vec_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t:&quot;</span> &lt;&lt; val &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::string&gt; names = {<span class="stringliteral">&quot;john&quot;</span>, <span class="stringliteral">&quot;clark&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; surnames = {<span class="stringliteral">&quot;deer&quot;</span>, <span class="stringliteral">&quot;kent&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> [name, surname] : zip(names, surnames))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; surname &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
