<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emlabcpp: emlabcpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emlabcpp
   </div>
   <div id="projectbrief">modern opinionated embedded C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">emlabcpp </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/koniarik/emlabcpp/actions/workflows/tests.yml"><img src="https://github.com/koniarik/emlabcpp/actions/workflows/tests.yml/badge.svg" alt="Tests" style="pointer-events: none;" class="inline"/></a> <a href="https://raw.githubusercontent.com/nlohmann/json/master/LICENSE.MIT"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="GitHub license" style="pointer-events: none;" class="inline"/></a></p>
<p>An opinionated C++20 library focusing on embedded development. It provides a wide set of tools, from complex mechanisms (protocol library) to simple utilites (view). More details in <a href="https://koniarik.github.io/emlabcpp/index.html">Documentation</a></p>
<ul>
<li><a href="#Installation">Installation</a></li>
<li><a href="#Components">Components</a><ul>
<li><a href="#algorithmh">algorithm.h</a></li>
<li><a href="#asserth">assert.h</a></li>
<li><a href="#boundedh">bounded.h</a></li>
<li><a href="#conceptsh">concepts.h</a></li>
<li><a href="#deferh">defer.h</a></li>
<li><a href="#eitherh">either.h</a></li>
<li><a href="#enumh">enum.h</a></li>
<li><a href="#iteratorh">iterator.h</a></li>
<li><a href="#matchh">match.h</a></li>
<li><a href="#physical_quantityh">physical_quantity.h</a></li>
<li><a href="#pidh">pid.h</a></li>
<li><a href="#protocolh">protocol.h</a></li>
<li><a href="#quantityh">quantity.h</a></li>
<li><a href="#static_circular_bufferh">static_circular_buffer.h</a></li>
<li><a href="#static_vectorh">static_vector.h</a></li>
<li><a href="#typesh">types.h</a></li>
<li><a href="#viewh">view.h</a></li>
<li><a href="#visith">visit.h</a></li>
<li><a href="#ziph">zip.h</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
Installation</h1>
<p>Repository is at <a href="https://github.com/koniarik/emlabcpp">https://github.com/koniarik/emlabcpp</a> The prefered of getting the library for now is via fetchcontent:</p>
<div class="fragment"><div class="line">FetchContent_Declare(</div>
<div class="line">  emlabcpp</div>
<div class="line">  GIT_REPOSITORY https://github.com/koniarik/emlabcpp</div>
<div class="line">  GIT_TAG v1.1</div>
<div class="line">)</div>
<div class="line">FetchContent_MakeAvailable(emlabcpp)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md10"></a>
Components</h1>
<p>The library can be view as a set of components. These are organized based on the root header file for the said component.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
algorithm.h</h2>
<p>Contains a set of algorithms similar to &lt;algorithm&gt; standard library, with a major change. Functions take as an argument a container itself, rather than iterators. Most of the functions are also able to work with <code>std::tuple</code>. This is expanded with other short functions representing simple algorithms.</p>
<p>The two core functions are <code>find_if</code> and <code>for_each</code>, both are implemented with variant over containers and tuples.</p>
<div class="fragment"><div class="line">std::tuple&lt; int, std::string &gt; tpl_data;</div>
<div class="line">std::vector&lt; int &gt; vec_data;</div>
<div class="line"><a class="code" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a>(tpl_data, [&amp;]( <span class="keyword">const</span> <span class="keyword">auto</span> &amp; item ){</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="line"><a class="code" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a>(vec_data, [&amp;]( <span class="keywordtype">int</span> item ){</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">std::size_t index = <a class="code" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if</a>(tpl_data, [&amp;]( <span class="keyword">auto</span> item ){</div>
<div class="line">    <span class="keywordflow">return</span> std::is_same_v&lt; decltype(item), std::string &gt;(item);</div>
<div class="line">});</div>
<div class="line"><span class="keyword">auto</span> iter = <a class="code" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if</a>(vec_data, [&amp;]( <span class="keywordtype">int</span> i ){</div>
<div class="line">    <span class="keywordflow">return</span> i != 0;</div>
<div class="line">});</div>
<div class="ttc" id="anamespaceemlabcpp_html_a685395cc470dfed697a40d2c718af4e9"><div class="ttname"><a href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">emlabcpp::for_each</a></div><div class="ttdeci">constexpr void for_each(Container &amp;&amp;cont, UnaryCallable &amp;&amp;f)</div><div class="ttdoc">Applies unary callable 'f' to each element of container 'cont'.</div><div class="ttdef"><b>Definition:</b> algorithm.h:176</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_adad2aaee725330a629c1fa9af8cf7e37"><div class="ttname"><a href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">emlabcpp::find_if</a></div><div class="ttdeci">constexpr auto find_if(Container &amp;&amp;cont, PredicateCallable &amp;&amp;f=std::identity())</div><div class="ttdoc">Returns iterator for first item, for which call to predicate f(*iter) holds true.</div><div class="ttdef"><b>Definition:</b> algorithm.h:114</div></div>
</div><!-- fragment --><p>See examples for an overview of algorithms.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
assert.h</h2>
<p>Provides <code><a class="el" href="assert_8h.html#a1be190c4e600e598cc284808298bde75" title="Copyright (C) 2020 Jan Veverak Koniarik.">EMLABCPP_ASSERT(c)</a></code> macro that has three states:</p><ol type="1">
<li>Does nothing - node instructions are emitted.</li>
<li>Calls <code>assert(c)</code> if <code>EMLABCPP_ASSERT_NATIVE</code> is defined.</li>
<li>Calls <code>EMLABCPP_ASSERT_FUNC(c)</code> if <code>EMLABCPP_ASSERT_FUNC</code> is defined.</li>
</ol>
<p>By default, none of the macros are defined.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
bounded.h</h2>
<p>Provides <code>bounded&lt;T,Min,Max&gt;</code> class that envelops type <code>T</code> and provides interface that enforces <code>T</code> to remain within bounds <code>Min</code> and <code>Max</code>. Can be used to relay value constrains in type information.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> T::set_power(bounded&lt;float, -1.f, 1.f&gt;)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md14"></a>
concepts.h</h2>
<p>A set of C++ concepts designed for implementing a checks inside the library.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
defer.h</h2>
<p>Simple utility class to setup code segments executed after the end of scope:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> exec_job(){</div>
<div class="line">    defer d = []{</div>
<div class="line">        send_finished_message();</div>
<div class="line">    };</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> This enforces that "finished" message is send after the <code>exec_job</code> call finishes.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
either.h</h2>
<p><code>either&lt;A,B&gt;</code> is <code>std::variant</code> alternative able to hold only two types. Either however contains multiple methods to transform it's state and type. This makes it possible to chain the changes in the code.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> error = std::string;</div>
<div class="line"> </div>
<div class="line">either&lt;U, error&gt; fuu();</div>
<div class="line"> </div>
<div class="line">either&lt;T, error&gt; foo(<span class="keywordtype">int</span> i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> fuu()</div>
<div class="line">        .convert_left([&amp;](U val) -&gt; T{</div>
<div class="line">            T <a class="code" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>{val};</div>
<div class="line">            T.do_magic(i);</div>
<div class="line">            <span class="keywordflow">return</span> <a class="code" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>;</div>
<div class="line">        })</div>
<div class="line">        .convert_right([&amp;](error e){</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;Magic was not done :(, sub error is: &quot;</span> + e;</div>
<div class="line">        });</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">foo(42).match(</div>
<div class="line">    [&amp;](T val){</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;T happend\o/: &quot;</span> &lt;&lt; val &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    },[&amp;](error e){</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;error happend :(: &quot;</span> &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    })</div>
<div class="ttc" id="anamespaceemlabcpp_html_a9f3571963bbe0982f9987b78b111c626"><div class="ttname"><a href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">emlabcpp::res</a></div><div class="ttdeci">T res</div><div class="ttdef"><b>Definition:</b> algorithm.h:555</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
enum.h</h2>
<p>Provides a function that converts enum value into string representative, this either does simple <code>int-&gt;string</code> conversion or uses <code>magic_enum</code> library if it is enabled with <code>EMLABCPP_USE_MAGIC_ENUM</code> define.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">enum</span> e_type {</div>
<div class="line">    FOO = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; convert_enum(FOO) &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Outputs <code>FOO</code> if <code>magic_enum</code> is enabled and <code>0</code> otherwise.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
iterator.h</h2>
<p>Contains <code>generic_iterator&lt;Derived&gt;</code> CRTP baseclass. This simplifies implementation of custom iterators, as most of the methods/operators we expect of iterators can be implemented based on a small set of functions. (operator+, operator++(int), operator++ can be implemetned with operator+=)</p>
<p>For implementing iterator, you only provide the basic subset for this class and it takes care of the rest. Keep in mind that this is for "general" use case, and for optimallity you may be better served with fully custom iterator.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
iterators/numeric.h</h3>
<p>Iterator that mimics real data container of sequence of numbers. The number is stored inside the iterator and when iterator is advanced, so is the internal value changed. Use functions like <code>range(from,to)</code> to creates a range from this iterators.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(std::size_t i : <a class="code" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range</a>(vec_data.size()-1))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; vec_data[i] &lt;&lt; <span class="charliteral">&#39;-&#39;</span> &lt;&lt; vec_data[i+1] &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_html_acf5a156c767ed17a892cc7e9b5acd2b1"><div class="ttname"><a href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">emlabcpp::range</a></div><div class="ttdeci">constexpr view&lt; iterators::numeric_iterator&lt; Numeric &gt; &gt; range(Numeric from, Numeric to)</div><div class="ttdoc">Builds numeric view over interval [from, to)</div><div class="ttdef"><b>Definition:</b> range.h:29</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md20"></a>
iterators/subscript.h</h3>
<p>Iterator over datatype that implemented operator[] but does not have iterators.</p>
<div class="fragment"><div class="line">std::bitset&lt;32&gt; bit_data;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">bool</span> b : <a class="code" href="namespaceemlabcpp.html#ac813ec118aa63294f4ed7955f389e289">subscript_view</a>(bit_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; (b ? <span class="charliteral">&#39;a&#39;</span> : <span class="charliteral">&#39;b&#39;</span>);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_html_ac813ec118aa63294f4ed7955f389e289"><div class="ttname"><a href="namespaceemlabcpp.html#ac813ec118aa63294f4ed7955f389e289">emlabcpp::subscript_view</a></div><div class="ttdeci">view&lt; iterators::subscript_iterator&lt; Container &gt; &gt; subscript_view(Container &amp;cont)</div><div class="ttdef"><b>Definition:</b> subscript_view.h:27</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md21"></a>
iterators/access.h</h3>
<p>Iterators overlays the data stored in input container, and provides access only to 'reference' provided by function out of item in the container.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>foo{</div>
<div class="line">    std::string attr;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;foo&gt; vec_data;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> acview = access_view(vec_data,</div>
<div class="line">                          [](<span class="keyword">const</span> foo&amp; item) -&gt; <span class="keyword">const</span> std::string&amp; {</div>
<div class="line">                            <span class="keywordflow">return</span> item.attr;</div>
<div class="line">                          });</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> std::string &amp; item : acview)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md22"></a>
match.h</h2>
<p>Match is mechanism similar to <code>std::visit(Callable,Variant)</code>, but one that changes the order of arguments and allows mutliple callables. The signature is along the lines of: <code>match(Variant,Callable...)</code>. The implementation composes callables together and let's method resolution pick the appropaite callable for alternative present in the variant.</p>
<p>This makes it possible to write constructs such as these: </p><div class="fragment"><div class="line">std::variant&lt;StateA, StateB, StateC&gt; states;</div>
<div class="line"><a class="code" href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">match</a>(states,</div>
<div class="line">    [&amp;](StateA sa){</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    },</div>
<div class="line">    [&amp;](StateB sb){</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    },</div>
<div class="line">    [&amp;](StateC sc){</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">    });</div>
<div class="ttc" id="anamespaceemlabcpp_html_a57181a407fd6f29a50664f8ba4cb44cd"><div class="ttname"><a href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">emlabcpp::match</a></div><div class="ttdeci">decltype(auto) match(Variant &amp;&amp;var, Callables &amp;&amp;... cals)</div><div class="ttdef"><b>Definition:</b> match.h:51</div></div>
</div><!-- fragment --><p> Here, the function executions a lambda for the state that is present in the variant, you can think about it like a <code>switch</code> but for variant.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
physical_quantity.h</h2>
<p>System of physical quantities based on <code><a class="el" href="quantity_8h.html">quantity.h</a></code>. These represent physical quantity that stores it's unit in it's own type (templated).</p>
<p>This makes it possible to have velocity/length/time represented as distinct types. Also, the result type of operations like length divided by time is of type velocity.</p>
<p>This increases safety of physical computations, as it enforces correct units in the math. The <code>operator&lt;&lt;</code> is overloaded to output units for the type, such as: <code>0.25m</code></p>
<div class="fragment"><div class="line">position uniform_accel(position s0, <a class="code" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">velocity</a> v0, <a class="code" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">acceleration</a> a, <a class="code" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">timeq</a> t)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s0 + v0*t + 0.5*a*t*t;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; position{0.25};</div>
<div class="ttc" id="anamespaceemlabcpp_html_a1133bfe4782c135fcdb04c3de43fc0a1"><div class="ttname"><a href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">emlabcpp::velocity</a></div><div class="ttdeci">physical_quantity&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt; velocity</div><div class="ttdef"><b>Definition:</b> physical_quantity.h:90</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a35fa23942849e26dc612a6608eb2ec02"><div class="ttname"><a href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">emlabcpp::timeq</a></div><div class="ttdeci">physical_quantity&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt; timeq</div><div class="ttdef"><b>Definition:</b> physical_quantity.h:79</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a9f7b213031fa424abf6cc3d1d04ac1ca"><div class="ttname"><a href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">emlabcpp::acceleration</a></div><div class="ttdeci">physical_quantity&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt; acceleration</div><div class="ttdef"><b>Definition:</b> physical_quantity.h:86</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md24"></a>
pid.h</h2>
<p>Basic PID regulator implementation using floats, templated based on the time type.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
protocol.h</h2>
<p>The protocol library serializes and deserialize C++ data structures into binary messages. The principle is that the protocol is defined with library types. Based on the definition, <code>protocol_handler&lt;Def&gt;</code> provides routines for serialization and deserialization of data structures corresponding to said definition.</p>
<p>In case of work with simple robot, we can create simple protocol: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">distance</a> = unsigned;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> = int;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">enum</span> robot_cmds : uint8_t</div>
<div class="line">{</div>
<div class="line">    FORWARD = 0,</div>
<div class="line">    LEFT = 1,</div>
<div class="line">    RIGHT = 2</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>robot_cmd_group</div>
<div class="line">  : protocol::command_group&lt; std::endian::little &gt;::with_commands&lt;</div>
<div class="line">      protocol::command&lt; FORWARD &gt;::with_args&lt; distance &gt;,</div>
<div class="line">      protocol::command&lt; LEFT &gt;::with_args&lt; angle &gt;,</div>
<div class="line">      protocol::command&lt; RIGHT &gt;::with_args&lt; angle &gt;</div>
<div class="line">    &gt;</div>
<div class="line">{};</div>
<div class="ttc" id="anamespaceemlabcpp_html_a11ac05592b4c728910966af0c89b13a8"><div class="ttname"><a href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">emlabcpp::distance</a></div><div class="ttdeci">length distance</div><div class="ttdef"><b>Definition:</b> physical_quantity.h:96</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_afa050c988b29285083320111dc7b90ca"><div class="ttname"><a href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">emlabcpp::angle</a></div><div class="ttdeci">physical_quantity&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt; angle</div><div class="ttdef"><b>Definition:</b> physical_quantity.h:84</div></div>
</div><!-- fragment --><p>See examples for more detailed explanation.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
quantity.h</h2>
<p>Simple thin overlay over numeric types, that gives abillity to implement strongly typed numeric types. This is handy in case you want to enforce correctness on type level. See implementation of <code>physical_quantity</code> as an example.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
static_circular_buffer.h</h2>
<p>Basic implementation of circular buffer with static maximal size, that can store non-default constructible elements. No dynamic allocation is used.</p>
<div class="fragment"><div class="line">static_circular_buffer&lt;std::byte, 256&gt; buffr;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : {0,1,2,3,4,5,6})</div>
<div class="line">{</div>
<div class="line">    buffr.push_back(i);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : buffr)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span>(!buffr.empty())</div>
<div class="line">{</div>
<div class="line">    buffr.pop_front();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md28"></a>
static_vector.h</h2>
<p>Basic implementation of vector with static maximal size, that can store non-default constructible elements. No dynamic allocation is used.</p>
<h2><a class="anchor" id="autotoc_md29"></a>
types.h</h2>
<p>A library of helpers for type inspection, this contains types similar to <code>type_traits</code> of standard library. This follows the pattern of <code>std::</code> library - type check is structure with <code>::value</code>/<code>::type</code> attributes and using for <code>_v</code>/<code>_t</code> suffixed aliases exists.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> data = std::vector&lt;int&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> fun = [](<span class="keywordtype">int</span> i) -&gt; std::string</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> std::to_string(i)</div>
<div class="line">};</div>
<div class="line"><span class="keyword">using</span> fun = decltype(fun);</div>
<div class="line"> </div>
<div class="line">static_assert(std::is_same_v&lt;mapped_t&lt;data, fun&gt;, std::string&gt;);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md30"></a>
view.h</h2>
<p>Simple container storing a pair of iterators - non-owning container of data. This make it possible to pass a subset of container to API expecting a container itself. It is also more sensible for functions that would return <code>std::pair</code> of iterators.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data{1,2,3,4,5,6};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : <a class="code" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view</a>{vec_data})</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : <a class="code" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view</a>{vec_data.begin() + 2, vec_data.end()})</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : <a class="code" href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">view_n</a>(vec_data, 4))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i : <a class="code" href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">reversed</a>(vec_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="charliteral">&#39;,&#39;</span>;</div>
<div class="line">}</div>
<div class="line">std::cout &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="ttc" id="anamespaceemlabcpp_html_a2fe2d2bf491db344cf04e4c2b9d799b8"><div class="ttname"><a href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">emlabcpp::reversed</a></div><div class="ttdeci">constexpr auto reversed(referenceable_container auto &amp;container) -&gt; view&lt; decltype(std::rbegin(container)) &gt;</div><div class="ttdoc">Returns view to the Container in reverse order.</div><div class="ttdef"><b>Definition:</b> view.h:207</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a4b726ddab4f550f3e186f177243cb09b"><div class="ttname"><a href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">emlabcpp::view</a></div><div class="ttdeci">view(Container &amp;cont) -&gt; view&lt; iterator_of_t&lt; Container &gt; &gt;</div><div class="ttdoc">The container deduction guide uses iterator_of_t.</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a57c2da6250c29d0cf3d6a0cfecaa1e45"><div class="ttname"><a href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">emlabcpp::view_n</a></div><div class="ttdeci">constexpr view&lt; Iter &gt; view_n(Iter begin, const std::size_t n)</div><div class="ttdoc">Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range!</div><div class="ttdef"><b>Definition:</b> view.h:183</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md31"></a>
visit.h</h2>
<p><code>visit</code> is reimplementation of <code>std::visit</code> that has worse time complexity in exchange of less code being generate for the mechanism. It also drop support for multiple variants.</p>
<h2><a class="anchor" id="autotoc_md32"></a>
zip.h</h2>
<p>zip iterator over multiple data containers, which dereference value is tuple of references to provided containers.</p>
<p>This is especially handy in combination with numeric iterator. Example is <code>enumerate(cont)</code> which returns zip of range over cont size and cont itself, which behaves same as enumerate on python.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; vec_data{-1,1,-1,1,-1,1};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> [i,val] : <a class="code" href="namespaceemlabcpp.html#afe935e56d6376df9f87d0d015a3baecc">enumerate</a>(vec_data))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;\t:&quot;</span> &lt;&lt; val &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">std::vector&lt;std::string&gt; names = {<span class="stringliteral">&quot;john&quot;</span>, <span class="stringliteral">&quot;clark&quot;</span>};</div>
<div class="line">std::vector&lt;std::string&gt; surnames = {<span class="stringliteral">&quot;deer&quot;</span>, <span class="stringliteral">&quot;kent&quot;</span>};</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> [name, surname] : <a class="code" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip</a>(names, surnames))</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="charliteral">&#39;\t&#39;</span> &lt;&lt; surname &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_html_a41ab261a0f296f3c9862e59e12339885"><div class="ttname"><a href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">emlabcpp::zip</a></div><div class="ttdeci">auto zip(Ts &amp;&amp;... cont)</div><div class="ttdoc">Creates a view of zip iterators for specified containers.</div><div class="ttdef"><b>Definition:</b> zip.h:147</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_afe935e56d6376df9f87d0d015a3baecc"><div class="ttname"><a href="namespaceemlabcpp.html#afe935e56d6376df9f87d0d015a3baecc">emlabcpp::enumerate</a></div><div class="ttdeci">auto enumerate(Container &amp;&amp;cont)</div><div class="ttdef"><b>Definition:</b> zip.h:153</div></div>
</div><!-- fragment --> </div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Jun 16 2023 14:04:31 for emlabcpp by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
