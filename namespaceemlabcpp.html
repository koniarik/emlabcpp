<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emlabcpp: emlabcpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emlabcpp
   </div>
   <div id="projectbrief">modern opinionated embedded C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceemlabcpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">emlabcpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceemlabcpp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1access__iterator.html">access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classemlabcpp_1_1access__iterator.html" title="access_iterator provides access to a reference of value stored in the Iterator.">access_iterator</a> provides access to a reference of value stored in the Iterator.  <a href="classemlabcpp_1_1access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1are__same"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a></td></tr>
<tr class="separator:structemlabcpp_1_1are__same"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_01T_00_01Ts_8_8_8_01_4.html">are_same&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_4.html">are_same&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded.html">bounded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded type represents a overlay over type T which is constrained between MinVal and MaxVal as compile time constants.  <a href="classemlabcpp_1_1bounded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded__view.html">bounded_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1convert__iterator.html">convert_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1convert__to.html">convert_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">object with operator() that constructs object of type T out of passed-in value.  <a href="structemlabcpp_1_1convert__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1defer.html">defer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1derived__storage.html">derived_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1either.html">either</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either is heterogenous structure that holds one of the two types specified.  <a href="classemlabcpp_1_1either.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1empty__assembly__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1empty__assembly__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks empty assembly.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1empty__assembly__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1generic__iterator.html">generic_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classemlabcpp_1_1generic__iterator.html" title="generic_iterator is a class using CRTP to ease implementation of custom iterators.">generic_iterator</a> is a class using CRTP to ease implementation of custom iterators.  <a href="classemlabcpp_1_1generic__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__view.html">is_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1iterator__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1iterator__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1mapped"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a></td></tr>
<tr class="separator:structemlabcpp_1_1mapped"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1mapped_3_01Container_00_01UnaryFunction_01_4.html">mapped&lt; Container, UnaryFunction &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure for finding the smallest and the largest item in some container, contains min/max attributes representing such elements.  <a href="structemlabcpp_1_1min__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1numeric__iterator.html">numeric_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">numeric iterator - iterator over numbers (which are calculated on the fly) Value of type T is stored internally and incremented as the iterator is moved forward/backward  <a href="classemlabcpp_1_1numeric__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> represents all physical units defined using the International System of Units and more.  <a href="structemlabcpp_1_1physical__quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1pid.html">pid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pool__base.html">pool_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pool__deleter.html">pool_deleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pool__interface.html">pool_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1pool__resource.html">pool_resource</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__command.html">protocol_command</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command group represents a segment in the message, that may contain multiple different variants of value, that are identified by ID at the beginning of the segment.  <a href="structemlabcpp_1_1protocol__command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__command__group.html">protocol_command_group</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command group should be used as a collection of commands that are selected based on the ID, during the deserialization first command that matches is selected.  <a href="structemlabcpp_1_1protocol__command__group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4">protocol_command_group&lt; Endianess &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__decl"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">protocol_decl</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1protocol__decl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each definition of item provided to protocol library should have specialization of '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl" title="Each definition of item provided to protocol library should have specialization of &#39;protocol_decl&#39; st...">protocol_decl</a>' structure.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__decl"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01bounded_3_01D_00_01Min_00_01Max_01_4_01_4.html">protocol_decl&lt; bounded&lt; D, Min, Max &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01D_01_4.html">protocol_decl&lt; D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__endianess_3_01Endianess_00_01D_01_4_01_4.html">protocol_decl&lt; protocol_endianess&lt; Endianess, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__error__record_01_4.html">protocol_decl&lt; protocol_error_record &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__group_3_01Ds_8_8_8_01_4_01_4.html">protocol_decl&lt; protocol_group&lt; Ds... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__mark_01_4.html">protocol_decl&lt; protocol_mark &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__offset_3_01D_00_01Offset_01_4_01_4.html">protocol_decl&lt; protocol_offset&lt; D, Offset &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__sized__buffer_3_01CounterType_00_01D_01_4_01_4.html">protocol_decl&lt; protocol_sized_buffer&lt; CounterType, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01protocol__sizeless__message_3_01N_01_4_01_4.html">protocol_decl&lt; protocol_sizeless_message&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01static__vector_3_01T_00_01N_01_4_01_4.html">protocol_decl&lt; static_vector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01std_1_1array_3_01D_00_01N_01_4_01_4.html">protocol_decl&lt; std::array&lt; D, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01std_1_1bitset_3_01N_01_4_01_4.html">protocol_decl&lt; std::bitset&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01std_1_1tuple_3_01Ds_8_8_8_01_4_01_4.html">protocol_decl&lt; std::tuple&lt; Ds... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01std_1_1variant_3_01Ds_8_8_8_01_4_01_4.html">protocol_decl&lt; std::variant&lt; Ds... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__decl_3_01tag_3_01V_01_4_01_4.html">protocol_decl&lt; tag&lt; V &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__def"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__def">protocol_def</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1protocol__def"><td class="mdescLeft">&#160;</td><td class="mdescRight">protocol_def&lt;T,E&gt; structure defines how type T should be serialized and deserialized.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__def">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01bounded_3_01D_00_01Min_00_01Max_01_4_00_01Endianess_01_4.html">protocol_def&lt; bounded&lt; D, Min, Max &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01D_00_01Endianess_01_4.html">protocol_def&lt; D, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__endianess_3_01Endianess_00_01D_01_4_00_01ParentEndianess_01_4.html">protocol_def&lt; protocol_endianess&lt; Endianess, D &gt;, ParentEndianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__error__record_00_01Endianess_01_4.html">protocol_def&lt; protocol_error_record, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__group_3_01Ds_8_8_8_01_4_00_01Endianess_01_4.html">protocol_def&lt; protocol_group&lt; Ds... &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__mark_00_01Endianess_01_4.html">protocol_def&lt; protocol_mark, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__offset_3_01D_00_01Offset_01_4_00_01Endianess_01_4.html">protocol_def&lt; protocol_offset&lt; D, Offset &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__sized__buffer_3_01CounterDef_00_01D_01_4_00_01Endianess_01_4.html">protocol_def&lt; protocol_sized_buffer&lt; CounterDef, D &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01protocol__sizeless__message_3_01N_01_4_00_01Endianess_01_4.html">protocol_def&lt; protocol_sizeless_message&lt; N &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01static__vector_3_01T_00_01N_01_4_00_01Endianess_01_4.html">protocol_def&lt; static_vector&lt; T, N &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01std_1_1array_3_01D_00_01N_01_4_00_01Endianess_01_4.html">protocol_def&lt; std::array&lt; D, N &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01std_1_1bitset_3_01N_01_4_00_01Endianess_01_4.html">protocol_def&lt; std::bitset&lt; N &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01std_1_1tuple_3_01Ds_8_8_8_01_4_00_01Endianess_01_4.html">protocol_def&lt; std::tuple&lt; Ds... &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01std_1_1variant_3_01Ds_8_8_8_01_4_00_01Endianess_01_4.html">protocol_def&lt; std::variant&lt; Ds... &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def_3_01tag_3_01V_01_4_00_01Endianess_01_4.html">protocol_def&lt; tag&lt; V &gt;, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__def__type__base.html">protocol_def_type_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">More complex constructs have custom mechanics that internally produces <code>def_type</code> alias used by the library to serialize/deserialize it.  <a href="structemlabcpp_1_1protocol__def__type__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__endianess.html">protocol_endianess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: when able to move to GCC11: using enum protocol_endianess_enum; and make it enum class.  <a href="structemlabcpp_1_1protocol__endianess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__error__record"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__error__record">protocol_error_record</a></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__error__record"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__group"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__group">protocol_group</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1protocol__group"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes values from definitions Ds to std::variant.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__group">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__group"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__handler.html">protocol_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">protocol_handler&lt; T &gt; should be used to execute actual serialization and deserealization of protocol definition.  <a href="structemlabcpp_1_1protocol__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error handling in protocol works with marks.  <a href="structemlabcpp_1_1protocol__mark.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1protocol__message.html">protocol_message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol library has custom type that represents message, however this is just simple overaly over std::array that remembers how many bytes are used.  <a href="classemlabcpp_1_1protocol__message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__offset.html">protocol_offset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value defined by <code>D</code> present in the message is offseted by <code>Offset</code>.  <a href="structemlabcpp_1_1protocol__offset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__packet.html">protocol_packet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__packet__handler.html">protocol_packet_handler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__reg.html">protocol_reg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that represents definition of one register in the map.  <a href="structemlabcpp_1_1protocol__reg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__register__handler.html">protocol_register_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handler for serialization and extraction of datatypes used by the register_map.  <a href="structemlabcpp_1_1protocol__register__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1protocol__register__map.html">protocol_register_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register map is abstraction to work with registers of external devices.  <a href="classemlabcpp_1_1protocol__register__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__result.html">protocol_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strucutre used as result of deserialization in the internal mechanisms of protocol handling.  <a href="structemlabcpp_1_1protocol__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1protocol__sequencer.html">protocol_sequencer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__serializer.html">protocol_serializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__serializer_3_01bool_00_01Endianess_01_4.html">protocol_serializer&lt; bool, Endianess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1protocol__sized__buffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__sized__buffer">protocol_sized_buffer</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1protocol__sized__buffer"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a segment starting with counter defined by CounterDef, this counter limits how many bytes are passed to deserialization process, bytes after the limit ale not considered by this segment.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__sized__buffer">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1protocol__sized__buffer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1protocol__sizeless__message.html">protocol_sizeless_message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sizeless message is class that behaves in a same way as normal <a class="el" href="classemlabcpp_1_1protocol__message.html" title="Protocol library has custom type that represents message, however this is just simple overaly over st...">protocol_message</a>, however it is serialized differently.  <a href="classemlabcpp_1_1protocol__sizeless__message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1protocol__tuple.html">protocol_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structemlabcpp_1_1protocol__tuple.html" title="protocol_tuple is high levle alternative to use just &#39;std::tuple&#39; that is more friendly for standalon...">protocol_tuple</a> is high levle alternative to use just 'std::tuple' that is more friendly for standalone protocols.  <a href="structemlabcpp_1_1protocol__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing generic quantity.  <a href="classemlabcpp_1_1quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1select__utype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a></td></tr>
<tr class="separator:structemlabcpp_1_1select__utype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing circular buffer of any type for up to N elements.  <a href="classemlabcpp_1_1static__circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer__iterator.html">static_circular_buffer_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1static__size.html">static_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data container for up to N elements.  <a href="classemlabcpp_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1subscript__iterator.html">subscript_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript iterator stores reference to given container and index of item.  <a href="classemlabcpp_1_1subscript__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tag.html">tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1tagged__quantity.html">tagged_quantity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__callable__overlay.html">testing_callable_overlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__composer.html">testing_composer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__controller.html">testing_controller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__controller__interface.html">testing_controller_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1testing__controller__message__error"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__message__error">testing_controller_message_error</a></td></tr>
<tr class="separator:structemlabcpp_1_1testing__controller__message__error"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1testing__controller__protocol__error"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__protocol__error">testing_controller_protocol_error</a></td></tr>
<tr class="separator:structemlabcpp_1_1testing__controller__protocol__error"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1testing__controller__reactor__group.html">testing_controller_reactor_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__default__reactor.html">testing_default_reactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__interface.html">testing_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1testing__internal__reactor__error"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__internal__reactor__error">testing_internal_reactor_error</a></td></tr>
<tr class="separator:structemlabcpp_1_1testing__internal__reactor__error"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1testing__packet__def.html">testing_packet_def</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__reactor.html">testing_reactor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1testing__reactor__controller__group.html">testing_reactor_controller_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1testing__reactor__error__group.html">testing_reactor_error_group</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__reactor__interface.html">testing_reactor_interface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1testing__reactor__protocol__error"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__reactor__protocol__error">testing_reactor_protocol_error</a></td></tr>
<tr class="separator:structemlabcpp_1_1testing__reactor__protocol__error"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1testing__record.html">testing_record</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1testing__result.html">testing_result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1tuple__has__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a></td></tr>
<tr class="separator:structemlabcpp_1_1tuple__has__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tuple__has__type_3_01T_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">tuple_has_type&lt; T, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1view.html">view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class to represent view of some container.  <a href="classemlabcpp_1_1view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip_ierator iterates over a group of iterators, where value is a tuple of references to value for each iterator.  <a href="classemlabcpp_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aea3360c0f2ac93edf6576ef57da1749a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea3360c0f2ac93edf6576ef57da1749a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aea3360c0f2ac93edf6576ef57da1749a">pool_unique_ptr</a> = std::unique_ptr&lt; T, <a class="el" href="structemlabcpp_1_1pool__deleter.html">pool_deleter</a> &gt;</td></tr>
<tr class="separator:aea3360c0f2ac93edf6576ef57da1749a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53400461db610368cbe228ab40b5c63d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53400461db610368cbe228ab40b5c63d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a53400461db610368cbe228ab40b5c63d">pool_vector</a> = std::vector&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a53400461db610368cbe228ab40b5c63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3002b266e75831a1f53acc6309e9a772"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3002b266e75831a1f53acc6309e9a772"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3002b266e75831a1f53acc6309e9a772">pool_list</a> = std::list&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a3002b266e75831a1f53acc6309e9a772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af23c0681903c11c3eebbf8043eaf2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3af23c0681903c11c3eebbf8043eaf2c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3af23c0681903c11c3eebbf8043eaf2c">pool_set</a> = std::set&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a3af23c0681903c11c3eebbf8043eaf2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43daa0cfcf1b4444fef3c134b538c492"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43daa0cfcf1b4444fef3c134b538c492"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a43daa0cfcf1b4444fef3c134b538c492">pool_deque</a> = std::deque&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a43daa0cfcf1b4444fef3c134b538c492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a26f08c5adb26bcc69ec7fc1bf42910"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename T &gt; </td></tr>
<tr class="memitem:a3a26f08c5adb26bcc69ec7fc1bf42910"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3a26f08c5adb26bcc69ec7fc1bf42910">pool_map</a> = std::map&lt; Key, T, std::less&lt; Key &gt;, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; std::pair&lt; const Key, T &gt; &gt; &gt;</td></tr>
<tr class="separator:a3a26f08c5adb26bcc69ec7fc1bf42910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb5a005e75f7e4f58008d4ed698e9d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">testing_key_buffer</a> = <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 16 &gt;</td></tr>
<tr class="separator:abfb5a005e75f7e4f58008d4ed698e9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289862982d90d50fae8def7c9491fac3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a289862982d90d50fae8def7c9491fac3">testing_name_buffer</a> = <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 32 &gt;</td></tr>
<tr class="separator:a289862982d90d50fae8def7c9491fac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab961228f0e95ce3f73f42aadfcaa54fd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab961228f0e95ce3f73f42aadfcaa54fd">testing_key</a> = std::variant&lt; uint32_t, <a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">testing_key_buffer</a> &gt;</td></tr>
<tr class="separator:ab961228f0e95ce3f73f42aadfcaa54fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b065acd5c5329faf70e62bda58d26eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9b065acd5c5329faf70e62bda58d26eb">testing_string_buffer</a> = <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 32 &gt;</td></tr>
<tr class="separator:a9b065acd5c5329faf70e62bda58d26eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d9348aa7043abf68885939947f3876"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a00d9348aa7043abf68885939947f3876">testing_arg_variant</a> = std::variant&lt; uint64_t, int64_t, bool, <a class="el" href="namespaceemlabcpp.html#a9b065acd5c5329faf70e62bda58d26eb">testing_string_buffer</a> &gt;</td></tr>
<tr class="separator:a00d9348aa7043abf68885939947f3876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e45204d4f0548306443a2b41a3ce7ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5e45204d4f0548306443a2b41a3ce7ba">testing_run_id</a> = uint32_t</td></tr>
<tr class="separator:a5e45204d4f0548306443a2b41a3ce7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d37dcae87129c4eeba626a3b431d4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af66d37dcae87129c4eeba626a3b431d4">testing_test_id</a> = uint16_t</td></tr>
<tr class="separator:af66d37dcae87129c4eeba626a3b431d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f9646ab3c944247009330cf42fd46a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a23f9646ab3c944247009330cf42fd46a">testing_error_variant</a> = std::variant&lt; <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__reactor__protocol__error">testing_reactor_protocol_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__protocol__error">testing_controller_protocol_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__internal__reactor__error">testing_internal_reactor_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__message__error">testing_controller_message_error</a> &gt;</td></tr>
<tr class="separator:a23f9646ab3c944247009330cf42fd46a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a34bbef6dd4f379a490c3311a6e2e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0e6a34bbef6dd4f379a490c3311a6e2e">testing_controller_reactor_variant</a> = typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_controller_reactor_group::value_type</a></td></tr>
<tr class="separator:a0e6a34bbef6dd4f379a490c3311a6e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e2a4fdbfa5c03cfededbdba72d4aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aec6e2a4fdbfa5c03cfededbdba72d4aa">testing_reactor_error_variant</a> = typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_reactor_error_group::value_type</a></td></tr>
<tr class="separator:aec6e2a4fdbfa5c03cfededbdba72d4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09926c7b0fd256972b4ce24e0ffe27fb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a09926c7b0fd256972b4ce24e0ffe27fb">testing_reactor_controller_variant</a> = typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_reactor_controller_group::value_type</a></td></tr>
<tr class="separator:a09926c7b0fd256972b4ce24e0ffe27fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5bb7446964b58645c8c8f480f06ec2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aad5bb7446964b58645c8c8f480f06ec2">testing_reactor_controller_packet</a> = <a class="el" href="structemlabcpp_1_1protocol__packet.html">protocol_packet</a>&lt; <a class="el" href="structemlabcpp_1_1testing__packet__def.html">testing_packet_def</a>, <a class="el" href="structemlabcpp_1_1testing__reactor__controller__group.html">testing_reactor_controller_group</a> &gt;</td></tr>
<tr class="separator:aad5bb7446964b58645c8c8f480f06ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a648640c7a757908fba8c9716f4493e19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a648640c7a757908fba8c9716f4493e19">testing_controller_reactor_packet</a> = <a class="el" href="structemlabcpp_1_1protocol__packet.html">protocol_packet</a>&lt; <a class="el" href="structemlabcpp_1_1testing__packet__def.html">testing_packet_def</a>, <a class="el" href="structemlabcpp_1_1testing__controller__reactor__group.html">testing_controller_reactor_group</a> &gt;</td></tr>
<tr class="separator:a648640c7a757908fba8c9716f4493e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb54919fd16f1fec2a66196473d126f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1bb54919fd16f1fec2a66196473d126f">testing_reactor_controller_msg</a> = typename <a class="el" href="structemlabcpp_1_1protocol__tuple.html#a02a32b8fb4d05f889e957df042b9a49c">testing_reactor_controller_packet::message_type</a></td></tr>
<tr class="separator:a1bb54919fd16f1fec2a66196473d126f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770bca1b8326991fba1ab2031fdae8c3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a770bca1b8326991fba1ab2031fdae8c3">testing_controller_reactor_msg</a> = typename <a class="el" href="structemlabcpp_1_1protocol__tuple.html#a02a32b8fb4d05f889e957df042b9a49c">testing_controller_reactor_packet::message_type</a></td></tr>
<tr class="separator:a770bca1b8326991fba1ab2031fdae8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632193a7b6636e1de8cb134a2e17acb7"><td class="memTemplParams" colspan="2">template&lt;typename Def , typename Payload &gt; </td></tr>
<tr class="memitem:a632193a7b6636e1de8cb134a2e17acb7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a632193a7b6636e1de8cb134a2e17acb7">protocol_packet_base</a> = <a class="el" href="structemlabcpp_1_1protocol__tuple.html">protocol_tuple</a>&lt; Def::endianess, std::decay_t&lt; decltype(Def::prefix) &gt;, typename Def::size_type, Payload, typename Def::checksum_type &gt;</td></tr>
<tr class="separator:a632193a7b6636e1de8cb134a2e17acb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td></tr>
<tr class="separator:a98ab53b012e339a9621604b203df856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dffbbe090c31e17065033d3662e823e"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:a2dffbbe090c31e17065033d3662e823e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2dffbbe090c31e17065033d3662e823e">mapped_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &gt;::type</td></tr>
<tr class="separator:a2dffbbe090c31e17065033d3662e823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">select_utype_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;::type</td></tr>
<tr class="separator:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a39c432c01b63c755cc8dd093c6c770d4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4">testing_messages_enum</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a72a4a7574af7a6c7d0b995c0fe6c8d08">TESTING_EXEC</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a731e8c7354bf5b01bca2045f5aef28a4">TESTING_COUNT</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4ae72b70736c7329e4159daa2922dd1744">TESTING_NAME</a> = 0x3, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a268d8a6175f3026117a34a043b03126f">TESTING_LOAD</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a67cda21402e7f8d8e57db5061f23460b">TESTING_ARG</a> = 0x5, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a1401c5abbdf222f7455220c37b788a96">TESTING_SUITE_NAME</a> = 0x6, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a6922eaa8737dea23f704750296c38ab2">TESTING_SUITE_DATE</a> = 0x7, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4aa0261eb0084a09514bfd63fc40dc3ac3">TESTING_COLLECT</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a995df505cfa8b23d094558924d2ed8fe">TESTING_FINISHED</a> = 0x9, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a2d2e75d3dd5ed8612b8a0d1f7763f662">TESTING_ERROR</a> = 0xa, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a5581441dee07e66569e90234d72f3e2e">TESTING_FAILURE</a> = 0xb, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a4790daa6f3f53eef479401fd60851447">TESTING_INTERNAL_ERROR</a> = 0xf0, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4a2c6a5c63099d8c4f7c77cbfbe3449ae2">TESTING_PROTOCOL_ERROR</a> = 0xf1, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4ae02f98d1bd046edd7cb9f5cb3c45e9df">TESTING_ARG_MISSING</a> = 0xf2
<br />
 }</td></tr>
<tr class="separator:a39c432c01b63c755cc8dd093c6c770d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b0d10071d3c9ba7c7b47555aa23f3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3">testing_error_enum</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a2f44719f4ae62abcbcae09b6f4010b7f">TESTING_TEST_NOT_LOADED_E</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a28e5f8b0ff0672d27b28c78b7f22f2db">TESTING_TEST_NOT_FOUND_E</a> = 2, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a367033ddcb9df760599f7d1f7f8c86ef">TESTING_WRONG_RUN_ID_E</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a1f86d9296a3a68b2172ace730e28dbd2">TESTING_TEST_ALREADY_LOADED_E</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a00e9b5aca5441fd3028c81e5086e7e99">TESTING_BAD_TEST_ID_E</a> = 5, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a77465a2c1b2a26e18c4e71f414040d33">TESTING_UNDESIRED_MSG_E</a> = 6, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3ab67b11ebc9d2740f26e1e8405f3d0b91">TESTING_NO_RESPONSE_E</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a870a0ce413caecadb69b503aece3c8cf">TESTING_ARG_MISSING_E</a> = 8, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3a5dc0562ae996c4a4fb7d49869946022d">TESTING_ARG_WRONG_MESSAGE_E</a> = 9, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3aa9b1e9ac9d77246619ac5dc1f935cb37">TESTING_ARG_WRONG_TYPE_E</a> = 10
<br />
 }</td></tr>
<tr class="separator:ab01b0d10071d3c9ba7c7b47555aa23f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efd2ac8dd2ca532b893b1c26565c594"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594">protocol_endianess_enum</a> { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594a53be8bce457a43c78d5047cded7dca4a">PROTOCOL_BIG_ENDIAN</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594aa2f671a4536141c87fc72a132d46d839">PROTOCOL_LITTLE_ENDIAN</a>
<br />
 }</td></tr>
<tr class="memdesc:a7efd2ac8dd2ca532b893b1c26565c594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum specifies what endianess should be used.  <a href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594">More...</a><br /></td></tr>
<tr class="separator:a7efd2ac8dd2ca532b893b1c26565c594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7c44a24d63104ca748cfad65fb1e588"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab7c44a24d63104ca748cfad65fb1e588"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab7c44a24d63104ca748cfad65fb1e588">ignore</a> (T &amp;&amp;)</td></tr>
<tr class="memdesc:ab7c44a24d63104ca748cfad65fb1e588"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes necessary to disable warnings of unused arguments Hint: use std::ignore.  <a href="namespaceemlabcpp.html#ab7c44a24d63104ca748cfad65fb1e588">More...</a><br /></td></tr>
<tr class="separator:ab7c44a24d63104ca748cfad65fb1e588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee3ba374b4601759b8c7dd7b2ddfe3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61ee3ba374b4601759b8c7dd7b2ddfe3"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a61ee3ba374b4601759b8c7dd7b2ddfe3">sign</a> (T &amp;&amp;val)</td></tr>
<tr class="memdesc:a61ee3ba374b4601759b8c7dd7b2ddfe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sign of variable T: -1,0,1  <a href="namespaceemlabcpp.html#a61ee3ba374b4601759b8c7dd7b2ddfe3">More...</a><br /></td></tr>
<tr class="separator:a61ee3ba374b4601759b8c7dd7b2ddfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplParams" colspan="2">template&lt;arithmetic_operators T, arithmetic_operators U&gt; </td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">map_range</a> (T input, T from_min, T from_max, U to_min, U to_max)</td></tr>
<tr class="memdesc:a0abef993d302d6b6d93fe877ca62491c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps input value 'input' from input range to equivalent value in output range  <a href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">More...</a><br /></td></tr>
<tr class="separator:a0abef993d302d6b6d93fe877ca62491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631eb361805aa7459b944503f7538951"><td class="memTemplParams" colspan="2">template&lt;container Container&gt; </td></tr>
<tr class="memitem:a631eb361805aa7459b944503f7538951"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size</a> (const Container &amp;cont) noexcept</td></tr>
<tr class="memdesc:a631eb361805aa7459b944503f7538951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the container, regardless of what it is.  <a href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">More...</a><br /></td></tr>
<tr class="separator:a631eb361805aa7459b944503f7538951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d436ac46a18d3b5aa2e2e8f253c656b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d436ac46a18d3b5aa2e2e8f253c656b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4d436ac46a18d3b5aa2e2e8f253c656b">almost_equal</a> (const T &amp;lh, const T &amp;rh, float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="memdesc:a4d436ac46a18d3b5aa2e2e8f253c656b"><td class="mdescLeft">&#160;</td><td class="mdescRight">two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps'  <a href="namespaceemlabcpp.html#a4d436ac46a18d3b5aa2e2e8f253c656b">More...</a><br /></td></tr>
<tr class="separator:a4d436ac46a18d3b5aa2e2e8f253c656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32164e98bc7489fa79dcfa50a7760028"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a32164e98bc7489fa79dcfa50a7760028"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a32164e98bc7489fa79dcfa50a7760028">tail</a> (Container &amp;&amp;cont, int step=1)</td></tr>
<tr class="memdesc:a32164e98bc7489fa79dcfa50a7760028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips first item of container.  <a href="namespaceemlabcpp.html#a32164e98bc7489fa79dcfa50a7760028">More...</a><br /></td></tr>
<tr class="separator:a32164e98bc7489fa79dcfa50a7760028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1440686048e000936426ed21aa3295"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a1d1440686048e000936426ed21aa3295"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1d1440686048e000936426ed21aa3295">init</a> (Container &amp;&amp;cont, int step=1)</td></tr>
<tr class="memdesc:a1d1440686048e000936426ed21aa3295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips last item of container.  <a href="namespaceemlabcpp.html#a1d1440686048e000936426ed21aa3295">More...</a><br /></td></tr>
<tr class="separator:a1d1440686048e000936426ed21aa3295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf83e29aeab35a17d15504a6dd57dd20"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:aaf83e29aeab35a17d15504a6dd57dd20"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaf83e29aeab35a17d15504a6dd57dd20">find_if</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:aaf83e29aeab35a17d15504a6dd57dd20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator for first item, for which call to f(*iter) holds true.  <a href="namespaceemlabcpp.html#aaf83e29aeab35a17d15504a6dd57dd20">More...</a><br /></td></tr>
<tr class="separator:aaf83e29aeab35a17d15504a6dd57dd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr std</td></tr>
<tr class="memdesc:aab6fd32a8b3335eec93b94331d4293b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of an element in tuple 't', for which call to f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple.  <a href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">More...</a><br /></td></tr>
<tr class="separator:aab6fd32a8b3335eec93b94331d4293b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T &gt; </td></tr>
<tr class="memitem:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">find</a> (Container &amp;&amp;cont, const T &amp;item)</td></tr>
<tr class="memdesc:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds first item in container 'cont' that is equal to 'item', returns iterator for container and index for tuples.  <a href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">More...</a><br /></td></tr>
<tr class="separator:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryFunction&gt; </td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr void <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each</a>(Container &amp;&amp;cont</td></tr>
<tr class="memdesc:a670099942b8cdd3d2cc28760b1717d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary function 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">More...</a><br /></td></tr>
<tr class="separator:a670099942b8cdd3d2cc28760b1717d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836376ebd63413e70abd97e0c49cca90"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryFunction&gt; </td></tr>
<tr class="memitem:a836376ebd63413e70abd97e0c49cca90"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:a836376ebd63413e70abd97e0c49cca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary function 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">More...</a><br /></td></tr>
<tr class="separator:a836376ebd63413e70abd97e0c49cca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664cee55fc768377c8588638004e9d98"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:a664cee55fc768377c8588638004e9d98"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a664cee55fc768377c8588638004e9d98">min_max_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a664cee55fc768377c8588638004e9d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary function 'f(x)' to each element of container 'cont', returns the largest and the smallest return value.  <a href="namespaceemlabcpp.html#a664cee55fc768377c8588638004e9d98">More...</a><br /></td></tr>
<tr class="separator:a664cee55fc768377c8588638004e9d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d14c00034fb21bef638c10fa08e5312"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:a5d14c00034fb21bef638c10fa08e5312"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5d14c00034fb21bef638c10fa08e5312">max_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a5d14c00034fb21bef638c10fa08e5312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary function 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls.  <a href="namespaceemlabcpp.html#a5d14c00034fb21bef638c10fa08e5312">More...</a><br /></td></tr>
<tr class="separator:a5d14c00034fb21bef638c10fa08e5312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b1b453f873c2ecebd79d2c8796393"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::remove_reference_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:ad61b1b453f873c2ecebd79d2c8796393"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad61b1b453f873c2ecebd79d2c8796393">min_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:ad61b1b453f873c2ecebd79d2c8796393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary function 'f(x) to each element of container 'cont, returns the smallest return value of 'f(x)' calls.  <a href="namespaceemlabcpp.html#ad61b1b453f873c2ecebd79d2c8796393">More...</a><br /></td></tr>
<tr class="separator:ad61b1b453f873c2ecebd79d2c8796393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f32e86c3dfcebce5092b96b5152e94e"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:a1f32e86c3dfcebce5092b96b5152e94e"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1f32e86c3dfcebce5092b96b5152e94e">count</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a1f32e86c3dfcebce5092b96b5152e94e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the unary function 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'.  <a href="namespaceemlabcpp.html#a1f32e86c3dfcebce5092b96b5152e94e">More...</a><br /></td></tr>
<tr class="separator:a1f32e86c3dfcebce5092b96b5152e94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f78b7389a240de94195008ba1efb03"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:af1f78b7389a240de94195008ba1efb03"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af1f78b7389a240de94195008ba1efb03">sum</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity(), T <a class="el" href="namespaceemlabcpp.html#a1d1440686048e000936426ed21aa3295">init</a>={})</td></tr>
<tr class="memdesc:af1f78b7389a240de94195008ba1efb03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item.  <a href="namespaceemlabcpp.html#af1f78b7389a240de94195008ba1efb03">More...</a><br /></td></tr>
<tr class="separator:af1f78b7389a240de94195008ba1efb03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d8a4c83393034954b54b0dd6191238"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:a01d8a4c83393034954b54b0dd6191238"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a01d8a4c83393034954b54b0dd6191238">accumulate</a> (const Container &amp;cont, T <a class="el" href="namespaceemlabcpp.html#a1d1440686048e000936426ed21aa3295">init</a>, BinaryFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:a01d8a4c83393034954b54b0dd6191238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, the return value is 'init' value for next round.  <a href="namespaceemlabcpp.html#a01d8a4c83393034954b54b0dd6191238">More...</a><br /></td></tr>
<tr class="separator:a01d8a4c83393034954b54b0dd6191238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82edfd68c59439561d561afe519d68a1"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:a82edfd68c59439561d561afe519d68a1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a82edfd68c59439561d561afe519d68a1">avg</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a82edfd68c59439561d561afe519d68a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function 'f(x)' to each element of container 'cont' and returns the average value of each call.  <a href="namespaceemlabcpp.html#a82edfd68c59439561d561afe519d68a1">More...</a><br /></td></tr>
<tr class="separator:a82edfd68c59439561d561afe519d68a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2da72b049f415878bb6a90c76e165bd"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:ac2da72b049f415878bb6a90c76e165bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac2da72b049f415878bb6a90c76e165bd">variance</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:ac2da72b049f415878bb6a90c76e165bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies function 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call.  <a href="namespaceemlabcpp.html#ac2da72b049f415878bb6a90c76e165bd">More...</a><br /></td></tr>
<tr class="separator:ac2da72b049f415878bb6a90c76e165bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea1d9aee5b35015e7e174fe87c2b6d8"><td class="memTemplParams" colspan="2">template&lt;container LhContainer, container RhContainer, typename BinaryFunction &gt; </td></tr>
<tr class="memitem:adea1d9aee5b35015e7e174fe87c2b6d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adea1d9aee5b35015e7e174fe87c2b6d8">for_cross_joint</a> (LhContainer &amp;&amp;lh_cont, RhContainer &amp;&amp;rh_cont, BinaryFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:adea1d9aee5b35015e7e174fe87c2b6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies binary function 'f(x,y)' to each combination of items x in lh_cont and y in rh_cont.  <a href="namespaceemlabcpp.html#adea1d9aee5b35015e7e174fe87c2b6d8">More...</a><br /></td></tr>
<tr class="separator:adea1d9aee5b35015e7e174fe87c2b6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb7bfbbedea4be369b14c29286045a"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:ae1eb7bfbbedea4be369b14c29286045a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae1eb7bfbbedea4be369b14c29286045a">any_of</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:ae1eb7bfbbedea4be369b14c29286045a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to function 'f(x)' returns true for at least one item in 'cont'.  <a href="namespaceemlabcpp.html#ae1eb7bfbbedea4be369b14c29286045a">More...</a><br /></td></tr>
<tr class="separator:ae1eb7bfbbedea4be369b14c29286045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a10ef3efe9c65ebacc0b32339f87a8"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:a48a10ef3efe9c65ebacc0b32339f87a8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a48a10ef3efe9c65ebacc0b32339f87a8">none_of</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a48a10ef3efe9c65ebacc0b32339f87a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to function 'f(x)' returns false for all items in 'cont'.  <a href="namespaceemlabcpp.html#a48a10ef3efe9c65ebacc0b32339f87a8">More...</a><br /></td></tr>
<tr class="separator:a48a10ef3efe9c65ebacc0b32339f87a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23dacc40d13b4848a3af667493a8af9"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:af23dacc40d13b4848a3af667493a8af9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af23dacc40d13b4848a3af667493a8af9">all_of</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:af23dacc40d13b4848a3af667493a8af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to function 'f(x)' returns true for all items in 'cont'.  <a href="namespaceemlabcpp.html#af23dacc40d13b4848a3af667493a8af9">More...</a><br /></td></tr>
<tr class="separator:af23dacc40d13b4848a3af667493a8af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67efeff1b8f5b0bb2beea241f352b7a"><td class="memTemplParams" colspan="2">template&lt;range_container LhContainer, range_container RhContainer&gt; </td></tr>
<tr class="memitem:aa67efeff1b8f5b0bb2beea241f352b7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa67efeff1b8f5b0bb2beea241f352b7a">equal</a> (const LhContainer &amp;lh, const RhContainer &amp;rh)</td></tr>
<tr class="memdesc:aa67efeff1b8f5b0bb2beea241f352b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of containers 'lh' and 'rh' has same size and lh[i] == rh[i] for all 0 &lt;= i &lt; size()  <a href="namespaceemlabcpp.html#aa67efeff1b8f5b0bb2beea241f352b7a">More...</a><br /></td></tr>
<tr class="separator:aa67efeff1b8f5b0bb2beea241f352b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da5d4d444c6f27cbb7df3532ec601cc"><td class="memTemplParams" colspan="2">template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </td></tr>
<tr class="memitem:a5da5d4d444c6f27cbb7df3532ec601cc"><td class="memTemplItemLeft" align="right" valign="top">ResultContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5da5d4d444c6f27cbb7df3532ec601cc">map_f</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity())</td></tr>
<tr class="memdesc:a5da5d4d444c6f27cbb7df3532ec601cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls function f(x) for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned out of the function.  <a href="namespaceemlabcpp.html#a5da5d4d444c6f27cbb7df3532ec601cc">More...</a><br /></td></tr>
<tr class="separator:a5da5d4d444c6f27cbb7df3532ec601cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e371a56f9ef085edf29095a9a4b45e0"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:a2e371a56f9ef085edf29095a9a4b45e0"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2e371a56f9ef085edf29095a9a4b45e0">map_f_to_a</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>=std::identity()) <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>(!<a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; Container &gt;)</td></tr>
<tr class="memdesc:a2e371a56f9ef085edf29095a9a4b45e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls function f(cont[i]) for i = 0...N and stores the result in array of an appropiate size.  <a href="namespaceemlabcpp.html#a2e371a56f9ef085edf29095a9a4b45e0">More...</a><br /></td></tr>
<tr class="separator:a2e371a56f9ef085edf29095a9a4b45e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d0a9dee2cae8fb64d8be9814c0a032"><td class="memTemplParams" colspan="2">template&lt;range_container Container, typename T &gt; </td></tr>
<tr class="memitem:a39d0a9dee2cae8fb64d8be9814c0a032"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a39d0a9dee2cae8fb64d8be9814c0a032">joined</a> (const Container &amp;cont, T &amp;&amp;val)</td></tr>
<tr class="memdesc:a39d0a9dee2cae8fb64d8be9814c0a032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cont[0] + val + cont[1] + val + cont[2] + ...  <a href="namespaceemlabcpp.html#a39d0a9dee2cae8fb64d8be9814c0a032">More...</a><br /></td></tr>
<tr class="separator:a39d0a9dee2cae8fb64d8be9814c0a032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8122a76a018ca59cc0549b02ed18523"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename NullFunction &gt; </td></tr>
<tr class="memitem:ae8122a76a018ca59cc0549b02ed18523"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae8122a76a018ca59cc0549b02ed18523">for_each_index</a> (NullFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:ae8122a76a018ca59cc0549b02ed18523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary function <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f()</a> with template argument of type 'std::size_t', which ranges from 0 to i.  <a href="namespaceemlabcpp.html#ae8122a76a018ca59cc0549b02ed18523">More...</a><br /></td></tr>
<tr class="separator:ae8122a76a018ca59cc0549b02ed18523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349d57e03a29dec812f941205b421f91"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename PredFunction &gt; </td></tr>
<tr class="memitem:a349d57e03a29dec812f941205b421f91"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a349d57e03a29dec812f941205b421f91">until_index</a> (PredFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:a349d57e03a29dec812f941205b421f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary predicate <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f()</a> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true.  <a href="namespaceemlabcpp.html#a349d57e03a29dec812f941205b421f91">More...</a><br /></td></tr>
<tr class="separator:a349d57e03a29dec812f941205b421f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3798c779ce948989ea0a3c699bc74b59"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename NullFunction &gt; </td></tr>
<tr class="memitem:a3798c779ce948989ea0a3c699bc74b59"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3798c779ce948989ea0a3c699bc74b59">requires</a> (!requires(NullFunction <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}) const expr auto <a class="el" href="namespaceemlabcpp.html#a682d97f0829a04051ce4240be4312a9a">select_index</a>(IndexType i</td></tr>
<tr class="memdesc:a3798c779ce948989ea0a3c699bc74b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function expectes bounded value as index input and callable nullary function.  <a href="namespaceemlabcpp.html#a3798c779ce948989ea0a3c699bc74b59">More...</a><br /></td></tr>
<tr class="separator:a3798c779ce948989ea0a3c699bc74b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682d97f0829a04051ce4240be4312a9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a682d97f0829a04051ce4240be4312a9a">select_index</a> (i, [&amp;]&lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();})</td></tr>
<tr class="separator:a682d97f0829a04051ce4240be4312a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff9499fee336e01a6b1a70d8d6fd63d"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename NullFunction &gt; </td></tr>
<tr class="memitem:aeff9499fee336e01a6b1a70d8d6fd63d"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeff9499fee336e01a6b1a70d8d6fd63d">requires</a> (NullFunction <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="separator:aeff9499fee336e01a6b1a70d8d6fd63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3014f69ce198b53f5238543e98cc6970"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3014f69ce198b53f5238543e98cc6970">select_index</a> (IndexType i, NullFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="separator:a3014f69ce198b53f5238543e98cc6970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b8276158ed7d743c68c7395ed0966"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3c4b8276158ed7d743c68c7395ed0966">align</a> (void *ptr, std::size_t alignment)</td></tr>
<tr class="memdesc:a3c4b8276158ed7d743c68c7395ed0966"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: this needs tests.  <a href="namespaceemlabcpp.html#a3c4b8276158ed7d743c68c7395ed0966">More...</a><br /></td></tr>
<tr class="separator:a3c4b8276158ed7d743c68c7395ed0966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7076d68b2c2f2c0114502a2c7b0ce5"><td class="memTemplParams" colspan="2">template&lt;typename T , T FromLh, T ToLh, T FromRh, T ToRh&gt; </td></tr>
<tr class="memitem:aeb7076d68b2c2f2c0114502a2c7b0ce5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromLh+FromRh, ToLh+ToRh &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeb7076d68b2c2f2c0114502a2c7b0ce5">operator+</a> (const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromLh, ToLh &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromRh, ToRh &gt; &amp;rh)</td></tr>
<tr class="memdesc:aeb7076d68b2c2f2c0114502a2c7b0ce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of two bounded types of same base type is bounded within appropiate ranges.  <a href="namespaceemlabcpp.html#aeb7076d68b2c2f2c0114502a2c7b0ce5">More...</a><br /></td></tr>
<tr class="separator:aeb7076d68b2c2f2c0114502a2c7b0ce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f10b2ff6c20f2e8057487e521275521"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, typename T , T MinVal, T MaxVal&gt; </td></tr>
<tr class="memitem:a2f10b2ff6c20f2e8057487e521275521"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2f10b2ff6c20f2e8057487e521275521">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, MinVal, MaxVal &gt; &amp;b)</td></tr>
<tr class="separator:a2f10b2ff6c20f2e8057487e521275521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1either.html">either</a>&lt; std::tuple&lt; Ts... &gt;, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">assemble_optionals</a> (std::optional&lt; Ts &gt; &amp;&amp;... opt)</td></tr>
<tr class="memdesc:ac30a98c58cf8a76fa9363a0d19c09486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets a set of various std::optionals and either returns all their values assembled as tuple or '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag" title="Marks empty assembly.">empty_assembly_tag</a>' implicating that some of the optionals was empty.  <a href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">More...</a><br /></td></tr>
<tr class="separator:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d3a03f11c2e95874c23956020a755"><td class="memTemplParams" colspan="2">template&lt;typename FirstE , typename... Eithers&gt; </td></tr>
<tr class="memitem:a306d3a03f11c2e95874c23956020a755"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a306d3a03f11c2e95874c23956020a755">assemble_left_collect_right</a> (FirstE &amp;&amp;first, Eithers &amp;&amp;... others) <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>(std</td></tr>
<tr class="memdesc:a306d3a03f11c2e95874c23956020a755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function expects eithers of any left type, but same right type.  <a href="namespaceemlabcpp.html#a306d3a03f11c2e95874c23956020a755">More...</a><br /></td></tr>
<tr class="separator:a306d3a03f11c2e95874c23956020a755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2cc6723ddd36a82e4ed013601e7725"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d2cc6723ddd36a82e4ed013601e7725"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3d2cc6723ddd36a82e4ed013601e7725">testing_string_to_buffer</a> (std::string_view sview)</td></tr>
<tr class="memdesc:a3d2cc6723ddd36a82e4ed013601e7725"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: maybe make a function in <a class="el" href="classemlabcpp_1_1static__vector.html" title="Data container for up to N elements.">static_vector</a> namespace?  <a href="namespaceemlabcpp.html#a3d2cc6723ddd36a82e4ed013601e7725">More...</a><br /></td></tr>
<tr class="separator:a3d2cc6723ddd36a82e4ed013601e7725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9142ef85b5234e04943a331ec21ebab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceemlabcpp.html#a289862982d90d50fae8def7c9491fac3">testing_name_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac9142ef85b5234e04943a331ec21ebab">testing_name_to_buffer</a> (std::string_view sview)</td></tr>
<tr class="separator:ac9142ef85b5234e04943a331ec21ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db275e21ec862a7a5eb6a6cb576280b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">testing_key_buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5db275e21ec862a7a5eb6a6cb576280b">testing_key_to_buffer</a> (std::string_view key)</td></tr>
<tr class="separator:a5db275e21ec862a7a5eb6a6cb576280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a04e29c11b2fc9f9973df1f901d77d2"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0a04e29c11b2fc9f9973df1f901d77d2">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__reactor__protocol__error">testing_reactor_protocol_error</a> &amp;e)</td></tr>
<tr class="separator:a0a04e29c11b2fc9f9973df1f901d77d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980b29573323f3e8dfd06067217bb89"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac980b29573323f3e8dfd06067217bb89">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__protocol__error">testing_controller_protocol_error</a> &amp;e)</td></tr>
<tr class="separator:ac980b29573323f3e8dfd06067217bb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640eedd7f28f5edf3c27cf94144a7609"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a640eedd7f28f5edf3c27cf94144a7609">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__internal__reactor__error">testing_internal_reactor_error</a> &amp;e)</td></tr>
<tr class="separator:a640eedd7f28f5edf3c27cf94144a7609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1db526d44b83d4c607b6b3698dfa64"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afe1db526d44b83d4c607b6b3698dfa64">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__message__error">testing_controller_message_error</a> &amp;e)</td></tr>
<tr class="separator:afe1db526d44b83d4c607b6b3698dfa64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaf334318cd4212e035e0252c7e98bd"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeaaf334318cd4212e035e0252c7e98bd">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#a23f9646ab3c944247009330cf42fd46a">testing_error_variant</a> &amp;var)</td></tr>
<tr class="separator:aeaaf334318cd4212e035e0252c7e98bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2330aaaa31e126417ac8ff0ac1fe5b7"><td class="memTemplParams" colspan="2">template&lt;testing_test T, testing_callable C&gt; </td></tr>
<tr class="memitem:ae2330aaaa31e126417ac8ff0ac1fe5b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1testing__composer.html">testing_composer</a>&lt; T, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae2330aaaa31e126417ac8ff0ac1fe5b7">testing_compose</a> (T t, C c)</td></tr>
<tr class="separator:ae2330aaaa31e126417ac8ff0ac1fe5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1718357386396f122c78205b00bed08c"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename AccessFunction &gt; </td></tr>
<tr class="memitem:a1718357386396f122c78205b00bed08c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1access__iterator.html">access_iterator</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt;, AccessFunction &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1718357386396f122c78205b00bed08c">access_view</a> (Container &amp;&amp;cont, AccessFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="memdesc:a1718357386396f122c78205b00bed08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates view ver container cont with AccessFunction f.  <a href="namespaceemlabcpp.html#a1718357386396f122c78205b00bed08c">More...</a><br /></td></tr>
<tr class="separator:a1718357386396f122c78205b00bed08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6938a08fc2b09d704fc4e6e8ea5b0b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:ab6938a08fc2b09d704fc4e6e8ea5b0b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1convert__iterator.html">convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab6938a08fc2b09d704fc4e6e8ea5b0b9">convert_view</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:ab6938a08fc2b09d704fc4e6e8ea5b0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ec7e0f819d5864f4e1db7a7a4aafdc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator &gt; </td></tr>
<tr class="memitem:a87ec7e0f819d5864f4e1db7a7a4aafdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1convert__iterator.html">convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a87ec7e0f819d5864f4e1db7a7a4aafdc">convert_view_n</a> (Iterator begin, std::size_t n)</td></tr>
<tr class="separator:a87ec7e0f819d5864f4e1db7a7a4aafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b40baac2662db6424a475292ef03b3"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:ac4b40baac2662db6424a475292ef03b3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1numeric__iterator.html">numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac4b40baac2662db6424a475292ef03b3">range</a> (Numeric from, Numeric to)</td></tr>
<tr class="memdesc:ac4b40baac2662db6424a475292ef03b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [from, to)  <a href="namespaceemlabcpp.html#ac4b40baac2662db6424a475292ef03b3">More...</a><br /></td></tr>
<tr class="separator:ac4b40baac2662db6424a475292ef03b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d76a81f2d964ef275dd31aab2737973"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:a2d76a81f2d964ef275dd31aab2737973"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1numeric__iterator.html">numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2d76a81f2d964ef275dd31aab2737973">range</a> (Numeric to)</td></tr>
<tr class="memdesc:a2d76a81f2d964ef275dd31aab2737973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [0, to)  <a href="namespaceemlabcpp.html#a2d76a81f2d964ef275dd31aab2737973">More...</a><br /></td></tr>
<tr class="separator:a2d76a81f2d964ef275dd31aab2737973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1323b0b8ce43a44ca13753d457260"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a46f1323b0b8ce43a44ca13753d457260"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1subscript__iterator.html">subscript_iterator</a>&lt; Container &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a46f1323b0b8ce43a44ca13753d457260">subscript_view</a> (Container &amp;cont)</td></tr>
<tr class="separator:a46f1323b0b8ce43a44ca13753d457260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplParams" colspan="2">template&lt;typename... Callables&gt; </td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab077da8cbabe4cc68820537ddc602b91">matcher</a> (Callables &amp;&amp;...) -&gt; <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td></tr>
<tr class="separator:ab077da8cbabe4cc68820537ddc602b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a63a6aaa5fc338d3d342d90a14225fe82">apply_on_match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">operator*</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a384e4bb5a921ff231358ff63aeecbe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together.  <a href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">More...</a><br /></td></tr>
<tr class="separator:a384e4bb5a921ff231358ff63aeecbe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">operator/</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted.  <a href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">More...</a><br /></td></tr>
<tr class="separator:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplParams" colspan="2">template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a5519896c5f0324265089711b6a020642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of physical quantity is square root of it's value and the exponents are divided in half.  <a href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">More...</a><br /></td></tr>
<tr class="separator:a5519896c5f0324265089711b6a020642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplParams" colspan="2">template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a9b9eb800885b61e8071ef11e69debdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power of physical quantity is power of root of it's value and the exponents are multiplied by the value.  <a href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">More...</a><br /></td></tr>
<tr class="separator:a9b9eb800885b61e8071ef11e69debdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb44994cf1fc5a0a2bfc4896ee8332de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a> (const char(&amp;msg)[17])</td></tr>
<tr class="memdesc:acb44994cf1fc5a0a2bfc4896ee8332de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="structemlabcpp_1_1protocol__mark.html" title="Error handling in protocol works with marks.">protocol_mark</a> from simple string literal.  <a href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">More...</a><br /></td></tr>
<tr class="separator:acb44994cf1fc5a0a2bfc4896ee8332de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b1cef1d03b8bfeb3f4e81f54a72dba"><td class="memTemplParams" colspan="2">template&lt;typename Map , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:af2b1cef1d03b8bfeb3f4e81f54a72dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af2b1cef1d03b8bfeb3f4e81f54a72dba">protocol_for_each_register</a> (const Map &amp;m, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>)</td></tr>
<tr class="separator:af2b1cef1d03b8bfeb3f4e81f54a72dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af5aa50c92bf95bb01b6eb333b32dcd"><td class="memTemplParams" colspan="2">template&lt;typename Sequencer , typename ReadCallback &gt; </td></tr>
<tr class="memitem:a2af5aa50c92bf95bb01b6eb333b32dcd"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; typename Sequencer::message_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2af5aa50c92bf95bb01b6eb333b32dcd">protocol_simple_load</a> (std::size_t read_limit, ReadCallback &amp;&amp;read)</td></tr>
<tr class="separator:a2af5aa50c92bf95bb01b6eb333b32dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ac304c1774efefc635bd44ba74b593"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, std::size_t N&gt; </td></tr>
<tr class="memitem:a70ac304c1774efefc635bd44ba74b593"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a70ac304c1774efefc635bd44ba74b593">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1protocol__message.html">protocol_message</a>&lt; N &gt; &amp;msg)</td></tr>
<tr class="separator:a70ac304c1774efefc635bd44ba74b593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463debb1eef1b03f9b58be24086f4784"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a463debb1eef1b03f9b58be24086f4784">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a> &amp;m)</td></tr>
<tr class="separator:a463debb1eef1b03f9b58be24086f4784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2face318b969f903389e5ef983b55ceb"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2face318b969f903389e5ef983b55ceb">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__error__record">protocol_error_record</a> &amp;rec)</td></tr>
<tr class="separator:a2face318b969f903389e5ef983b55ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11acb6ac1c9c88f881b5e5742328b34"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae11acb6ac1c9c88f881b5e5742328b34">operator&lt;&lt;</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const <a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594">protocol_endianess_enum</a> &amp;val)</td></tr>
<tr class="separator:ae11acb6ac1c9c88f881b5e5742328b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f533e8e78352f31fb1ff0fbc1c8a85"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, protocol_endianess_enum Endianess, typename... Regs&gt; </td></tr>
<tr class="memitem:a84f533e8e78352f31fb1ff0fbc1c8a85"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a84f533e8e78352f31fb1ff0fbc1c8a85">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1protocol__register__map.html">protocol_register_map</a>&lt; Endianess, Regs... &gt; &amp;m)</td></tr>
<tr class="separator:a84f533e8e78352f31fb1ff0fbc1c8a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37fb61edcdf95a5c2fc63e29d2431946">operator+</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="memdesc:a37fb61edcdf95a5c2fc63e29d2431946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#a37fb61edcdf95a5c2fc63e29d2431946">More...</a><br /></td></tr>
<tr class="separator:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec5f53bd49815db80874c10f4742f92"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a7ec5f53bd49815db80874c10f4742f92"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7ec5f53bd49815db80874c10f4742f92">operator-</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="memdesc:a7ec5f53bd49815db80874c10f4742f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#a7ec5f53bd49815db80874c10f4742f92">More...</a><br /></td></tr>
<tr class="separator:a7ec5f53bd49815db80874c10f4742f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc235c95c20406e05b11a433e3ed7857"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:afc235c95c20406e05b11a433e3ed7857"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afc235c95c20406e05b11a433e3ed7857">operator-</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; val)</td></tr>
<tr class="memdesc:afc235c95c20406e05b11a433e3ed7857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides negation of the quantity.  <a href="namespaceemlabcpp.html#afc235c95c20406e05b11a433e3ed7857">More...</a><br /></td></tr>
<tr class="separator:afc235c95c20406e05b11a433e3ed7857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a18ed069c328b94893a379a85d855f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </td></tr>
<tr class="memitem:a49a18ed069c328b94893a379a85d855f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a49a18ed069c328b94893a379a85d855f">operator&lt;</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const RhValueType rhs)</td></tr>
<tr class="separator:a49a18ed069c328b94893a379a85d855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c42d6c592410c5073ecfb18431a4d04"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </td></tr>
<tr class="memitem:a1c42d6c592410c5073ecfb18431a4d04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c42d6c592410c5073ecfb18431a4d04">operator&lt;</a> (const LhValueType lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="separator:a1c42d6c592410c5073ecfb18431a4d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1b0db510277c2522d504eabc6821e3"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a9a1b0db510277c2522d504eabc6821e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9a1b0db510277c2522d504eabc6821e3">operator*</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto val)</td></tr>
<tr class="memdesc:a9a1b0db510277c2522d504eabc6821e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a9a1b0db510277c2522d504eabc6821e3">More...</a><br /></td></tr>
<tr class="separator:a9a1b0db510277c2522d504eabc6821e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0176bf0d3582d8fa997f2ae98869d099"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a0176bf0d3582d8fa997f2ae98869d099"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0176bf0d3582d8fa997f2ae98869d099">operator/</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto val)</td></tr>
<tr class="memdesc:a0176bf0d3582d8fa997f2ae98869d099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a0176bf0d3582d8fa997f2ae98869d099">More...</a><br /></td></tr>
<tr class="separator:a0176bf0d3582d8fa997f2ae98869d099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad94cfee3e6e80c1e90bc767e6ace9f7e">abs</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with absolute value of internal value.  <a href="namespaceemlabcpp.html#ad94cfee3e6e80c1e90bc767e6ace9f7e">More...</a><br /></td></tr>
<tr class="separator:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a364f72aef7b46ed76b90e1f7a054fc32">cos</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; u)</td></tr>
<tr class="memdesc:a364f72aef7b46ed76b90e1f7a054fc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cosinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#a364f72aef7b46ed76b90e1f7a054fc32">More...</a><br /></td></tr>
<tr class="separator:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d3eb598a75856181b79136ed06dbd8"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:aa3d3eb598a75856181b79136ed06dbd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa3d3eb598a75856181b79136ed06dbd8">sin</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; u)</td></tr>
<tr class="memdesc:aa3d3eb598a75856181b79136ed06dbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#aa3d3eb598a75856181b79136ed06dbd8">More...</a><br /></td></tr>
<tr class="separator:aa3d3eb598a75856181b79136ed06dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bc958527847885bdfc4005b22271e6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a82bc958527847885bdfc4005b22271e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">max</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lh, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rh)</td></tr>
<tr class="memdesc:a82bc958527847885bdfc4005b22271e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with maximum value of one of the quantities.  <a href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">More...</a><br /></td></tr>
<tr class="separator:a82bc958527847885bdfc4005b22271e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">min</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lh, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rh)</td></tr>
<tr class="memdesc:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with minimum value of one of the quantities.  <a href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">More...</a><br /></td></tr>
<tr class="separator:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a244aa2b00962ce96249bb72e5d07b0c1">operator*</a> (const ValueType val, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:a244aa2b00962ce96249bb72e5d07b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a244aa2b00962ce96249bb72e5d07b0c1">More...</a><br /></td></tr>
<tr class="separator:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memTemplItemLeft" align="right" valign="top">constexpr ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1e7c3c010fa2b7cffe9478558c1d9df6">operator/</a> (const ValueType val, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a1e7c3c010fa2b7cffe9478558c1d9df6">More...</a><br /></td></tr>
<tr class="separator:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eca5f3bb3804309470b88131f9417de"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, typename T , typename ValueType &gt; </td></tr>
<tr class="memitem:a8eca5f3bb3804309470b88131f9417de"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8eca5f3bb3804309470b88131f9417de">operator&lt;&lt;</a> (Stream &amp;os, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; T, ValueType &gt; q)</td></tr>
<tr class="separator:a8eca5f3bb3804309470b88131f9417de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2254b75f92599473cee7451ded051a0e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2254b75f92599473cee7451ded051a0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2254b75f92599473cee7451ded051a0e">operator&lt;=&gt;</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:a2254b75f92599473cee7451ded051a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e80e0e361283130d83856b68f4e6d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abe4e80e0e361283130d83856b68f4e6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abe4e80e0e361283130d83856b68f4e6d">operator==</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:abe4e80e0e361283130d83856b68f4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afaabfb4832972f3f9c7589a82ac8ac4f">operator!=</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1d2eb2cc5c084a4173867a48032517"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abf1d2eb2cc5c084a4173867a48032517"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abf1d2eb2cc5c084a4173867a48032517">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;cb)</td></tr>
<tr class="memdesc:abf1d2eb2cc5c084a4173867a48032517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for the view, uses comma to separate the items in the view.  <a href="namespaceemlabcpp.html#abf1d2eb2cc5c084a4173867a48032517">More...</a><br /></td></tr>
<tr class="separator:abf1d2eb2cc5c084a4173867a48032517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640640991a3cfee97b11ab4df8759583"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a640640991a3cfee97b11ab4df8759583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a640640991a3cfee97b11ab4df8759583">operator&lt;=&gt;</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:a640640991a3cfee97b11ab4df8759583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaccb739b9336c5bd977ad988c3d336"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:accaccb739b9336c5bd977ad988c3d336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#accaccb739b9336c5bd977ad988c3d336">operator==</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:accaccb739b9336c5bd977ad988c3d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaa5569071253ac2623f7130fd1ff9d3a">operator!=</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba54ad76836fd2a980ac4d6cf8d648af"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aba54ad76836fd2a980ac4d6cf8d648af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aba54ad76836fd2a980ac4d6cf8d648af">swap</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:aba54ad76836fd2a980ac4d6cf8d648af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dff36c03e0407491a4acf6b85b3f86e"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7dff36c03e0407491a4acf6b85b3f86e"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7dff36c03e0407491a4acf6b85b3f86e">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;vec)</td></tr>
<tr class="memdesc:a7dff36c03e0407491a4acf6b85b3f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for the view, uses comma to separate the items in the view.  <a href="namespaceemlabcpp.html#a7dff36c03e0407491a4acf6b85b3f86e">More...</a><br /></td></tr>
<tr class="separator:a7dff36c03e0407491a4acf6b85b3f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155a6828d776fbc298d37aabee6bc0d7"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, auto ID&gt; </td></tr>
<tr class="memitem:a155a6828d776fbc298d37aabee6bc0d7"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a155a6828d776fbc298d37aabee6bc0d7">operator&lt;&lt;</a> (Stream &amp;os, <a class="el" href="structemlabcpp_1_1tag.html">tag</a>&lt; ID &gt;)</td></tr>
<tr class="separator:a155a6828d776fbc298d37aabee6bc0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d4ea091d64444e17a8e74d672c3c6c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46d4ea091d64444e17a8e74d672c3c6c"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a46d4ea091d64444e17a8e74d672c3c6c">pretty_type_name</a> ()</td></tr>
<tr class="separator:a46d4ea091d64444e17a8e74d672c3c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acd74c7df9ccef5ce376d2c3fe2ef8908">requires</a> (sizeof(uint8_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3dcd56ce6fdffb4ebcf8a4c079335d8e">requires</a> (sizeof(uint16_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac39ed97224e397106e08c6e04012e62a">requires</a> (sizeof(uint32_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:ac39ed97224e397106e08c6e04012e62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2acb59e904f4530e0e8d42e98f67bcaa">requires</a> (sizeof(uint64_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f323f095107eec70dbb1db1387711"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:a541f323f095107eec70dbb1db1387711"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a541f323f095107eec70dbb1db1387711">operator==</a> (const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;rh)</td></tr>
<tr class="separator:a541f323f095107eec70dbb1db1387711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8d7465ddd19bb5f2eaa845a6cc78b8e0">operator!=</a> (const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;rh)</td></tr>
<tr class="separator:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view</a> (Container &amp;cont) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td></tr>
<tr class="memdesc:a4b726ddab4f550f3e186f177243cb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container deduction guide uses iterator_of_t.  <a href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">More...</a><br /></td></tr>
<tr class="separator:a4b726ddab4f550f3e186f177243cb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172761451ef499ea1a316bf3b683fd16"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a172761451ef499ea1a316bf3b683fd16"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a172761451ef499ea1a316bf3b683fd16">view_n</a> (Iter begin, std::size_t n)</td></tr>
<tr class="memdesc:a172761451ef499ea1a316bf3b683fd16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range!  <a href="namespaceemlabcpp.html#a172761451ef499ea1a316bf3b683fd16">More...</a><br /></td></tr>
<tr class="separator:a172761451ef499ea1a316bf3b683fd16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793151b3dbb2a3d533314e5a55cf6f54"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:a793151b3dbb2a3d533314e5a55cf6f54"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a793151b3dbb2a3d533314e5a55cf6f54">trim_view</a> (Container &amp;cont, float r)</td></tr>
<tr class="memdesc:a793151b3dbb2a3d533314e5a55cf6f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items.  <a href="namespaceemlabcpp.html#a793151b3dbb2a3d533314e5a55cf6f54">More...</a><br /></td></tr>
<tr class="separator:a793151b3dbb2a3d533314e5a55cf6f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3921b804e7ed8b1041ec50f786404c28"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3921b804e7ed8b1041ec50f786404c28">reversed</a> (<a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype(container.rbegin()) &gt;</td></tr>
<tr class="memdesc:a3921b804e7ed8b1041ec50f786404c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view to the Container in reverse order.  <a href="namespaceemlabcpp.html#a3921b804e7ed8b1041ec50f786404c28">More...</a><br /></td></tr>
<tr class="separator:a3921b804e7ed8b1041ec50f786404c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ef973500b9ebc01d0f76f50c43aa38"><td class="memTemplParams" colspan="2">template&lt;ostreamlike Stream, typename Iterator &gt; </td></tr>
<tr class="memitem:a09ef973500b9ebc01d0f76f50c43aa38"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a09ef973500b9ebc01d0f76f50c43aa38">operator&lt;&lt;</a> (Stream &amp;os, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; &amp;output)</td></tr>
<tr class="memdesc:a09ef973500b9ebc01d0f76f50c43aa38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output operator for the view, uses comma to separate the items in the view.  <a href="namespaceemlabcpp.html#a09ef973500b9ebc01d0f76f50c43aa38">More...</a><br /></td></tr>
<tr class="separator:a09ef973500b9ebc01d0f76f50c43aa38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="separator:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="separator:a75cf44a6df8173ea7a46979f57546332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4a90457babf1c49444a526a98007a751">operator+</a> (<a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; lh, std::ptrdiff_t m)</td></tr>
<tr class="separator:a4a90457babf1c49444a526a98007a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a163dd8154f05ef8a818183d0d44cbcdc">operator!=</a> (const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;rh)</td></tr>
<tr class="separator:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplParams" colspan="2">template&lt;range_container... Ts&gt; </td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip</a> (Ts &amp;&amp;... cont)</td></tr>
<tr class="memdesc:a41ab261a0f296f3c9862e59e12339885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of zip iterators for specified containers.  <a href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">More...</a><br /></td></tr>
<tr class="separator:a41ab261a0f296f3c9862e59e12339885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afe935e56d6376df9f87d0d015a3baecc">enumerate</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:afe935e56d6376df9f87d0d015a3baecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplParams" colspan="2">template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl</a> (TuplesTuple &amp;&amp;tpls, std::index_sequence&lt; ItemIndexes... &gt;, std::index_sequence&lt; TupleIndexes... &gt;)</td></tr>
<tr class="separator:aa8b8f5742901528282a9da6b8317e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c07efb3691ae81d8dbffdeed5ee54e7"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename... Tuples, std::enable_if_t&lt; is_std_tuple_v&lt; Tuple &gt; &gt; *  = nullptr, std::enable_if_t&lt; std::conjunction_v&lt; is_std_tuple&lt; std::decay_t&lt; Tuples &gt; &gt;... &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c07efb3691ae81d8dbffdeed5ee54e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c07efb3691ae81d8dbffdeed5ee54e7">zip</a> (Tuple &amp;&amp;frst, Tuples &amp;&amp;... tpls)</td></tr>
<tr class="memdesc:a1c07efb3691ae81d8dbffdeed5ee54e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips a set of tuples of same size into a new tuple.  <a href="namespaceemlabcpp.html#a1c07efb3691ae81d8dbffdeed5ee54e7">More...</a><br /></td></tr>
<tr class="separator:a1c07efb3691ae81d8dbffdeed5ee54e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a20db02f115d34db629106a39c5194e18"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a> = 1.19e-07<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a></td></tr>
<tr class="separator:a20db02f115d34db629106a39c5194e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2351d7b7de1988dbb2979cadfd729d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a></td></tr>
<tr class="separator:a2351d7b7de1988dbb2979cadfd729d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3571963bbe0982f9987b78b111c626"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a> {}</td></tr>
<tr class="separator:a9f3571963bbe0982f9987b78b111c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">bounded_constant</a> = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, N, N &gt;{}</td></tr>
<tr class="memdesc:a7b5a68de4881301e46697c48654d8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type alias for bounded index constants.  <a href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">More...</a><br /></td></tr>
<tr class="separator:a7b5a68de4881301e46697c48654d8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">bounded_derived</a></td></tr>
<tr class="memdesc:add79493bcf07bd4c54afffe3a0f3ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that matchestype deriving from bounded.  <a href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">More...</a><br /></td></tr>
<tr class="separator:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a></td></tr>
<tr class="separator:a94924279b38cf1803ee0f01cb4889b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a></td></tr>
<tr class="separator:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5494e6f6f24a2fd7e7ccfaecb31944b3">arithmetic_like</a> = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td></tr>
<tr class="separator:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td></tr>
<tr class="separator:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a></td></tr>
<tr class="separator:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a></td></tr>
<tr class="memdesc:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible  <a href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">More...</a><br /></td></tr>
<tr class="separator:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a> = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt;</td></tr>
<tr class="separator:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a></td></tr>
<tr class="separator:ad5b78b4d7a2e426170153951069c76cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a></td></tr>
<tr class="separator:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , typename Container &gt; </td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abeb742c691973ef2d34b0ace4d8eef15">container_invocable</a></td></tr>
<tr class="separator:abeb742c691973ef2d34b0ace4d8eef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , typename ReturnValue , typename... Args&gt; </td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5219e24bd076b3c65f56c69b9025dd69">invocable_returning</a></td></tr>
<tr class="separator:a5219e24bd076b3c65f56c69b9025dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a></td></tr>
<tr class="separator:a27325f314502897567307b29b2b03776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459242c17dfd40402115fe8a63d21622"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LH , typename RH &gt; </td></tr>
<tr class="memitem:a459242c17dfd40402115fe8a63d21622"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a459242c17dfd40402115fe8a63d21622">either_uniquely_right_item</a></td></tr>
<tr class="separator:a459242c17dfd40402115fe8a63d21622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f75ff24381eb238fa2d96e7b7788ce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21f75ff24381eb238fa2d96e7b7788ce"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a21f75ff24381eb238fa2d96e7b7788ce">testing_test</a> = std::derived_from&lt; T, <a class="el" href="classemlabcpp_1_1testing__interface.html">testing_interface</a> &gt;</td></tr>
<tr class="separator:a21f75ff24381eb238fa2d96e7b7788ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eff427e2ab20965ca0f25f45bacf49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7eff427e2ab20965ca0f25f45bacf49"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae7eff427e2ab20965ca0f25f45bacf49">testing_callable</a></td></tr>
<tr class="memdesc:ae7eff427e2ab20965ca0f25f45bacf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">&amp;&amp; std::movable&lt; T &gt;;  <a href="namespaceemlabcpp.html#ae7eff427e2ab20965ca0f25f45bacf49">More...</a><br /></td></tr>
<tr class="separator:ae7eff427e2ab20965ca0f25f45bacf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">pi</a> = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a> }</td></tr>
<tr class="memdesc:a7cac9e89744ae1ec8ad817df33d291f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants of units that are relevant for us.  <a href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">More...</a><br /></td></tr>
<tr class="separator:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab7e77781bf7b562c6fdf625db0b576"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abab7e77781bf7b562c6fdf625db0b576"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abab7e77781bf7b562c6fdf625db0b576">protocol_base_type</a> = std::is_integral_v&lt; T &gt; || std::is_enum_v&lt; T &gt;</td></tr>
<tr class="memdesc:abab7e77781bf7b562c6fdf625db0b576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that matches types considered base - serialized directly by using byte shifting.  <a href="namespaceemlabcpp.html#abab7e77781bf7b562c6fdf625db0b576">More...</a><br /></td></tr>
<tr class="separator:abab7e77781bf7b562c6fdf625db0b576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602f297ea94780303fcf0369627f5e72"><td class="memTemplParams" colspan="2">template&lt;typename D &gt; </td></tr>
<tr class="memitem:a602f297ea94780303fcf0369627f5e72"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a602f297ea94780303fcf0369627f5e72">protocol_declarable</a></td></tr>
<tr class="memdesc:a602f297ea94780303fcf0369627f5e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concepts limits types to types that can be declared, that is the overload of '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl" title="Each definition of item provided to protocol library should have specialization of &#39;protocol_decl&#39; st...">protocol_decl</a>' is fully defined: protocol_decl::value_type contains definition of value produced by the declaration, protocol_decl::max_size contains estimated maximal size in bytes taken by the serialized value in the message.  <a href="namespaceemlabcpp.html#a602f297ea94780303fcf0369627f5e72">More...</a><br /></td></tr>
<tr class="separator:a602f297ea94780303fcf0369627f5e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9647fb1b94d3992c20f0c5017049a67a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9647fb1b94d3992c20f0c5017049a67a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9647fb1b94d3992c20f0c5017049a67a">protocol_fixedly_sized</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">protocol_decl</a>&lt; T &gt;::min_size == <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">protocol_decl</a>&lt; T &gt;::max_size</td></tr>
<tr class="separator:a9647fb1b94d3992c20f0c5017049a67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf01e75bfbd6924b7d262036e65a0881"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf01e75bfbd6924b7d262036e65a0881"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acf01e75bfbd6924b7d262036e65a0881">protocol_def_check</a></td></tr>
<tr class="memdesc:acf01e75bfbd6924b7d262036e65a0881"><td class="mdescLeft">&#160;</td><td class="mdescRight">protocol_def_check&lt;T&gt; concept verifies that 'T' is valid overload of <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__def" title="protocol_def&lt;T,E&gt; structure defines how type T should be serialized and deserialized.">protocol_def</a>.  <a href="namespaceemlabcpp.html#acf01e75bfbd6924b7d262036e65a0881">More...</a><br /></td></tr>
<tr class="separator:acf01e75bfbd6924b7d262036e65a0881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0600b5cf194accae7c5238c9972cad1"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab0600b5cf194accae7c5238c9972cad1">SIZE_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPSIZE &quot; )</td></tr>
<tr class="separator:ab0600b5cf194accae7c5238c9972cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50429a6831c33bfc19692833c3a6b0c1"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a50429a6831c33bfc19692833c3a6b0c1">LOWSIZE_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPLOWSIZE &quot; )</td></tr>
<tr class="memdesc:a50429a6831c33bfc19692833c3a6b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">not enough bytes left in the message for the item  <a href="namespaceemlabcpp.html#a50429a6831c33bfc19692833c3a6b0c1">More...</a><br /></td></tr>
<tr class="separator:a50429a6831c33bfc19692833c3a6b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3ea4ba31c3aac1ca5db845fbe67711"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0f3ea4ba31c3aac1ca5db845fbe67711">BIGSIZE_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBIGSIZE &quot; )</td></tr>
<tr class="memdesc:a0f3ea4ba31c3aac1ca5db845fbe67711"><td class="mdescLeft">&#160;</td><td class="mdescRight">too much bytes left in the message for the item  <a href="namespaceemlabcpp.html#a0f3ea4ba31c3aac1ca5db845fbe67711">More...</a><br /></td></tr>
<tr class="separator:a0f3ea4ba31c3aac1ca5db845fbe67711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e05bb2d6769aee5b01021e927a54b65"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0e05bb2d6769aee5b01021e927a54b65">BOUNDS_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBOUNDS &quot; )</td></tr>
<tr class="memdesc:a0e05bb2d6769aee5b01021e927a54b65"><td class="mdescLeft">&#160;</td><td class="mdescRight">value in the message is outside of the range of bounded type  <a href="namespaceemlabcpp.html#a0e05bb2d6769aee5b01021e927a54b65">More...</a><br /></td></tr>
<tr class="separator:a0e05bb2d6769aee5b01021e927a54b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d60b3b8af2bc89f3dc4f985a67aff"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2a0d60b3b8af2bc89f3dc4f985a67aff">UNDEFVAR_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPUNDEFVAR&quot; )</td></tr>
<tr class="memdesc:a2a0d60b3b8af2bc89f3dc4f985a67aff"><td class="mdescLeft">&#160;</td><td class="mdescRight">variant id is outside of the range for defined variant  <a href="namespaceemlabcpp.html#a2a0d60b3b8af2bc89f3dc4f985a67aff">More...</a><br /></td></tr>
<tr class="separator:a2a0d60b3b8af2bc89f3dc4f985a67aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145bebab87eba36baf2eeac66f12ded2"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a145bebab87eba36baf2eeac66f12ded2">BADVAL_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBADVAL &quot; )</td></tr>
<tr class="memdesc:a145bebab87eba36baf2eeac66f12ded2"><td class="mdescLeft">&#160;</td><td class="mdescRight">parsed value is not correct, such as constant  <a href="namespaceemlabcpp.html#a145bebab87eba36baf2eeac66f12ded2">More...</a><br /></td></tr>
<tr class="separator:a145bebab87eba36baf2eeac66f12ded2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0086d26c146022436c25e55e690c79"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aca0086d26c146022436c25e55e690c79">GROUP_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPGRPMATCH&quot; )</td></tr>
<tr class="memdesc:aca0086d26c146022436c25e55e690c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">no item of group matched the content of message  <a href="namespaceemlabcpp.html#aca0086d26c146022436c25e55e690c79">More...</a><br /></td></tr>
<tr class="separator:aca0086d26c146022436c25e55e690c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1464a98bcd956131d445b317f4e8814f"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1464a98bcd956131d445b317f4e8814f">CHECKSUM_ERR</a> = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPCHECKSUM&quot; )</td></tr>
<tr class="memdesc:a1464a98bcd956131d445b317f4e8814f"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrong checksum in the protocol  <a href="namespaceemlabcpp.html#a1464a98bcd956131d445b317f4e8814f">More...</a><br /></td></tr>
<tr class="separator:a1464a98bcd956131d445b317f4e8814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59d4efcbda0164962a9720e2c1e8f6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abc59d4efcbda0164962a9720e2c1e8f6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abc59d4efcbda0164962a9720e2c1e8f6">protocol_message_derived</a></td></tr>
<tr class="memdesc:abc59d4efcbda0164962a9720e2c1e8f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">concept matches any type that is <a class="el" href="classemlabcpp_1_1protocol__message.html" title="Protocol library has custom type that represents message, however this is just simple overaly over st...">protocol_message</a> or derives from it.  <a href="namespaceemlabcpp.html#abc59d4efcbda0164962a9720e2c1e8f6">More...</a><br /></td></tr>
<tr class="separator:abc59d4efcbda0164962a9720e2c1e8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee9999dcf24d3acafa60872b768205e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeee9999dcf24d3acafa60872b768205e"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeee9999dcf24d3acafa60872b768205e">protocol_packet_def</a></td></tr>
<tr class="separator:aeee9999dcf24d3acafa60872b768205e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5384f85878a19eecba149c46ea300dc"><td class="memTemplParams" colspan="2">template&lt;typename UnaryFunction , typename Registers &gt; </td></tr>
<tr class="memitem:ab5384f85878a19eecba149c46ea300dc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab5384f85878a19eecba149c46ea300dc">protocol_register_map_void_returning</a></td></tr>
<tr class="separator:ab5384f85878a19eecba149c46ea300dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a869ab03f1bd49e1adc49de513ad86ba4">quantity_derived</a></td></tr>
<tr class="separator:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aff43a196db9cecc357e6f4452638b32f">is_view_v</a> = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aff43a196db9cecc357e6f4452638b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae5e4923a149af384640fe5d3759dcc9a">are_same_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td></tr>
<tr class="separator:ae5e4923a149af384640fe5d3759dcc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Us&gt; </td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8574533cb7c969125a6fde8f5063eff2">tuple_has_type_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td></tr>
<tr class="separator:a8574533cb7c969125a6fde8f5063eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a633f5fea14133c23b25a75cd57a8805d">is_std_tuple_v</a> = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a633f5fea14133c23b25a75cd57a8805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1d463be90e36b5d5be447e407fca17bf">is_std_array_v</a> = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a1d463be90e36b5d5be447e407fca17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa5277a3e558d32758ca0e4770ed5e1eb">is_std_vector_v</a> = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">static_size_v</a> = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td></tr>
<tr class="memdesc:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marked deprecated on 19.4.2021.  <a href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">More...</a><br /></td></tr>
<tr class="separator:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adaca063c7275419f3999bd854c88de3d">has_static_size_v</a> = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td></tr>
<tr class="separator:adaca063c7275419f3999bd854c88de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35890f89255716603146448591d91823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a></td></tr>
<tr class="separator:a35890f89255716603146448591d91823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structemlabcpp_1_1are__same" id="structemlabcpp_1_1are__same"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1are__same">&#9670;&nbsp;</a></span>emlabcpp::are_same</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::are_same</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename...&gt;<br />
struct emlabcpp::are_same&lt;... &gt;</h3>

<hr  />
<p> are_same&lt;Ts..&gt;::value is true if all Ts... are equal types. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1empty__assembly__tag" id="structemlabcpp_1_1empty__assembly__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1empty__assembly__tag">&#9670;&nbsp;</a></span>emlabcpp::empty_assembly_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::empty_assembly_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Marks empty assembly. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1iterator__of" id="structemlabcpp_1_1iterator__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1iterator__of">&#9670;&nbsp;</a></span>emlabcpp::iterator_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::iterator_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container&gt;<br />
struct emlabcpp::iterator_of&lt; Container &gt;</h3>

<hr  />
<p> <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a> is structure where <a class="el" href="namespaceemlabcpp.html#abb6468ad7836780268a9d6ed31b017bc">iterator_of&lt;Container&gt;::type</a> returns type of iterator that is returned by cont.begin(); </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abb6468ad7836780268a9d6ed31b017bc"></a>typedef decltype(begin(declval&lt; add_lvalue_reference_t&lt; Container &gt; &gt;()))</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1mapped" id="structemlabcpp_1_1mapped"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1mapped">&#9670;&nbsp;</a></span>emlabcpp::mapped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::mapped</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container, typename UnaryFunction&gt;<br />
struct emlabcpp::mapped&lt; Container, UnaryFunction &gt;</h3>

<hr  />
<p> mapped&lt;T,F&gt;::type is type returned by instance of F::operator() when applied on items from instance of T. It can differentiate between tuples or containers </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4" id="structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__command__group_3_01Endianess_01_4">&#9670;&nbsp;</a></span>emlabcpp::protocol_command_group&lt; Endianess &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_command_group&lt; Endianess &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;protocol_endianess_enum Endianess&gt;<br />
struct emlabcpp::protocol_command_group&lt; Endianess &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a1116f970afbac58563966b407530deaf"></a></td>
<td class="fieldname">
with_commands</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1protocol__decl" id="structemlabcpp_1_1protocol__decl"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__decl">&#9670;&nbsp;</a></span>emlabcpp::protocol_decl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_decl</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename D&gt;<br />
struct emlabcpp::protocol_decl&lt; D &gt;</h3>

<p>Each definition of item provided to protocol library should have specialization of '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl" title="Each definition of item provided to protocol library should have specialization of &#39;protocol_decl&#39; st...">protocol_decl</a>' structure. </p>
<p>This contains basic information of how it should be serialized. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1protocol__def" id="structemlabcpp_1_1protocol__def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__def">&#9670;&nbsp;</a></span>emlabcpp::protocol_def</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_def</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, protocol_endianess_enum&gt;<br />
struct emlabcpp::protocol_def&lt; typename, protocol_endianess_enum &gt;</h3>

<p>protocol_def&lt;T,E&gt; structure defines how type T should be serialized and deserialized. </p>
<p>Each type or kind of types should overlead this structure and use same attributes as protocol_decl&lt;T,E&gt;. E is edianess of the serialization used. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1protocol__error__record" id="structemlabcpp_1_1protocol__error__record"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__error__record">&#9670;&nbsp;</a></span>emlabcpp::protocol_error_record</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_error_record</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::protocol_error_record:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1protocol__error__record__coll__graph.svg" width="199" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a05a3329bfcabf114135f90476bfbcc09"></a><a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a></td>
<td class="fieldname">
mark</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a8dcbb739bb8a0179b85adc8f351725bb"></a>size_t</td>
<td class="fieldname">
offset</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1protocol__group" id="structemlabcpp_1_1protocol__group"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__group">&#9670;&nbsp;</a></span>emlabcpp::protocol_group</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_group</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename... Ds&gt;<br />
struct emlabcpp::protocol_group&lt; Ds &gt;</h3>

<p>Serializes values from definitions Ds to std::variant. </p>
<p>The byte message does not contain identificator of variant used, rather the first definition that manages to deserialize the message is used. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a139d42724f35fa5519e859cad8d93c39"></a></td>
<td class="fieldname">
options_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1protocol__sized__buffer" id="structemlabcpp_1_1protocol__sized__buffer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1protocol__sized__buffer">&#9670;&nbsp;</a></span>emlabcpp::protocol_sized_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::protocol_sized_buffer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename CounterDef, typename D&gt;<br />
struct emlabcpp::protocol_sized_buffer&lt; CounterDef, D &gt;</h3>

<p>Creates a segment starting with counter defined by CounterDef, this counter limits how many bytes are passed to deserialization process, bytes after the limit ale not considered by this segment. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ae9c48fbdad00cd511b7ffdbf96c444e8"></a>typedef CounterDef</td>
<td class="fieldname">
counter_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a30b9d448ee094e2a9c6e5b40216e2754"></a>typedef D</td>
<td class="fieldname">
value_type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1select__utype" id="structemlabcpp_1_1select__utype"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1select__utype">&#9670;&nbsp;</a></span>emlabcpp::select_utype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::select_utype</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t&gt;<br />
struct emlabcpp::select_utype&lt; size_t &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1testing__controller__message__error" id="structemlabcpp_1_1testing__controller__message__error"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1testing__controller__message__error">&#9670;&nbsp;</a></span>emlabcpp::testing_controller_message_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::testing_controller_message_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a95580a4893efd63e4aa800d599eb2ad0"></a><a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4">testing_messages_enum</a></td>
<td class="fieldname">
msg_id</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1testing__controller__protocol__error" id="structemlabcpp_1_1testing__controller__protocol__error"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1testing__controller__protocol__error">&#9670;&nbsp;</a></span>emlabcpp::testing_controller_protocol_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::testing_controller_protocol_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::testing_controller_protocol_error:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1testing__controller__protocol__error__coll__graph.svg" width="219" height="246"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a555ffdabf7ef4cd54e8993dfa47f0164"></a><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__error__record">protocol_error_record</a></td>
<td class="fieldname">
rec</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1testing__internal__reactor__error" id="structemlabcpp_1_1testing__internal__reactor__error"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1testing__internal__reactor__error">&#9670;&nbsp;</a></span>emlabcpp::testing_internal_reactor_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::testing_internal_reactor_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa071beaabe5ee1c0af87ce62efc9f87f"></a><a class="el" href="namespaceemlabcpp.html#aec6e2a4fdbfa5c03cfededbdba72d4aa">testing_reactor_error_variant</a></td>
<td class="fieldname">
val</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1testing__reactor__protocol__error" id="structemlabcpp_1_1testing__reactor__protocol__error"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1testing__reactor__protocol__error">&#9670;&nbsp;</a></span>emlabcpp::testing_reactor_protocol_error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::testing_reactor_protocol_error</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::testing_reactor_protocol_error:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1testing__reactor__protocol__error__coll__graph.svg" width="203" height="246"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa508af544a02cf8d215173408efd76a5"></a><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__error__record">protocol_error_record</a></td>
<td class="fieldname">
rec</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1tuple__has__type" id="structemlabcpp_1_1tuple__has__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1tuple__has__type">&#9670;&nbsp;</a></span>emlabcpp::tuple_has_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::tuple_has_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Tuple&gt;<br />
struct emlabcpp::tuple_has_type&lt; T, Tuple &gt;</h3>

<hr  />
<p> tuple_has_type&lt;T, Tuple&gt;::value is true if Tuple s std::tuple and contains type T </p>
</div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9f7b213031fa424abf6cc3d1d04ac1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7b213031fa424abf6cc3d1d04ac1ca">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">emlabcpp::acceleration</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a034dcea22b6c4c252c6127ffd7078a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034dcea22b6c4c252c6127ffd7078a7d">&#9670;&nbsp;</a></span>amount_of_substance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a034dcea22b6c4c252c6127ffd7078a7d">emlabcpp::amount_of_substance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa050c988b29285083320111dc7b90ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa050c988b29285083320111dc7b90ca">&#9670;&nbsp;</a></span>angle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">emlabcpp::angle</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0893503dba0b6cfd0ebd72ceb358f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0893503dba0b6cfd0ebd72ceb358f20">&#9670;&nbsp;</a></span>angular_velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af0893503dba0b6cfd0ebd72ceb358f20">emlabcpp::angular_velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eca5b22a706c436b22c929c45b773ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca5b22a706c436b22c929c45b773ef">&#9670;&nbsp;</a></span>area</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a4eca5b22a706c436b22c929c45b773ef">emlabcpp::area</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afde778df7140459ee3df4cf32bf7566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde778df7140459ee3df4cf32bf7566e">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afde778df7140459ee3df4cf32bf7566e">emlabcpp::byte</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2eceaa8b0d9ceb67162be01c8a803f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2eceaa8b0d9ceb67162be01c8a803f7">&#9670;&nbsp;</a></span>current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae2eceaa8b0d9ceb67162be01c8a803f7">emlabcpp::current</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ac05592b4c728910966af0c89b13a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ac05592b4c728910966af0c89b13a8">&#9670;&nbsp;</a></span>distance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">emlabcpp::distance</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf27b9093d0831dd17c88bcce4f9330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf27b9093d0831dd17c88bcce4f9330">&#9670;&nbsp;</a></span>force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aabf27b9093d0831dd17c88bcce4f9330">emlabcpp::force</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 1, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d67880c6a526098821b950d000c2d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d67880c6a526098821b950d000c2d79">&#9670;&nbsp;</a></span>frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a0d67880c6a526098821b950d000c2d79">emlabcpp::frequency</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98ab53b012e339a9621604b203df856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ab53b012e339a9621604b203df856e">&#9670;&nbsp;</a></span>iterator_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">emlabcpp::iterator_of_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a458a21111b267fd6b9727f821974f859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458a21111b267fd6b9727f821974f859">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">emlabcpp::length</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5e1be68f8469a0ef8388b17b94406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5e1be68f8469a0ef8388b17b94406e">&#9670;&nbsp;</a></span>luminous_intensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5c5e1be68f8469a0ef8388b17b94406e">emlabcpp::luminous_intensity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2dffbbe090c31e17065033d3662e823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dffbbe090c31e17065033d3662e823e">&#9670;&nbsp;</a></span>mapped_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a2dffbbe090c31e17065033d3662e823e">emlabcpp::mapped_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620d7b1d1801843cd1a7356bcc341e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620d7b1d1801843cd1a7356bcc341e3e">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a620d7b1d1801843cd1a7356bcc341e3e">emlabcpp::mass</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43daa0cfcf1b4444fef3c134b538c492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43daa0cfcf1b4444fef3c134b538c492">&#9670;&nbsp;</a></span>pool_deque</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a43daa0cfcf1b4444fef3c134b538c492">emlabcpp::pool_deque</a> = typedef std::deque&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3002b266e75831a1f53acc6309e9a772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3002b266e75831a1f53acc6309e9a772">&#9670;&nbsp;</a></span>pool_list</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a3002b266e75831a1f53acc6309e9a772">emlabcpp::pool_list</a> = typedef std::list&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a26f08c5adb26bcc69ec7fc1bf42910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a26f08c5adb26bcc69ec7fc1bf42910">&#9670;&nbsp;</a></span>pool_map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a3a26f08c5adb26bcc69ec7fc1bf42910">emlabcpp::pool_map</a> = typedef std::map&lt; Key, T, std::less&lt; Key &gt;, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; std::pair&lt; const Key, T &gt; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af23c0681903c11c3eebbf8043eaf2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af23c0681903c11c3eebbf8043eaf2c">&#9670;&nbsp;</a></span>pool_set</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a3af23c0681903c11c3eebbf8043eaf2c">emlabcpp::pool_set</a> = typedef std::set&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea3360c0f2ac93edf6576ef57da1749a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3360c0f2ac93edf6576ef57da1749a">&#9670;&nbsp;</a></span>pool_unique_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aea3360c0f2ac93edf6576ef57da1749a">emlabcpp::pool_unique_ptr</a> = typedef std::unique_ptr&lt; T, <a class="el" href="structemlabcpp_1_1pool__deleter.html">pool_deleter</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53400461db610368cbe228ab40b5c63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53400461db610368cbe228ab40b5c63d">&#9670;&nbsp;</a></span>pool_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a53400461db610368cbe228ab40b5c63d">emlabcpp::pool_vector</a> = typedef std::vector&lt; T, <a class="el" href="classemlabcpp_1_1pool__allocator.html">pool_allocator</a>&lt; T &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf48f5a991078e6acfe3db1e7762675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf48f5a991078e6acfe3db1e7762675">&#9670;&nbsp;</a></span>power</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abbf48f5a991078e6acfe3db1e7762675">emlabcpp::power</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a632193a7b6636e1de8cb134a2e17acb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632193a7b6636e1de8cb134a2e17acb7">&#9670;&nbsp;</a></span>protocol_packet_base</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Def , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a632193a7b6636e1de8cb134a2e17acb7">emlabcpp::protocol_packet_base</a> = typedef <a class="el" href="structemlabcpp_1_1protocol__tuple.html">protocol_tuple</a>&lt; Def::endianess, std::decay_t&lt; decltype( Def::prefix ) &gt;, typename Def::size_type, Payload, typename Def::checksum_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af96516bd702e891771257f4dc279a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96516bd702e891771257f4dc279a2f2">&#9670;&nbsp;</a></span>radius</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af96516bd702e891771257f4dc279a2f2">emlabcpp::radius</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48e239b7c22e51004fc26dd043d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48e239b7c22e51004fc26dd043d32b9">&#9670;&nbsp;</a></span>resistance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae48e239b7c22e51004fc26dd043d32b9">emlabcpp::resistance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -2, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac223240cfaa32fcb48f0daa06c78a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac223240cfaa32fcb48f0daa06c78a9e2">&#9670;&nbsp;</a></span>select_utype_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">emlabcpp::select_utype_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a845bc83f874f1d97f649fbe0137c913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845bc83f874f1d97f649fbe0137c913c">&#9670;&nbsp;</a></span>temp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a845bc83f874f1d97f649fbe0137c913c">emlabcpp::temp</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00d9348aa7043abf68885939947f3876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d9348aa7043abf68885939947f3876">&#9670;&nbsp;</a></span>testing_arg_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a00d9348aa7043abf68885939947f3876">emlabcpp::testing_arg_variant</a> = typedef std::variant&lt; uint64_t, int64_t, bool, <a class="el" href="namespaceemlabcpp.html#a9b065acd5c5329faf70e62bda58d26eb">testing_string_buffer</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a770bca1b8326991fba1ab2031fdae8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770bca1b8326991fba1ab2031fdae8c3">&#9670;&nbsp;</a></span>testing_controller_reactor_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a770bca1b8326991fba1ab2031fdae8c3">emlabcpp::testing_controller_reactor_msg</a> = typedef typename <a class="el" href="structemlabcpp_1_1protocol__tuple.html#a02a32b8fb4d05f889e957df042b9a49c">testing_controller_reactor_packet::message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a648640c7a757908fba8c9716f4493e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a648640c7a757908fba8c9716f4493e19">&#9670;&nbsp;</a></span>testing_controller_reactor_packet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a648640c7a757908fba8c9716f4493e19">emlabcpp::testing_controller_reactor_packet</a> = typedef <a class="el" href="structemlabcpp_1_1protocol__packet.html">protocol_packet</a>&lt; <a class="el" href="structemlabcpp_1_1testing__packet__def.html">testing_packet_def</a>, <a class="el" href="structemlabcpp_1_1testing__controller__reactor__group.html">testing_controller_reactor_group</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e6a34bbef6dd4f379a490c3311a6e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6a34bbef6dd4f379a490c3311a6e2e">&#9670;&nbsp;</a></span>testing_controller_reactor_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a0e6a34bbef6dd4f379a490c3311a6e2e">emlabcpp::testing_controller_reactor_variant</a> = typedef typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_controller_reactor_group::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23f9646ab3c944247009330cf42fd46a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f9646ab3c944247009330cf42fd46a">&#9670;&nbsp;</a></span>testing_error_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a23f9646ab3c944247009330cf42fd46a">emlabcpp::testing_error_variant</a> = typedef std::variant&lt; <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__reactor__protocol__error">testing_reactor_protocol_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__protocol__error">testing_controller_protocol_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__internal__reactor__error">testing_internal_reactor_error</a>, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__message__error">testing_controller_message_error</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab961228f0e95ce3f73f42aadfcaa54fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab961228f0e95ce3f73f42aadfcaa54fd">&#9670;&nbsp;</a></span>testing_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ab961228f0e95ce3f73f42aadfcaa54fd">emlabcpp::testing_key</a> = typedef std::variant&lt; uint32_t, <a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">testing_key_buffer</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfb5a005e75f7e4f58008d4ed698e9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb5a005e75f7e4f58008d4ed698e9d1">&#9670;&nbsp;</a></span>testing_key_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">emlabcpp::testing_key_buffer</a> = typedef <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 16 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a289862982d90d50fae8def7c9491fac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289862982d90d50fae8def7c9491fac3">&#9670;&nbsp;</a></span>testing_name_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a289862982d90d50fae8def7c9491fac3">emlabcpp::testing_name_buffer</a> = typedef <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 32 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bb54919fd16f1fec2a66196473d126f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb54919fd16f1fec2a66196473d126f">&#9670;&nbsp;</a></span>testing_reactor_controller_msg</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1bb54919fd16f1fec2a66196473d126f">emlabcpp::testing_reactor_controller_msg</a> = typedef typename <a class="el" href="structemlabcpp_1_1protocol__tuple.html#a02a32b8fb4d05f889e957df042b9a49c">testing_reactor_controller_packet::message_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad5bb7446964b58645c8c8f480f06ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5bb7446964b58645c8c8f480f06ec2">&#9670;&nbsp;</a></span>testing_reactor_controller_packet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aad5bb7446964b58645c8c8f480f06ec2">emlabcpp::testing_reactor_controller_packet</a> = typedef <a class="el" href="structemlabcpp_1_1protocol__packet.html">protocol_packet</a>&lt; <a class="el" href="structemlabcpp_1_1testing__packet__def.html">testing_packet_def</a>, <a class="el" href="structemlabcpp_1_1testing__reactor__controller__group.html">testing_reactor_controller_group</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a09926c7b0fd256972b4ce24e0ffe27fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09926c7b0fd256972b4ce24e0ffe27fb">&#9670;&nbsp;</a></span>testing_reactor_controller_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a09926c7b0fd256972b4ce24e0ffe27fb">emlabcpp::testing_reactor_controller_variant</a> = typedef typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_reactor_controller_group::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec6e2a4fdbfa5c03cfededbdba72d4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec6e2a4fdbfa5c03cfededbdba72d4aa">&#9670;&nbsp;</a></span>testing_reactor_error_variant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aec6e2a4fdbfa5c03cfededbdba72d4aa">emlabcpp::testing_reactor_error_variant</a> = typedef typename <a class="el" href="structemlabcpp_1_1protocol__command__group.html#a8570e68a3c50291e7e35225b7e538243">testing_reactor_error_group::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e45204d4f0548306443a2b41a3ce7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e45204d4f0548306443a2b41a3ce7ba">&#9670;&nbsp;</a></span>testing_run_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5e45204d4f0548306443a2b41a3ce7ba">emlabcpp::testing_run_id</a> = typedef uint32_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b065acd5c5329faf70e62bda58d26eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b065acd5c5329faf70e62bda58d26eb">&#9670;&nbsp;</a></span>testing_string_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a9b065acd5c5329faf70e62bda58d26eb">emlabcpp::testing_string_buffer</a> = typedef <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; char, 32 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af66d37dcae87129c4eeba626a3b431d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66d37dcae87129c4eeba626a3b431d4">&#9670;&nbsp;</a></span>testing_test_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af66d37dcae87129c4eeba626a3b431d4">emlabcpp::testing_test_id</a> = typedef uint16_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35fa23942849e26dc612a6608eb2ec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fa23942849e26dc612a6608eb2ec02">&#9670;&nbsp;</a></span>timeq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">emlabcpp::timeq</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a151948c6a8488f45e3d7834f876be469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151948c6a8488f45e3d7834f876be469">&#9670;&nbsp;</a></span>unitless</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a151948c6a8488f45e3d7834f876be469">emlabcpp::unitless</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type alieases of physical quantity for used quantities. </p>

</div>
</div>
<a id="a1133bfe4782c135fcdb04c3de43fc0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133bfe4782c135fcdb04c3de43fc0a1">&#9670;&nbsp;</a></span>velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">emlabcpp::velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c9a554fd1715665000628242b77a474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9a554fd1715665000628242b77a474">&#9670;&nbsp;</a></span>voltage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1c9a554fd1715665000628242b77a474">emlabcpp::voltage</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f05bc39f7d9b7332f437d5a7b19156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f05bc39f7d9b7332f437d5a7b19156c">&#9670;&nbsp;</a></span>volume</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5f05bc39f7d9b7332f437d5a7b19156c">emlabcpp::volume</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 3, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a7efd2ac8dd2ca532b893b1c26565c594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7efd2ac8dd2ca532b893b1c26565c594">&#9670;&nbsp;</a></span>protocol_endianess_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594">emlabcpp::protocol_endianess_enum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum specifies what endianess should be used. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7efd2ac8dd2ca532b893b1c26565c594a53be8bce457a43c78d5047cded7dca4a"></a>PROTOCOL_BIG_ENDIAN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7efd2ac8dd2ca532b893b1c26565c594aa2f671a4536141c87fc72a132d46d839"></a>PROTOCOL_LITTLE_ENDIAN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab01b0d10071d3c9ba7c7b47555aa23f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b0d10071d3c9ba7c7b47555aa23f3">&#9670;&nbsp;</a></span>testing_error_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#ab01b0d10071d3c9ba7c7b47555aa23f3">emlabcpp::testing_error_enum</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a2f44719f4ae62abcbcae09b6f4010b7f"></a>TESTING_TEST_NOT_LOADED_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a28e5f8b0ff0672d27b28c78b7f22f2db"></a>TESTING_TEST_NOT_FOUND_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a367033ddcb9df760599f7d1f7f8c86ef"></a>TESTING_WRONG_RUN_ID_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a1f86d9296a3a68b2172ace730e28dbd2"></a>TESTING_TEST_ALREADY_LOADED_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a00e9b5aca5441fd3028c81e5086e7e99"></a>TESTING_BAD_TEST_ID_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a77465a2c1b2a26e18c4e71f414040d33"></a>TESTING_UNDESIRED_MSG_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3ab67b11ebc9d2740f26e1e8405f3d0b91"></a>TESTING_NO_RESPONSE_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a870a0ce413caecadb69b503aece3c8cf"></a>TESTING_ARG_MISSING_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3a5dc0562ae996c4a4fb7d49869946022d"></a>TESTING_ARG_WRONG_MESSAGE_E&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab01b0d10071d3c9ba7c7b47555aa23f3aa9b1e9ac9d77246619ac5dc1f935cb37"></a>TESTING_ARG_WRONG_TYPE_E&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a39c432c01b63c755cc8dd093c6c770d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c432c01b63c755cc8dd093c6c770d4">&#9670;&nbsp;</a></span>testing_messages_enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a39c432c01b63c755cc8dd093c6c770d4">emlabcpp::testing_messages_enum</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a72a4a7574af7a6c7d0b995c0fe6c8d08"></a>TESTING_EXEC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a731e8c7354bf5b01bca2045f5aef28a4"></a>TESTING_COUNT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4ae72b70736c7329e4159daa2922dd1744"></a>TESTING_NAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a268d8a6175f3026117a34a043b03126f"></a>TESTING_LOAD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a67cda21402e7f8d8e57db5061f23460b"></a>TESTING_ARG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a1401c5abbdf222f7455220c37b788a96"></a>TESTING_SUITE_NAME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a6922eaa8737dea23f704750296c38ab2"></a>TESTING_SUITE_DATE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4aa0261eb0084a09514bfd63fc40dc3ac3"></a>TESTING_COLLECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a995df505cfa8b23d094558924d2ed8fe"></a>TESTING_FINISHED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a2d2e75d3dd5ed8612b8a0d1f7763f662"></a>TESTING_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a5581441dee07e66569e90234d72f3e2e"></a>TESTING_FAILURE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a4790daa6f3f53eef479401fd60851447"></a>TESTING_INTERNAL_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4a2c6a5c63099d8c4f7c77cbfbe3449ae2"></a>TESTING_PROTOCOL_ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a39c432c01b63c755cc8dd093c6c770d4ae02f98d1bd046edd7cb9f5cb3c45e9df"></a>TESTING_ARG_MISSING&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad94cfee3e6e80c1e90bc767e6ace9f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94cfee3e6e80c1e90bc767e6ace9f7e">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with absolute value of internal value. </p>

</div>
</div>
<a id="a1718357386396f122c78205b00bed08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1718357386396f122c78205b00bed08c">&#9670;&nbsp;</a></span>access_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename AccessFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1access__iterator.html">access_iterator</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt;, AccessFunction &gt; &gt; emlabcpp::access_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates view ver container cont with AccessFunction f. </p>
<p>Beware that this produces two copies of f! </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a01d8a4c83393034954b54b0dd6191238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d8a4c83393034954b54b0dd6191238">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T , typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::accumulate </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies function 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, the return value is 'init' value for next round. </p>
<p>NOLINT(bugprone-use-after-move)</p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a1d1440686048e000936426ed21aa3295">init()</a>.</p>

</div>
</div>
<a id="a3c4b8276158ed7d743c68c7395ed0966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c4b8276158ed7d743c68c7395ed0966">&#9670;&nbsp;</a></span>align()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* emlabcpp::align </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: this needs tests. </p>

</div>
</div>
<a id="af23dacc40d13b4848a3af667493a8af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23dacc40d13b4848a3af667493a8af9">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::all_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to function 'f(x)' returns true for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae1eb7bfbbedea4be369b14c29286045a">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a4d436ac46a18d3b5aa2e2e8f253c656b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d436ac46a18d3b5aa2e2e8f253c656b">&#9670;&nbsp;</a></span>almost_equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps' </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ad94cfee3e6e80c1e90bc767e6ace9f7e">abs()</a>.</p>

</div>
</div>
<a id="ae1eb7bfbbedea4be369b14c29286045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1eb7bfbbedea4be369b14c29286045a">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::any_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to function 'f(x)' returns true for at least one item in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#aaf83e29aeab35a17d15504a6dd57dd20">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a63a6aaa5fc338d3d342d90a14225fe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a6aaa5fc338d3d342d90a14225fe82">&#9670;&nbsp;</a></span>apply_on_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit()</a>.</p>

</div>
</div>
<a id="a75cf44a6df8173ea7a46979f57546332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf44a6df8173ea7a46979f57546332">&#9670;&nbsp;</a></span>apply_on_visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="a306d3a03f11c2e95874c23956020a755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d3a03f11c2e95874c23956020a755">&#9670;&nbsp;</a></span>assemble_left_collect_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstE , typename... Eithers&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::assemble_left_collect_right </td>
          <td>(</td>
          <td class="paramtype">FirstE &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eithers &amp;&amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function expects eithers of any left type, but same right type. </p>
<p>These are acceessed and either tuple of <em>all</em> left items is returned or vector of any of right items.</p>
<p>This returns appropiated either&lt; std::tuple&lt; LeftItems... &gt;, <a class="el" href="classemlabcpp_1_1static__vector.html" title="Data container for up to N elements.">static_vector</a>&lt; Righitems, N &gt;&gt;. This is handy for uses cases when you have expected values of multiple functions on the left, / and their errors on the right. It either returns all values or the errors that happend. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">assemble_optionals()</a>.</p>

</div>
</div>
<a id="ac30a98c58cf8a76fa9363a0d19c09486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30a98c58cf8a76fa9363a0d19c09486">&#9670;&nbsp;</a></span>assemble_optionals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1either.html">either</a>&lt; std::tuple&lt; Ts... &gt;, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a> &gt; emlabcpp::assemble_optionals </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; Ts &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function gets a set of various std::optionals and either returns all their values assembled as tuple or '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag" title="Marks empty assembly.">empty_assembly_tag</a>' implicating that some of the optionals was empty. </p>

</div>
</div>
<a id="a82edfd68c59439561d561afe519d68a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82edfd68c59439561d561afe519d68a1">&#9670;&nbsp;</a></span>avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::avg </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies function 'f(x)' to each element of container 'cont' and returns the average value of each call. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a631eb361805aa7459b944503f7538951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631eb361805aa7459b944503f7538951">&#9670;&nbsp;</a></span>cont_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::cont_size </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the container, regardless of what it is. </p>

</div>
</div>
<a id="ab6938a08fc2b09d704fc4e6e8ea5b0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6938a08fc2b09d704fc4e6e8ea5b0b9">&#9670;&nbsp;</a></span>convert_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1convert__iterator.html">convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87ec7e0f819d5864f4e1db7a7a4aafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ec7e0f819d5864f4e1db7a7a4aafdc">&#9670;&nbsp;</a></span>convert_view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1convert__iterator.html">convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view_n </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a172761451ef499ea1a316bf3b683fd16">view_n()</a>.</p>

</div>
</div>
<a id="a364f72aef7b46ed76b90e1f7a054fc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364f72aef7b46ed76b90e1f7a054fc32">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cosinus of the quantity as scalar. </p>

</div>
</div>
<a id="a1f32e86c3dfcebce5092b96b5152e94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f32e86c3dfcebce5092b96b5152e94e">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::count </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the unary function 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="afe935e56d6376df9f87d0d015a3baecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe935e56d6376df9f87d0d015a3baecc">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::enumerate </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac4b40baac2662db6424a475292ef03b3">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip()</a>.</p>

</div>
</div>
<a id="aa67efeff1b8f5b0bb2beea241f352b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67efeff1b8f5b0bb2beea241f352b7a">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container LhContainer, range_container RhContainer&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::equal </td>
          <td>(</td>
          <td class="paramtype">const LhContainer &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhContainer &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true of containers 'lh' and 'rh' has same size and lh[i] == rh[i] for all 0 &lt;= i &lt; size() </p>

</div>
</div>
<a id="ae6a73bbed8b818abff4ab4e7c2b9af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a73bbed8b818abff4ab4e7c2b9af68">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds first item in container 'cont' that is equal to 'item', returns iterator for container and index for tuples. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aaf83e29aeab35a17d15504a6dd57dd20">find_if()</a>.</p>

</div>
</div>
<a id="aaf83e29aeab35a17d15504a6dd57dd20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf83e29aeab35a17d15504a6dd57dd20">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator for first item, for which call to f(*iter) holds true. </p>
<p>end() iterator is returned otherwise. The end() iterator is taken once, before the container is iterated. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="adea1d9aee5b35015e7e174fe87c2b6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea1d9aee5b35015e7e174fe87c2b6d8">&#9670;&nbsp;</a></span>for_cross_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container LhContainer, container RhContainer, typename BinaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_cross_joint </td>
          <td>(</td>
          <td class="paramtype">LhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>lh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>rh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies binary function 'f(x,y)' to each combination of items x in lh_cont and y in rh_cont. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, and <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>.</p>

</div>
</div>
<a id="a836376ebd63413e70abd97e0c49cca90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836376ebd63413e70abd97e0c49cca90">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryFunction&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary function 'f' to each element of container 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="ae8122a76a018ca59cc0549b02ed18523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8122a76a018ca59cc0549b02ed18523">&#9670;&nbsp;</a></span>for_each_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, typename NullFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each_index </td>
          <td>(</td>
          <td class="paramtype">NullFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary function <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f()</a> with template argument of type 'std::size_t', which ranges from 0 to i. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="ab7c44a24d63104ca748cfad65fb1e588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c44a24d63104ca748cfad65fb1e588">&#9670;&nbsp;</a></span>ignore()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::ignore </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sometimes necessary to disable warnings of unused arguments Hint: use std::ignore. </p>

</div>
</div>
<a id="a1d1440686048e000936426ed21aa3295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d1440686048e000936426ed21aa3295">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::init </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips last item of container. </p>

</div>
</div>
<a id="a39d0a9dee2cae8fb64d8be9814c0a032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d0a9dee2cae8fb64d8be9814c0a032">&#9670;&nbsp;</a></span>joined()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::joined </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cont[0] + val + cont[1] + val + cont[2] + ... </p>
<ul>
<li>cont[n-1] + val + cont[n]; </li>
</ul>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a32164e98bc7489fa79dcfa50a7760028">tail()</a>.</p>

</div>
</div>
<a id="acb44994cf1fc5a0a2bfc4896ee8332de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb44994cf1fc5a0a2bfc4896ee8332de">&#9670;&nbsp;</a></span>make_protocol_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a> emlabcpp::make_protocol_mark </td>
          <td>(</td>
          <td class="paramtype">const char(&amp;)&#160;</td>
          <td class="paramname"><em>msg</em>[17]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="structemlabcpp_1_1protocol__mark.html" title="Error handling in protocol works with marks.">protocol_mark</a> from simple string literal. </p>
<p>NOLINTNEXTLINE(modernize-avoid-c-arrays) </p>
<p>note: do not try to fix the argument type, this is correct approach.</p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a5da5d4d444c6f27cbb7df3532ec601cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da5d4d444c6f27cbb7df3532ec601cc">&#9670;&nbsp;</a></span>map_f()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ResultContainer emlabcpp::map_f </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls function f(x) for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned out of the function. </p>
<p>The behavior depends on what kind of 'ResultContainer' is used, rules are in this order:</p><ol type="1">
<li>std::array is constructed and res[i] = f(cont[i]) is used for i = 0...N</li>
<li>if 'ResultContainer' has push_back(x) method, that is used to insert result of calls to f(x)</li>
<li>insert(x) method is used to insert result of calls to f(x) </li>
</ol>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a2e371a56f9ef085edf29095a9a4b45e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e371a56f9ef085edf29095a9a4b45e0">&#9670;&nbsp;</a></span>map_f_to_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; emlabcpp::map_f_to_a </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls function f(cont[i]) for i = 0...N and stores the result in array of an appropiate size. </p>
<p>The functions needs size 'N' as template parameter </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a0abef993d302d6b6d93fe877ca62491c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abef993d302d6b6d93fe877ca62491c">&#9670;&nbsp;</a></span>map_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;arithmetic_operators T, arithmetic_operators U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U emlabcpp::map_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps input value 'input' from input range to equivalent value in output range </p>

</div>
</div>
<a id="a57181a407fd6f29a50664f8ba4cb44cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57181a407fd6f29a50664f8ba4cb44cd">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="ab077da8cbabe4cc68820537ddc602b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab077da8cbabe4cc68820537ddc602b91">&#9670;&nbsp;</a></span>matcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structemlabcpp_1_1matcher.html">emlabcpp::matcher</a> </td>
          <td>(</td>
          <td class="paramtype">Callables &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82bc958527847885bdfc4005b22271e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bc958527847885bdfc4005b22271e6">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with maximum value of one of the quantities. </p>

</div>
</div>
<a id="a5d14c00034fb21bef638c10fa08e5312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d14c00034fb21bef638c10fa08e5312">&#9670;&nbsp;</a></span>max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::max_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary function 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls. </p>
<p>Returns lowest value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, and <a class="el" href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">max()</a>.</p>

</div>
</div>
<a id="ab4db09819cc4cc5a21ed238dd2e30d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4db09819cc4cc5a21ed238dd2e30d6a">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with minimum value of one of the quantities. </p>

</div>
</div>
<a id="ad61b1b453f873c2ecebd79d2c8796393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad61b1b453f873c2ecebd79d2c8796393">&#9670;&nbsp;</a></span>min_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::remove_reference_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::min_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary function 'f(x) to each element of container 'cont, returns the smallest return value of 'f(x)' calls. </p>
<p>Returns maximum value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, <a class="el" href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">max()</a>, and <a class="el" href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">min()</a>.</p>

</div>
</div>
<a id="a664cee55fc768377c8588638004e9d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664cee55fc768377c8588638004e9d98">&#9670;&nbsp;</a></span>min_max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; emlabcpp::min_max_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary function 'f(x)' to each element of container 'cont', returns the largest and the smallest return value. </p>
<p>of 'f(x)' calls. Returns the default value of the 'f(x)' return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a836376ebd63413e70abd97e0c49cca90">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, <a class="el" href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">max()</a>, <a class="el" href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">min()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a48a10ef3efe9c65ebacc0b32339f87a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a10ef3efe9c65ebacc0b32339f87a8">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::none_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to function 'f(x)' returns false for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae1eb7bfbbedea4be369b14c29286045a">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="afaabfb4832972f3f9c7589a82ac8ac4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaabfb4832972f3f9c7589a82ac8ac4f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa5569071253ac2623f7130fd1ff9d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5569071253ac2623f7130fd1ff9d3a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7465ddd19bb5f2eaa845a6cc78b8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7465ddd19bb5f2eaa845a6cc78b8e0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a163dd8154f05ef8a818183d0d44cbcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163dd8154f05ef8a818183d0d44cbcdc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a244aa2b00962ce96249bb72e5d07b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244aa2b00962ce96249bb72e5d07b0c1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const ValueType&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="a384e4bb5a921ff231358ff63aeecbe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384e4bb5a921ff231358ff63aeecbe77">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together. </p>

</div>
</div>
<a id="a9a1b0db510277c2522d504eabc6821e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1b0db510277c2522d504eabc6821e3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of quantity by it's value_type. </p>

</div>
</div>
<a id="aeb7076d68b2c2f2c0114502a2c7b0ce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7076d68b2c2f2c0114502a2c7b0ce5">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , T FromLh, T ToLh, T FromRh, T ToRh&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromLh + FromRh, ToLh + ToRh &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromLh, ToLh &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, FromRh, ToRh &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of two bounded types of same base type is bounded within appropiate ranges. </p>

<p class="reference">References <a class="el" href="classemlabcpp_1_1bounded.html#a4c03b3f83e73a36634b7c8a176a2ef50">emlabcpp::bounded&lt; T, MinVal, MaxVal &gt;::make()</a>.</p>

</div>
</div>
<a id="a37fb61edcdf95a5c2fc63e29d2431946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fb61edcdf95a5c2fc63e29d2431946">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="a4a90457babf1c49444a526a98007a751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a90457babf1c49444a526a98007a751">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc235c95c20406e05b11a433e3ed7857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc235c95c20406e05b11a433e3ed7857">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides negation of the quantity. </p>

</div>
</div>
<a id="a7ec5f53bd49815db80874c10f4742f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec5f53bd49815db80874c10f4742f92">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="a1e7c3c010fa2b7cffe9478558c1d9df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7c3c010fa2b7cffe9478558c1d9df6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ValueType emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype">const ValueType&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="a1fdcd2bf6efc13dd21e3298c777d4982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdcd2bf6efc13dd21e3298c777d4982">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted. </p>

</div>
</div>
<a id="a0176bf0d3582d8fa997f2ae98869d099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0176bf0d3582d8fa997f2ae98869d099">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of quantity by it's value_type. </p>

</div>
</div>
<a id="a1c42d6c592410c5073ecfb18431a4d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c42d6c592410c5073ecfb18431a4d04">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const LhValueType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49a18ed069c328b94893a379a85d855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a18ed069c328b94893a379a85d855f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhValueType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae11acb6ac1c9c88f881b5e5742328b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11acb6ac1c9c88f881b5e5742328b34">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594">protocol_endianess_enum</a> &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594a53be8bce457a43c78d5047cded7dca4a">PROTOCOL_BIG_ENDIAN</a>, and <a class="el" href="namespaceemlabcpp.html#a7efd2ac8dd2ca532b893b1c26565c594aa2f671a4536141c87fc72a132d46d839">PROTOCOL_LITTLE_ENDIAN</a>.</p>

</div>
</div>
<a id="a2face318b969f903389e5ef983b55ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2face318b969f903389e5ef983b55ceb">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__error__record">protocol_error_record</a> &amp;&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a05a3329bfcabf114135f90476bfbcc09">emlabcpp::protocol_error_record::mark</a>, and <a class="el" href="namespaceemlabcpp.html#a8dcbb739bb8a0179b85adc8f351725bb">emlabcpp::protocol_error_record::offset</a>.</p>

</div>
</div>
<a id="a463debb1eef1b03f9b58be24086f4784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463debb1eef1b03f9b58be24086f4784">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1protocol__mark.html">protocol_mark</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe1db526d44b83d4c607b6b3698dfa64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1db526d44b83d4c607b6b3698dfa64">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__message__error">testing_controller_message_error</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>TODO: multiple cases of this, maybe abstract away?</p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a95580a4893efd63e4aa800d599eb2ad0">emlabcpp::testing_controller_message_error::msg_id</a>.</p>

</div>
</div>
<a id="ac980b29573323f3e8dfd06067217bb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980b29573323f3e8dfd06067217bb89">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__controller__protocol__error">testing_controller_protocol_error</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a555ffdabf7ef4cd54e8993dfa47f0164">emlabcpp::testing_controller_protocol_error::rec</a>.</p>

</div>
</div>
<a id="aeaaf334318cd4212e035e0252c7e98bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaf334318cd4212e035e0252c7e98bd">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a23f9646ab3c944247009330cf42fd46a">testing_error_variant</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="a640eedd7f28f5edf3c27cf94144a7609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640eedd7f28f5edf3c27cf94144a7609">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__internal__reactor__error">testing_internal_reactor_error</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a63a6aaa5fc338d3d342d90a14225fe82">apply_on_match()</a>, and <a class="el" href="namespaceemlabcpp.html#aa071beaabe5ee1c0af87ce62efc9f87f">emlabcpp::testing_internal_reactor_error::val</a>.</p>

</div>
</div>
<a id="a0a04e29c11b2fc9f9973df1f901d77d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a04e29c11b2fc9f9973df1f901d77d2">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1testing__reactor__protocol__error">testing_reactor_protocol_error</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa508af544a02cf8d215173408efd76a5">emlabcpp::testing_reactor_protocol_error::rec</a>.</p>

</div>
</div>
<a id="a2f10b2ff6c20f2e8057487e521275521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f10b2ff6c20f2e8057487e521275521">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, typename T , T MinVal, T MaxVal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; T, MinVal, MaxVal &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70ac304c1774efefc635bd44ba74b593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70ac304c1774efefc635bd44ba74b593">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1protocol__message.html">protocol_message</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#ac4b40baac2662db6424a475292ef03b3">range()</a>, and <a class="el" href="classemlabcpp_1_1protocol__message.html#ac87266cff140730fb8ab757e8054fcda">emlabcpp::protocol_message&lt; N &gt;::size()</a>.</p>

</div>
</div>
<a id="a84f533e8e78352f31fb1ff0fbc1c8a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84f533e8e78352f31fb1ff0fbc1c8a85">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, protocol_endianess_enum Endianess, typename... Regs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1protocol__register__map.html">protocol_register_map</a>&lt; Endianess, Regs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae8122a76a018ca59cc0549b02ed18523">for_each_index()</a>.</p>

</div>
</div>
<a id="abf1d2eb2cc5c084a4173867a48032517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf1d2eb2cc5c084a4173867a48032517">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output operator for the view, uses comma to separate the items in the view. </p>

</div>
</div>
<a id="a7dff36c03e0407491a4acf6b85b3f86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dff36c03e0407491a4acf6b85b3f86e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output operator for the view, uses comma to separate the items in the view. </p>

</div>
</div>
<a id="a09ef973500b9ebc01d0f76f50c43aa38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ef973500b9ebc01d0f76f50c43aa38">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Output operator for the view, uses comma to separate the items in the view. </p>

</div>
</div>
<a id="a8eca5f3bb3804309470b88131f9417de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eca5f3bb3804309470b88131f9417de">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, typename T , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; T, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a155a6828d776fbc298d37aabee6bc0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155a6828d776fbc298d37aabee6bc0d7">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ostreamlike Stream, auto ID&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">Stream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1tag.html">tag</a>&lt; ID &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2254b75f92599473cee7451ded051a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2254b75f92599473cee7451ded051a0e">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#af6923c24f500869e457a4ca7f2fb9426">emlabcpp::static_circular_buffer&lt; T, N &gt;::begin()</a>, and <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#aa8165951ae18e5a305ee580be7c749d4">emlabcpp::static_circular_buffer&lt; T, N &gt;::end()</a>.</p>

</div>
</div>
<a id="a640640991a3cfee97b11ab4df8759583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640640991a3cfee97b11ab4df8759583">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__vector.html#a3aa21b589fbecd34ed3f487ba81c4534">emlabcpp::static_vector&lt; T, N &gt;::begin()</a>, and <a class="el" href="classemlabcpp_1_1static__vector.html#a5ff32c8ea013a8be31e716d472f84bbb">emlabcpp::static_vector&lt; T, N &gt;::end()</a>.</p>

</div>
</div>
<a id="abe4e80e0e361283130d83856b68f4e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4e80e0e361283130d83856b68f4e6d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#a4a90f093a980231b0156e8ed33c6e1f1">emlabcpp::static_circular_buffer&lt; T, N &gt;::size()</a>.</p>

</div>
</div>
<a id="accaccb739b9336c5bd977ad988c3d336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaccb739b9336c5bd977ad988c3d336">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__vector.html#a69dc10d4fa55b6747ef48967e8ee9805">emlabcpp::static_vector&lt; T, N &gt;::size()</a>.</p>

</div>
</div>
<a id="a541f323f095107eec70dbb1db1387711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541f323f095107eec70dbb1db1387711">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a465e78169e53ecff3e2377283787a2e9">emlabcpp::view&lt; Iterator &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1view.html#a30a11defa5a206b6355bee7a540ab795">emlabcpp::view&lt; Iterator &gt;::end()</a>, and <a class="el" href="classemlabcpp_1_1view.html#aaa812fd178fc993e11fbbbc5894fb3c3">emlabcpp::view&lt; Iterator &gt;::size()</a>.</p>

</div>
</div>
<a id="a9b9eb800885b61e8071ef11e69debdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9eb800885b61e8071ef11e69debdf6">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power of physical quantity is power of root of it's value and the exponents are multiplied by the value. </p>

</div>
</div>
<a id="a46d4ea091d64444e17a8e74d672c3c6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d4ea091d64444e17a8e74d672c3c6c">&#9670;&nbsp;</a></span>pretty_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string emlabcpp::pretty_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr  />
<p> / central function for returning name of type that can demangle if necessary </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="af2b1cef1d03b8bfeb3f4e81f54a72dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b1cef1d03b8bfeb3f4e81f54a72dba">&#9670;&nbsp;</a></span>protocol_for_each_register()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Map , typename UnaryFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::protocol_for_each_register </td>
          <td>(</td>
          <td class="paramtype">const Map &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a2af5aa50c92bf95bb01b6eb333b32dcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af5aa50c92bf95bb01b6eb333b32dcd">&#9670;&nbsp;</a></span>protocol_simple_load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequencer , typename ReadCallback &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; typename Sequencer::message_type &gt; emlabcpp::protocol_simple_load </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>read_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadCallback &amp;&amp;&#160;</td>
          <td class="paramname"><em>read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1f32e86c3dfcebce5092b96b5152e94e">count()</a>, <a class="el" href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">match()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="ac4b40baac2662db6424a475292ef03b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b40baac2662db6424a475292ef03b3">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1numeric__iterator.html">numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [from, to) </p>

</div>
</div>
<a id="a2d76a81f2d964ef275dd31aab2737973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d76a81f2d964ef275dd31aab2737973">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1numeric__iterator.html">numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [0, to) </p>

</div>
</div>
<a id="aab6fd32a8b3335eec93b94331d4293b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fd32a8b3335eec93b94331d4293b0">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns index of an element in tuple 't', for which call to f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, and <a class="el" href="namespaceemlabcpp_1_1impl.html#afdd163fc58b80f48ae4783294b6ebc8e">emlabcpp::impl::find_if_impl()</a>.</p>

</div>
</div>
<a id="a670099942b8cdd3d2cc28760b1717d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670099942b8cdd3d2cc28760b1717d7c">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryFunction&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies unary function 'f' to each element of container 'cont'. </p>

</div>
</div>
<a id="a3798c779ce948989ea0a3c699bc74b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3798c779ce948989ea0a3c699bc74b59">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename NullFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!requires(NullFunction <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function expectes bounded value as index input and callable nullary function. </p>
<p>Based on the value of index, <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f()</a> is called with template argument std::size_t with internal value of the provided index. Expectes the bounded value to be valid (that is within the range) </p>

</div>
</div>
<a id="aeff9499fee336e01a6b1a70d8d6fd63d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff9499fee336e01a6b1a70d8d6fd63d">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename NullFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">NullFunction&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a3dcd56ce6fdffb4ebcf8a4c079335d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd56ce6fdffb4ebcf8a4c079335d8e">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint16_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac39ed97224e397106e08c6e04012e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39ed97224e397106e08c6e04012e62a">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint32_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2acb59e904f4530e0e8d42e98f67bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acb59e904f4530e0e8d42e98f67bcaa">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint64_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd74c7df9ccef5ce376d2c3fe2ef8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd74c7df9ccef5ce376d2c3fe2ef8908">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint8_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3921b804e7ed8b1041ec50f786404c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3921b804e7ed8b1041ec50f786404c28">&#9670;&nbsp;</a></span>reversed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::reversed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype( container.rbegin() ) &gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns view to the Container in reverse order. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>.</p>

</div>
</div>
<a id="a682d97f0829a04051ce4240be4312a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682d97f0829a04051ce4240be4312a9a">&#9670;&nbsp;</a></span>select_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">i&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[&amp;] &lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();}&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3014f69ce198b53f5238543e98cc6970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3014f69ce198b53f5238543e98cc6970">&#9670;&nbsp;</a></span>select_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a61ee3ba374b4601759b8c7dd7b2ddfe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ee3ba374b4601759b8c7dd7b2ddfe3">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int emlabcpp::sign </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sign of variable T: -1,0,1 </p>

</div>
</div>
<a id="aa3d3eb598a75856181b79136ed06dbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d3eb598a75856181b79136ed06dbd8">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sinus of the quantity as scalar. </p>

</div>
</div>
<a id="a5519896c5f0324265089711b6a020642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5519896c5f0324265089711b6a020642">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square root of physical quantity is square root of it's value and the exponents are divided in half. </p>

</div>
</div>
<a id="a46f1323b0b8ce43a44ca13753d457260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f1323b0b8ce43a44ca13753d457260">&#9670;&nbsp;</a></span>subscript_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1subscript__iterator.html">subscript_iterator</a>&lt; Container &gt; &gt; emlabcpp::subscript_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af1f78b7389a240de94195008ba1efb03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f78b7389a240de94195008ba1efb03">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item. </p>

</div>
</div>
<a id="aba54ad76836fd2a980ac4d6cf8d648af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba54ad76836fd2a980ac4d6cf8d648af">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__vector.html#aa311b7e7e5ad50d9b413f58a3a7087ab">emlabcpp::static_vector&lt; T, N &gt;::swap()</a>.</p>

</div>
</div>
<a id="a32164e98bc7489fa79dcfa50a7760028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32164e98bc7489fa79dcfa50a7760028">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::tail </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips first item of container. </p>

</div>
</div>
<a id="ae2330aaaa31e126417ac8ff0ac1fe5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2330aaaa31e126417ac8ff0ac1fe5b7">&#9670;&nbsp;</a></span>testing_compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;testing_test T, testing_callable C&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1testing__composer.html">testing_composer</a>&lt; T, C &gt; emlabcpp::testing_compose </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5db275e21ec862a7a5eb6a6cb576280b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5db275e21ec862a7a5eb6a6cb576280b">&#9670;&nbsp;</a></span>testing_key_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceemlabcpp.html#abfb5a005e75f7e4f58008d4ed698e9d1">testing_key_buffer</a> emlabcpp::testing_key_to_buffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9142ef85b5234e04943a331ec21ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9142ef85b5234e04943a331ec21ebab">&#9670;&nbsp;</a></span>testing_name_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceemlabcpp.html#a289862982d90d50fae8def7c9491fac3">testing_name_buffer</a> emlabcpp::testing_name_to_buffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sview</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d2cc6723ddd36a82e4ed013601e7725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d2cc6723ddd36a82e4ed013601e7725">&#9670;&nbsp;</a></span>testing_string_to_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceemlabcpp.html#a9b065acd5c5329faf70e62bda58d26eb">testing_string_buffer</a> emlabcpp::testing_string_to_buffer </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>sview</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: maybe make a function in <a class="el" href="classemlabcpp_1_1static__vector.html" title="Data container for up to N elements.">static_vector</a> namespace? </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">min()</a>.</p>

</div>
</div>
<a id="a793151b3dbb2a3d533314e5a55cf6f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793151b3dbb2a3d533314e5a55cf6f54">&#9670;&nbsp;</a></span>trim_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt; emlabcpp::trim_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items. </p>
<p>This can be used to get the dataset without first/last 5% for example, by using r=0.1 </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="aa8b8f5742901528282a9da6b8317e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b8f5742901528282a9da6b8317e7b5">&#9670;&nbsp;</a></span>tuple_zip_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::tuple_zip_impl </td>
          <td>(</td>
          <td class="paramtype">TuplesTuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tpls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; ItemIndexes... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; TupleIndexes... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="a349d57e03a29dec812f941205b421f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349d57e03a29dec812f941205b421f91">&#9670;&nbsp;</a></span>until_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, typename PredFunction &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::until_index </td>
          <td>(</td>
          <td class="paramtype">PredFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary predicate <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f()</a> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true. </p>
<p>Function returns whenever the f was called or not. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>.</p>

</div>
</div>
<a id="ac2da72b049f415878bb6a90c76e165bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2da72b049f415878bb6a90c76e165bd">&#9670;&nbsp;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryFunction = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::variance </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies function 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call. </p>
<p>The <code>f</code> is applied twice to each element. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a82edfd68c59439561d561afe519d68a1">avg()</a>, <a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#af1f78b7389a240de94195008ba1efb03">sum()</a>.</p>

</div>
</div>
<a id="a4b726ddab4f550f3e186f177243cb09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b726ddab4f550f3e186f177243cb09b">&#9670;&nbsp;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">emlabcpp::view</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The container deduction guide uses iterator_of_t. </p>

</div>
</div>
<a id="a172761451ef499ea1a316bf3b683fd16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172761451ef499ea1a316bf3b683fd16">&#9670;&nbsp;</a></span>view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt; emlabcpp::view_n </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range! </p>

</div>
</div>
<a id="a6e4b7b6dd8a3a27f7f7bcea52f265b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41ab261a0f296f3c9862e59e12339885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ab261a0f296f3c9862e59e12339885">&#9670;&nbsp;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view of zip iterators for specified containers. </p>
<p>Beware that the function does not check that containers have same size of ranges. If the size differs, increments of begin iterator will never be same as end iterator. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view()</a>.</p>

</div>
</div>
<a id="a1c07efb3691ae81d8dbffdeed5ee54e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c07efb3691ae81d8dbffdeed5ee54e7">&#9670;&nbsp;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename... Tuples, std::enable_if_t&lt; is_std_tuple_v&lt; Tuple &gt; &gt; *  = nullptr, std::enable_if_t&lt; std::conjunction_v&lt; is_std_tuple&lt; std::decay_t&lt; Tuples &gt; &gt;... &gt; &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>frst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuples &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tpls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Zips a set of tuples of same size into a new tuple. </p>
<p>zip(tuple&lt;A,B&gt;(), tuple&lt;C,D&gt;()) -&gt; tuple&lt;tuple&lt;A,C&gt;, &lt;tuple&lt;B,d&gt;&gt;; </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae5e4923a149af384640fe5d3759dcc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e4923a149af384640fe5d3759dcc9a">&#9670;&nbsp;</a></span>are_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::are_same_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61e7321a7721894fde42b2da9bf2cbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7321a7721894fde42b2da9bf2cbd8">&#9670;&nbsp;</a></span>arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70c87fb6240fb7ebbfbb27d7b25b999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70c87fb6240fb7ebbfbb27d7b25b999">&#9670;&nbsp;</a></span>arithmetic_assignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_assignment</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a, T b )</div>
<div class="line">{</div>
<div class="line">        { a += b };</div>
<div class="line">        { a -= b };</div>
<div class="line">        { a /= b };</div>
<div class="line">        { a *= b };</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5494e6f6f24a2fd7e7ccfaecb31944b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5494e6f6f24a2fd7e7ccfaecb31944b3">&#9670;&nbsp;</a></span>arithmetic_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_like = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94924279b38cf1803ee0f01cb4889b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94924279b38cf1803ee0f01cb4889b24">&#9670;&nbsp;</a></span>arithmetic_operators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a, T b )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                a + b</div>
<div class="line">                } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">        {</div>
<div class="line">                a - b</div>
<div class="line">                } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">        {</div>
<div class="line">                a / b</div>
<div class="line">                } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">        {</div>
<div class="line">                a* b</div>
<div class="line">                } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a145bebab87eba36baf2eeac66f12ded2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145bebab87eba36baf2eeac66f12ded2">&#9670;&nbsp;</a></span>BADVAL_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::BADVAL_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBADVAL &quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>parsed value is not correct, such as constant </p>

</div>
</div>
<a id="a0f3ea4ba31c3aac1ca5db845fbe67711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3ea4ba31c3aac1ca5db845fbe67711">&#9670;&nbsp;</a></span>BIGSIZE_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::BIGSIZE_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBIGSIZE &quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>too much bytes left in the message for the item </p>

</div>
</div>
<a id="a7b5a68de4881301e46697c48654d8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a68de4881301e46697c48654d8477">&#9670;&nbsp;</a></span>bounded_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::bounded_constant = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, N, N &gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple type alias for bounded index constants. </p>

</div>
</div>
<a id="add79493bcf07bd4c54afffe3a0f3ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add79493bcf07bd4c54afffe3a0f3ee00">&#9670;&nbsp;</a></span>bounded_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::bounded_derived</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T val )</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1detail.html#aa15d5c022409d351cd45334d7501dc72">detail::bounded_derived_test</a>( val );</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Concept that matchestype deriving from bounded. </p>

</div>
</div>
<a id="a0e05bb2d6769aee5b01021e927a54b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e05bb2d6769aee5b01021e927a54b65">&#9670;&nbsp;</a></span>BOUNDS_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::BOUNDS_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPBOUNDS &quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>value in the message is outside of the range of bounded type </p>

</div>
</div>
<a id="a1464a98bcd956131d445b317f4e8814f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1464a98bcd956131d445b317f4e8814f">&#9670;&nbsp;</a></span>CHECKSUM_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::CHECKSUM_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPCHECKSUM&quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrong checksum in the protocol </p>

</div>
</div>
<a id="ac6a5e3253aa7ea8bcd6574b3274c74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5e3253aa7ea8bcd6574b3274c74b6">&#9670;&nbsp;</a></span>container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeb742c691973ef2d34b0ace4d8eef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb742c691973ef2d34b0ace4d8eef15">&#9670;&nbsp;</a></span>container_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container_invocable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a> )</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>( *cont.begin() );</div>
<div class="line">}</div>
<div class="line">|| <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( Container cont )</div>
<div class="line">{</div>
<div class="line">        std::tuple_size&lt; std::decay_t&lt; Container &gt; &gt;::value == 0;</div>
<div class="line">}</div>
<div class="line">|| <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a> )</div>
<div class="line">{</div>
<div class="line">        </div>
<div class="line">        <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>( std::get&lt; 0 &gt;( cont ) );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a20db02f115d34db629106a39c5194e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db02f115d34db629106a39c5194e18">&#9670;&nbsp;</a></span>default_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::default_epsilon = 1.19e-07<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a459242c17dfd40402115fe8a63d21622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459242c17dfd40402115fe8a63d21622">&#9670;&nbsp;</a></span>either_uniquely_right_item</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LH , typename RH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::either_uniquely_right_item</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::same_as&lt; std::decay_t&lt; T &gt;, RH &gt; &amp;&amp; !std::same_as&lt; LH, RH &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2351d7b7de1988dbb2979cadfd729d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2351d7b7de1988dbb2979cadfd729d1f">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NullFunction &amp;&amp; emlabcpp::f</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        std::apply(</div>
<div class="line">            [&amp;]&lt; <span class="keyword">typename</span>... Items &gt;( Items&amp;&amp;... items ) {</div>
<div class="line">                    ( <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>( std::forward&lt; Items &gt;( items ) ), ... );</div>
<div class="line">            },</div>
<div class="line">            std::forward&lt; Container &gt;( cont ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb54eee14fc87e50de7f6ed35ad1aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54eee14fc87e50de7f6ed35ad1aba0">&#9670;&nbsp;</a></span>gettable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::gettable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value</div>
<div class="line">                } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aca0086d26c146022436c25e55e690c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0086d26c146022436c25e55e690c79">&#9670;&nbsp;</a></span>GROUP_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::GROUP_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPGRPMATCH&quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>no item of group matched the content of message </p>

</div>
</div>
<a id="adaca063c7275419f3999bd854c88de3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca063c7275419f3999bd854c88de3d">&#9670;&nbsp;</a></span>has_static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::has_static_size_v = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr  />
<p> has_static_size&lt;T&gt;::value is true in case type T have size deduceable at compile time </p>

</div>
</div>
<a id="a5219e24bd076b3c65f56c69b9025dd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5219e24bd076b3c65f56c69b9025dd69">&#9670;&nbsp;</a></span>invocable_returning</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction , typename ReturnValue , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::invocable_returning</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( <a class="code" href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">UnaryFunction</a> <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>, Args... args )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                <a class="code" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a>( args... )</div>
<div class="line">                } -&gt; std::same_as&lt; ReturnValue &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d463be90e36b5d5be447e407fca17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d463be90e36b5d5be447e407fca17bf">&#9670;&nbsp;</a></span>is_std_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_array_v = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a633f5fea14133c23b25a75cd57a8805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f5fea14133c23b25a75cd57a8805d">&#9670;&nbsp;</a></span>is_std_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_tuple_v = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5277a3e558d32758ca0e4770ed5e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5277a3e558d32758ca0e4770ed5e1eb">&#9670;&nbsp;</a></span>is_std_vector_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_vector_v = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff43a196db9cecc357e6f4452638b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff43a196db9cecc357e6f4452638b32f">&#9670;&nbsp;</a></span>is_view_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_view_v = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50429a6831c33bfc19692833c3a6b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50429a6831c33bfc19692833c3a6b0c1">&#9670;&nbsp;</a></span>LOWSIZE_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::LOWSIZE_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPLOWSIZE &quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>not enough bytes left in the message for the item </p>

</div>
</div>
<a id="a27325f314502897567307b29b2b03776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27325f314502897567307b29b2b03776">&#9670;&nbsp;</a></span>ostreamlike</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::ostreamlike</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T val )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                val.good()</div>
<div class="line">                } -&gt; std::same_as&lt; bool &gt;;</div>
<div class="line">        {</div>
<div class="line">                val.bad()</div>
<div class="line">                } -&gt; std::same_as&lt; bool &gt;;</div>
<div class="line">        bool( val );</div>
<div class="line">        <span class="keyword">typename</span> T::char_type;</div>
<div class="line">        detail::directly_streamable_for&lt; T, uint8_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, uint16_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, uint32_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, int8_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, int16_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, int32_t &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, float &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, double &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, bool &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, const void* &gt;;</div>
<div class="line">        detail::directly_streamable_for&lt; T, std::nullptr_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cac9e89744ae1ec8ad817df33d291f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cac9e89744ae1ec8ad817df33d291f1">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> emlabcpp::pi = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">f</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants of units that are relevant for us. </p>

</div>
</div>
<a id="abab7e77781bf7b562c6fdf625db0b576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab7e77781bf7b562c6fdf625db0b576">&#9670;&nbsp;</a></span>protocol_base_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_base_type = std::is_integral_v&lt; T &gt; || std::is_enum_v&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept that matches types considered base - serialized directly by using byte shifting. </p>

</div>
</div>
<a id="a602f297ea94780303fcf0369627f5e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602f297ea94780303fcf0369627f5e72">&#9670;&nbsp;</a></span>protocol_declarable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_declarable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( D val )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                protocol_decl&lt; D &gt;::max_size</div>
<div class="line">                } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">        {</div>
<div class="line">                protocol_decl&lt; D &gt;::min_size</div>
<div class="line">                } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">        std::default_initializable&lt; typename protocol_decl&lt; D &gt;::value_type &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>This concepts limits types to types that can be declared, that is the overload of '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl" title="Each definition of item provided to protocol library should have specialization of &#39;protocol_decl&#39; st...">protocol_decl</a>' is fully defined: protocol_decl::value_type contains definition of value produced by the declaration, protocol_decl::max_size contains estimated maximal size in bytes taken by the serialized value in the message. </p>
<p>protocol_decl::min_size should contain minimal size used. </p>

</div>
</div>
<a id="acf01e75bfbd6924b7d262036e65a0881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf01e75bfbd6924b7d262036e65a0881">&#9670;&nbsp;</a></span>protocol_def_check</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_def_check</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>()</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                T::max_size</div>
<div class="line">                } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">        <span class="keyword">typename</span> T::value_type;</div>
<div class="line">        bounded_derived&lt; typename T::size_type &gt;;</div>
<div class="line">}</div>
<div class="line">&amp;&amp;<a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( std::span&lt; uint8_t, T::max_size &gt; buff, <span class="keyword">typename</span> T::value_type item )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                T::serialize_at( buff, item )</div>
<div class="line">                } -&gt; std::same_as&lt; typename T::size_type &gt;;</div>
<div class="line">}</div>
<div class="line">&amp;&amp;<a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( bounded_view&lt; const uint8_t*, typename T::size_type &gt; buff )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                T::deserialize( buff )</div>
<div class="line">                } -&gt; std::same_as&lt; protocol_result&lt; typename T::value_type &gt; &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>protocol_def_check&lt;T&gt; concept verifies that 'T' is valid overload of <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__def" title="protocol_def&lt;T,E&gt; structure defines how type T should be serialized and deserialized.">protocol_def</a>. </p>
<p>Use this in tests of custom <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__def" title="protocol_def&lt;T,E&gt; structure defines how type T should be serialized and deserialized.">protocol_def</a> overloads. </p>

</div>
</div>
<a id="a9647fb1b94d3992c20f0c5017049a67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9647fb1b94d3992c20f0c5017049a67a">&#9670;&nbsp;</a></span>protocol_fixedly_sized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_fixedly_sized = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">protocol_decl</a>&lt; T &gt;::min_size == <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1protocol__decl">protocol_decl</a>&lt; T &gt;::max_size</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc59d4efcbda0164962a9720e2c1e8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc59d4efcbda0164962a9720e2c1e8f6">&#9670;&nbsp;</a></span>protocol_message_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_message_derived</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T val )</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1detail.html#a70e6b942ad12ffa5b8b9c5080ced861e">detail::protocol_message_derived_test</a>( val );</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>concept matches any type that is <a class="el" href="classemlabcpp_1_1protocol__message.html" title="Protocol library has custom type that represents message, however this is just simple overaly over st...">protocol_message</a> or derives from it. </p>

</div>
</div>
<a id="aeee9999dcf24d3acafa60872b768205e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee9999dcf24d3acafa60872b768205e">&#9670;&nbsp;</a></span>protocol_packet_def</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_packet_def</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T t )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                T::endianess</div>
<div class="line">                } -&gt; std::convertible_to&lt; protocol_endianess_enum &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp.html#a1d463be90e36b5d5be447e407fca17bf">is_std_array_v</a>&lt; std::decay_t&lt; decltype( T::prefix ) &gt; &gt;;</div>
<div class="line">        protocol_declarable&lt; typename T::size_type &gt;;</div>
<div class="line">        protocol_declarable&lt; typename T::checksum_type &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab5384f85878a19eecba149c46ea300dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5384f85878a19eecba149c46ea300dc">&#9670;&nbsp;</a></span>protocol_register_map_void_returning</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryFunction , typename Registers &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::protocol_register_map_void_returning</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    invocable_returning&lt; UnaryFunction, void, std::tuple_element_t&lt; 0, Registers &gt; &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a869ab03f1bd49e1adc49de513ad86ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869ab03f1bd49e1adc49de513ad86ba4">&#9670;&nbsp;</a></span>quantity_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::quantity_derived</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T val )</div>
<div class="line">{</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1detail.html#a8be65555da61958326df0b50c6ee2bd8">detail::quantity_derived_test</a>( val );</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a904e4439ee5b6a29ec1c9a5a6d404c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e4439ee5b6a29ec1c9a5a6d404c55">&#9670;&nbsp;</a></span>range_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (</div>
<div class="line">                              <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a ) { begin( a ); } ||</div>
<div class="line">                              <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a ) { std::begin( a ); } ) &amp;&amp;</div>
<div class="line">                          (</div>
<div class="line">                              <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a ) { end( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a ) { std::end( a ); } )</div>
</div><!-- fragment -->
<p>so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible </p>

</div>
</div>
<a id="ad5b78b4d7a2e426170153951069c76cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b78b4d7a2e426170153951069c76cf">&#9670;&nbsp;</a></span>referenceable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::referenceable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= is_view&lt; T &gt;::value ||</div>
<div class="line">    ( range_container&lt; T &gt; &amp;&amp; !std::is_rvalue_reference_v&lt; T &gt; )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f3571963bbe0982f9987b78b111c626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3571963bbe0982f9987b78b111c626">&#9670;&nbsp;</a></span>res</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return emlabcpp::res {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0600b5cf194accae7c5238c9972cad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0600b5cf194accae7c5238c9972cad1">&#9670;&nbsp;</a></span>SIZE_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::SIZE_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPSIZE &quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e849ebc932caa63f7e1e6c67d0c2f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e849ebc932caa63f7e1e6c67d0c2f7b">&#9670;&nbsp;</a></span>static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::static_size_v = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marked deprecated on 19.4.2021. </p>

</div>
</div>
<a id="a8114b1d4bc758992dd14a1d64bd454c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8114b1d4bc758992dd14a1d64bd454c5">&#9670;&nbsp;</a></span>static_sized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::static_sized</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T a )</div>
<div class="line">{</div>
<div class="line">        {</div>
<div class="line">                std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value</div>
<div class="line">                } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7eff427e2ab20965ca0f25f45bacf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7eff427e2ab20965ca0f25f45bacf49">&#9670;&nbsp;</a></span>testing_callable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::testing_callable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">requires</a>( T t, testing_record&amp; rec )</div>
<div class="line">{</div>
<div class="line">        t( rec );</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>&amp;&amp; std::movable&lt; T &gt;; </p>

</div>
</div>
<a id="a21f75ff24381eb238fa2d96e7b7788ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f75ff24381eb238fa2d96e7b7788ce">&#9670;&nbsp;</a></span>testing_test</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::testing_test = std::derived_from&lt; T, <a class="el" href="classemlabcpp_1_1testing__interface.html">testing_interface</a> &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8574533cb7c969125a6fde8f5063eff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574533cb7c969125a6fde8f5063eff2">&#9670;&nbsp;</a></span>tuple_has_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::tuple_has_type_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35890f89255716603146448591d91823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35890f89255716603146448591d91823">&#9670;&nbsp;</a></span>UnaryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::UnaryFunction</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keyword">using</span> type = decltype( std::declval&lt; UnaryFunction &gt;()(</div>
<div class="line">            std::get&lt; 0 &gt;( std::declval&lt; Container &gt;() ) ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2a0d60b3b8af2bc89f3dc4f985a67aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0d60b3b8af2bc89f3dc4f985a67aff">&#9670;&nbsp;</a></span>UNDEFVAR_ERR</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::UNDEFVAR_ERR = <a class="el" href="namespaceemlabcpp.html#acb44994cf1fc5a0a2bfc4896ee8332de">make_protocol_mark</a>( &quot;EMLABCPPUNDEFVAR&quot; )</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>variant id is outside of the range for defined variant </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespaceemlabcpp_html_a2351d7b7de1988dbb2979cadfd729d1f"><div class="ttname"><a href="namespaceemlabcpp.html#a2351d7b7de1988dbb2979cadfd729d1f">emlabcpp::f</a></div><div class="ttdeci">UnaryFunction &amp;&amp; f</div><div class="ttdef"><b>Definition:</b> algorithm.h:129</div></div>
<div class="ttc" id="anamespaceemlabcpp_1_1detail_html_aa15d5c022409d351cd45334d7501dc72"><div class="ttname"><a href="namespaceemlabcpp_1_1detail.html#aa15d5c022409d351cd45334d7501dc72">emlabcpp::detail::bounded_derived_test</a></div><div class="ttdeci">constexpr bool bounded_derived_test(const bounded&lt; T, MinVal, MaxVal &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> bounded.h:134</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a35890f89255716603146448591d91823"><div class="ttname"><a href="namespaceemlabcpp.html#a35890f89255716603146448591d91823">emlabcpp::UnaryFunction</a></div><div class="ttdeci">UnaryFunction</div><div class="ttdef"><b>Definition:</b> types.h:26</div></div>
<div class="ttc" id="anamespaceemlabcpp_1_1impl_html_a973ded016662ca00739321b5d00113e0"><div class="ttname"><a href="namespaceemlabcpp_1_1impl.html#a973ded016662ca00739321b5d00113e0">emlabcpp::impl::requires</a></div><div class="ttdeci">requires(!range_container&lt; Container &gt;) inline std</div><div class="ttdef"><b>Definition:</b> impl.h:59</div></div>
<div class="ttc" id="anamespaceemlabcpp_1_1detail_html_a8be65555da61958326df0b50c6ee2bd8"><div class="ttname"><a href="namespaceemlabcpp_1_1detail.html#a8be65555da61958326df0b50c6ee2bd8">emlabcpp::detail::quantity_derived_test</a></div><div class="ttdeci">constexpr bool quantity_derived_test(const quantity&lt; Derived, ValueType &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> quantity.h:119</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_a1d463be90e36b5d5be447e407fca17bf"><div class="ttname"><a href="namespaceemlabcpp.html#a1d463be90e36b5d5be447e407fca17bf">emlabcpp::is_std_array_v</a></div><div class="ttdeci">constexpr bool is_std_array_v</div><div class="ttdef"><b>Definition:</b> base.h:124</div></div>
<div class="ttc" id="anamespaceemlabcpp_1_1detail_html_a70e6b942ad12ffa5b8b9c5080ced861e"><div class="ttname"><a href="namespaceemlabcpp_1_1detail.html#a70e6b942ad12ffa5b8b9c5080ced861e">emlabcpp::detail::protocol_message_derived_test</a></div><div class="ttdeci">constexpr bool protocol_message_derived_test(const protocol_message&lt; N &gt; &amp;)</div><div class="ttdef"><b>Definition:</b> message.h:168</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceemlabcpp.html">emlabcpp</a></li>
    <li class="footer">Generated on Sun May 1 2022 15:02:26 for emlabcpp by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
