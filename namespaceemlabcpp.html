<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emlabcpp: emlabcpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emlabcpp
   </div>
   <div id="projectbrief">modern opinionated embedded C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceemlabcpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">emlabcpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright (C) 2020 Jan Veverak Koniarik.  
<a href="namespaceemlabcpp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceemlabcpp_1_1cfg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1cfg.html">cfg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1coro"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1coro.html">coro</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1coro"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1iterators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1iterators.html">iterators</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1logging"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1logging.html">logging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1pmr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1pmr.html">pmr</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1pmr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1protocol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1protocol.html">protocol</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1rpc.html">rpc</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1rpc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1testing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1testing.html">testing</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1testing"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copyright (C) 2020 Jan Veverak Koniarik. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper structure for finding the smallest and the largest item in some container, contains min/max attributes representing such elements.  <a href="structemlabcpp_1_1min__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1convert__to.html">convert_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object with <code>operator()</code> that constructs object of type <code>T</code>out of passed-in value.  <a href="structemlabcpp_1_1convert__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded.html">bounded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bounded type represents a overlay over type T which is constrained between MinVal and MaxVal as compile time constants.  <a href="classemlabcpp_1_1bounded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01bounded_3_01T_00_01MinVal_00_01MaxVal_01_4_01_4.html">pretty_printer&lt; bounded&lt; T, MinVal, MaxVal &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1defer.html">defer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defer is an object that receives and stores callable, which is called on it's destruction.  <a href="classemlabcpp_1_1defer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1either.html">either</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Either is heterogenous structure that holds one of the two types specified.  <a href="classemlabcpp_1_1either.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1empty__assembly__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1empty__assembly__tag"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks empty assembly.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1empty__assembly__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded__view.html">bounded_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1cobs__decoder.html">cobs_decoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__request__adapter.html">contiguous_request_adapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__object__handle.html">contiguous_object_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__array__handle.html">contiguous_array_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__node.html">contiguous_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__tree.html">contiguous_tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1derived__storage.html">derived_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classemlabcpp_1_1function__view"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1function__view">function_view</a></td></tr>
<tr class="separator:classemlabcpp_1_1function__view"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1function__view_3_01ReturnType_07ArgTypes_8_8_8_08_01_4.html">function_view&lt; ReturnType(ArgTypes...) &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1point.html">point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing multidimensional point in coordinate system of dimension N.  <a href="classemlabcpp_1_1point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pose__distance"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1pose__distance"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance between two poses in space, represented as 'space distance' and 'angular distance'  <a href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1pose__distance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pose.html">pose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents orientation and position in 3D space  <a href="structemlabcpp_1_1pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">API and behavior of this is inspired by tf::Quaternion.  <a href="classemlabcpp_1_1quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1linked__list__node.html">linked_list_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1log__colors"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a></td></tr>
<tr class="separator:structemlabcpp_1_1log__colors"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1log__color__stub"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__color__stub">log_color_stub</a></td></tr>
<tr class="separator:structemlabcpp_1_1log__color__stub"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1timelog.html">timelog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01timelog_01_4.html">pretty_printer&lt; timelog &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1transposed__matrix.html">transposed_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1identity__matrix.html">identity_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1rowcol__submatrix.html">rowcol_submatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01T_01_4.html">pretty_printer&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pretty__printer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pretty__printer">pretty_printer</a></td></tr>
<tr class="separator:structemlabcpp_1_1pretty__printer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1buffer__writer.html">buffer_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1recursive__writer.html">recursive_writer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__stream.html">pretty_stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1byte_01_4.html">pretty_printer&lt; std::byte &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01signed_01char_01_4.html">pretty_printer&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01short_01int_01_4.html">pretty_printer&lt; short int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01int_01_4.html">pretty_printer&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01long_01int_01_4.html">pretty_printer&lt; long int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01unsigned_01char_01_4.html">pretty_printer&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01short_01unsigned_01_4.html">pretty_printer&lt; short unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01unsigned_01_4.html">pretty_printer&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01long_01unsigned_01_4.html">pretty_printer&lt; long unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01float_01_4.html">pretty_printer&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01char_01_4.html">pretty_printer&lt; char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01char_0fN_0e_01_4.html">pretty_printer&lt; char[N] &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1string_01_4.html">pretty_printer&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01bool_01_4.html">pretty_printer&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01view_3_01Iterator_01_4_01_4.html">pretty_printer&lt; view&lt; Iterator &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1span_3_01T_00_01N_01_4_01_4.html">pretty_printer&lt; std::span&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">pretty_printer&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1filesystem_1_1path_01_4.html">pretty_printer&lt; std::filesystem::path &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1optional_3_01T_01_4_01_4.html">pretty_printer&lt; std::optional&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1vector_3_01T_01_4_01_4.html">pretty_printer&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1set_3_01T_01_4_01_4.html">pretty_printer&lt; std::set&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1map_3_01K_00_01T_01_4_01_4.html">pretty_printer&lt; std::map&lt; K, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1unordered__map_3_01K_00_01T_01_4_01_4.html">pretty_printer&lt; std::unordered_map&lt; K, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">pretty_printer&lt; std::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">pretty_printer&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1pair_3_01LH_00_01RH_01_4_01_4.html">pretty_printer&lt; std::pair&lt; LH, RH &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1chrono_1_1duration_3_01Rep_00_01Period_01_4_01_4.html">pretty_printer&lt; std::chrono::duration&lt; Rep, Period &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01std_1_1bitset_3_01N_01_4_01_4.html">pretty_printer&lt; std::bitset&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1simple__stream.html">simple_stream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01string__buffer_3_01N_01_4_01_4.html">pretty_printer&lt; string_buffer&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1generic__iterator.html">generic_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classemlabcpp_1_1generic__iterator.html" title="generic_iterator is a class using CRTP to ease implementation of custom iterators.">generic_iterator</a> is a class using CRTP to ease implementation of custom iterators.  <a href="classemlabcpp_1_1generic__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> represents all physical units defined using the International System of Units and more.  <a href="structemlabcpp_1_1physical__quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pid__coefficients"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__coefficients">pid_coefficients</a></td></tr>
<tr class="separator:structemlabcpp_1_1pid__coefficients"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pid__config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__config">pid_config</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1pid__config"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to configure the pid regulator.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1pid__config">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1pid__config"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pid.html">pid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of PID regulator, the object should be constructed and populated with pid&lt;T&gt;::conf structure with configuration values (p,i,d coeficients, min/max output vals).  <a href="structemlabcpp_1_1pid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01protocol_1_1message_3_01N_01_4_01_4.html">pretty_printer&lt; protocol::message&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01protocol_1_1sizeless__message_3_01N_01_4_01_4.html">pretty_printer&lt; protocol::sizeless_message&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01protocol_1_1mark_01_4.html">pretty_printer&lt; protocol::mark &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01protocol_1_1error__record_01_4.html">pretty_printer&lt; protocol::error_record &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing generic quantity.  <a href="classemlabcpp_1_1quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1tagged__quantity.html">tagged_quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class represents a quantity that uses <code>tags</code> to distinguish quantities instead of inheritance.  <a href="classemlabcpp_1_1tagged__quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer__iterator.html">static_circular_buffer_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing circular buffer of any type for up to N elements.  <a href="classemlabcpp_1_1static__circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classemlabcpp_1_1static__function__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a></td></tr>
<tr class="separator:classemlabcpp_1_1static__function__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__function__base_3_01ReturnType_07ArgTypes_8_8_8_08_00_01Capacity_00_01Align_01_4.html">static_function_base&lt; ReturnType(ArgTypes...), Capacity, Align &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__storage.html">static_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continuous data container that can contain N of uninitialized elements.  <a href="classemlabcpp_1_1static__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data container for up to N elements.  <a href="classemlabcpp_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pretty__printer_3_01static__vector_3_01T_00_01N_01_4_01_4.html">pretty_printer&lt; static_vector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1iterator__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1iterator__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__view.html">is_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1are__same"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a></td></tr>
<tr class="separator:structemlabcpp_1_1are__same"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_01T_00_01Ts_8_8_8_01_4.html">are_same&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_4.html">are_same&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1tuple__has__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a></td></tr>
<tr class="separator:structemlabcpp_1_1tuple__has__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tuple__has__type_3_01T_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">tuple_has_type&lt; T, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1static__size.html">static_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1signature__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1signature__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1signature__of_3_01ReturnType_07Class_1_1_5_08_07Args_8_8_8_08_01_4.html">signature_of&lt; ReturnType(Class::*)(Args...) &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1signature__of_3_01ReturnType_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">signature_of&lt; ReturnType(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4">signature_of&lt; ReturnType(Args...) &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1mapped"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a></td></tr>
<tr class="separator:structemlabcpp_1_1mapped"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1mapped_3_01Container_00_01UnaryCallable_01_4.html">mapped&lt; Container, UnaryCallable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tag.html">tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1select__utype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a></td></tr>
<tr class="separator:structemlabcpp_1_1select__utype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__map"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4">type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__tag">type_tag</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1index__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1index__of">index_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1index__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1index__of_3_01T_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">index_of&lt; T, std::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1view.html">view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class to represent view of some container.  <a href="classemlabcpp_1_1view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip_ierator iterates over a group of iterators, where value is a tuple of references to value for each iterator.  <a href="classemlabcpp_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a068a535d76f319e21113bceb0fdb8fbe"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a068a535d76f319e21113bceb0fdb8fbe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = std::array&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, 2 &gt;</td></tr>
<tr class="separator:a068a535d76f319e21113bceb0fdb8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a> = <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, 2 &gt;</td></tr>
<tr class="separator:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803520b1d525d0030e528bc67b402b53"><td class="memTemplParams" colspan="2">template&lt;typename Signature , std::size_t Capacity&gt; </td></tr>
<tr class="memitem:a803520b1d525d0030e528bc67b402b53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a803520b1d525d0030e528bc67b402b53">static_function</a> = <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a>&lt; Signature, Capacity, alignof(void *) &gt;</td></tr>
<tr class="separator:a803520b1d525d0030e528bc67b402b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td></tr>
<tr class="separator:a98ab53b012e339a9621604b203df856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf111745a0eec5119748333b9640afca"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryCallable &gt; </td></tr>
<tr class="memitem:abf111745a0eec5119748333b9640afca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abf111745a0eec5119748333b9640afca">mapped_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &gt;::type</td></tr>
<tr class="separator:abf111745a0eec5119748333b9640afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">select_utype_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;::type</td></tr>
<tr class="separator:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename &gt; class Fun&gt; </td></tr>
<tr class="memitem:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afbd4de918223b1144d32fcef8a9dfe2a">type_map_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a>&lt; T, Fun &gt;::type</td></tr>
<tr class="separator:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a151948c6a8488f45e3d7834f876be469"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a151948c6a8488f45e3d7834f876be469">unitless</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a151948c6a8488f45e3d7834f876be469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458a21111b267fd6b9727f821974f859"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a458a21111b267fd6b9727f821974f859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620d7b1d1801843cd1a7356bcc341e3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a620d7b1d1801843cd1a7356bcc341e3e">mass</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a620d7b1d1801843cd1a7356bcc341e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa23942849e26dc612a6608eb2ec02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">timeq</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a35fa23942849e26dc612a6608eb2ec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eceaa8b0d9ceb67162be01c8a803f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae2eceaa8b0d9ceb67162be01c8a803f7">current</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:ae2eceaa8b0d9ceb67162be01c8a803f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845bc83f874f1d97f649fbe0137c913c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a845bc83f874f1d97f649fbe0137c913c">temp</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a845bc83f874f1d97f649fbe0137c913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034dcea22b6c4c252c6127ffd7078a7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a034dcea22b6c4c252c6127ffd7078a7d">amount_of_substance</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a034dcea22b6c4c252c6127ffd7078a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5e1be68f8469a0ef8388b17b94406e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5c5e1be68f8469a0ef8388b17b94406e">luminous_intensity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</td></tr>
<tr class="separator:a5c5e1be68f8469a0ef8388b17b94406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa050c988b29285083320111dc7b90ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</td></tr>
<tr class="separator:afa050c988b29285083320111dc7b90ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde778df7140459ee3df4cf32bf7566e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afde778df7140459ee3df4cf32bf7566e">byte</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</td></tr>
<tr class="separator:afde778df7140459ee3df4cf32bf7566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7b213031fa424abf6cc3d1d04ac1ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">acceleration</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a9f7b213031fa424abf6cc3d1d04ac1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0893503dba0b6cfd0ebd72ceb358f20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af0893503dba0b6cfd0ebd72ceb358f20">angular_velocity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 1, 0 &gt;</td></tr>
<tr class="separator:af0893503dba0b6cfd0ebd72ceb358f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca5b22a706c436b22c929c45b773ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4eca5b22a706c436b22c929c45b773ef">area</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a4eca5b22a706c436b22c929c45b773ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f05bc39f7d9b7332f437d5a7b19156c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5f05bc39f7d9b7332f437d5a7b19156c">volume</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 3, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a5f05bc39f7d9b7332f437d5a7b19156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133bfe4782c135fcdb04c3de43fc0a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">velocity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a1133bfe4782c135fcdb04c3de43fc0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d67880c6a526098821b950d000c2d79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0d67880c6a526098821b950d000c2d79">frequency</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a0d67880c6a526098821b950d000c2d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf27b9093d0831dd17c88bcce4f9330"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aabf27b9093d0831dd17c88bcce4f9330">force</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 1, -2, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:aabf27b9093d0831dd17c88bcce4f9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf48f5a991078e6acfe3db1e7762675"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abbf48f5a991078e6acfe3db1e7762675">power</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:abbf48f5a991078e6acfe3db1e7762675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9a554fd1715665000628242b77a474"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c9a554fd1715665000628242b77a474">voltage</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -1, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a1c9a554fd1715665000628242b77a474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48e239b7c22e51004fc26dd043d32b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae48e239b7c22e51004fc26dd043d32b9">resistance</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -2, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:ae48e239b7c22e51004fc26dd043d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ac05592b4c728910966af0c89b13a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">distance</a> = <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td></tr>
<tr class="separator:a11ac05592b4c728910966af0c89b13a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96516bd702e891771257f4dc279a2f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af96516bd702e891771257f4dc279a2f2">radius</a> = <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td></tr>
<tr class="separator:af96516bd702e891771257f4dc279a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a98cc8be30884776ff941bb6ae93946fd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fd">contiguous_tree_type</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fdaecc2e9c313faddb07e7da223c1dc5c3f">VALUE</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fda8eee8e217391199668cbac89472ace53">OBJECT</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fdacb4fb1757fb37c43cded35d3eb857c43">ARRAY</a> = 3
<br />
 }</td></tr>
<tr class="separator:a98cc8be30884776ff941bb6ae93946fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815694613f8d89e804ac10b1395eeca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eeca">contiguous_container_type</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eecaacb4fb1757fb37c43cded35d3eb857c43">ARRAY</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eecaa8eee8e217391199668cbac89472ace53">OBJECT</a> = 2
<br />
 }</td></tr>
<tr class="separator:aa815694613f8d89e804ac10b1395eeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453799fa0ff8d942480b0bcc3dbf7f10"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10">contiguous_request_adapter_errors</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a7e94d60ca52c8bf6da26a0a479f08d21">MISSING_NODE</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a9bf67e4befa0dcd99caa7f01f2c9b714">WRONG_TYPE</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a3396545d99c2f2d78dd20411b4a66ad2">CHILD_MISSING</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10aba7de5bc6888294e5884b024a4c894f1">FULL</a> = 4
<br />
 }</td></tr>
<tr class="separator:a453799fa0ff8d942480b0bcc3dbf7f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d26e4c3f680aa9ba3a5469a253cca55"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4d26e4c3f680aa9ba3a5469a253cca55">log_severity</a> { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a4d26e4c3f680aa9ba3a5469a253cca55adc30ec20708ef7b0f641ef78b7880a15">DEBUG</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a4d26e4c3f680aa9ba3a5469a253cca55a551b723eafd6a31d444fcb2f5920fbd3">INFO</a> = 2
<br />
 }</td></tr>
<tr class="separator:a4d26e4c3f680aa9ba3a5469a253cca55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1aef6c41e29219cbbc8538767c0e1f0e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aef6c41e29219cbbc8538767c0e1f0e"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1aef6c41e29219cbbc8538767c0e1f0e">sign</a> (const T &amp;val)</td></tr>
<tr class="memdesc:a1aef6c41e29219cbbc8538767c0e1f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sign of variable T: -1,0,1  <a href="namespaceemlabcpp.html#a1aef6c41e29219cbbc8538767c0e1f0e">More...</a><br /></td></tr>
<tr class="separator:a1aef6c41e29219cbbc8538767c0e1f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3a3ff32c2bf0005fcdbab5763193f239">ceil_to</a> (T val, T base)</td></tr>
<tr class="memdesc:a3a3ff32c2bf0005fcdbab5763193f239"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes an value <code>val</code> and rounds it up to nearest multiply of <code>base</code>  <a href="namespaceemlabcpp.html#a3a3ff32c2bf0005fcdbab5763193f239">More...</a><br /></td></tr>
<tr class="separator:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplParams" colspan="2">template&lt;arithmetic_operators T, arithmetic_operators U&gt; </td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">map_range</a> (T input, T from_min, T from_max, U to_min, U to_max)</td></tr>
<tr class="memdesc:a0abef993d302d6b6d93fe877ca62491c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps input value 'input' from input range to equivalent value in output range  <a href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">More...</a><br /></td></tr>
<tr class="separator:a0abef993d302d6b6d93fe877ca62491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631eb361805aa7459b944503f7538951"><td class="memTemplParams" colspan="2">template&lt;container Container&gt; </td></tr>
<tr class="memitem:a631eb361805aa7459b944503f7538951"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size</a> (const Container &amp;cont) noexcept</td></tr>
<tr class="memdesc:a631eb361805aa7459b944503f7538951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the container, regardless of what it is.  <a href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">More...</a><br /></td></tr>
<tr class="separator:a631eb361805aa7459b944503f7538951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4898d31a822e25963cab32a985e89f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4898d31a822e25963cab32a985e89f4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af4898d31a822e25963cab32a985e89f4">almost_equal</a> (const T &amp;lh, const T &amp;rh, const float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="memdesc:af4898d31a822e25963cab32a985e89f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps'.  <a href="namespaceemlabcpp.html#af4898d31a822e25963cab32a985e89f4">More...</a><br /></td></tr>
<tr class="separator:af4898d31a822e25963cab32a985e89f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254ed4de50fc497ac961253ac3625040"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a254ed4de50fc497ac961253ac3625040"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a254ed4de50fc497ac961253ac3625040">tail</a> (Container &amp;&amp;cont, const int step=1)</td></tr>
<tr class="memdesc:a254ed4de50fc497ac961253ac3625040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips first item of container.  <a href="namespaceemlabcpp.html#a254ed4de50fc497ac961253ac3625040">More...</a><br /></td></tr>
<tr class="separator:a254ed4de50fc497ac961253ac3625040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b323693e8d1a33bad5c12c63709fe3b"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a4b323693e8d1a33bad5c12c63709fe3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4b323693e8d1a33bad5c12c63709fe3b">init</a> (Container &amp;&amp;cont, const int step=1)</td></tr>
<tr class="memdesc:a4b323693e8d1a33bad5c12c63709fe3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips last item of container.  <a href="namespaceemlabcpp.html#a4b323693e8d1a33bad5c12c63709fe3b">More...</a><br /></td></tr>
<tr class="separator:a4b323693e8d1a33bad5c12c63709fe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2aaee725330a629c1fa9af8cf7e37"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:adad2aaee725330a629c1fa9af8cf7e37"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if</a> (Container &amp;&amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:adad2aaee725330a629c1fa9af8cf7e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator for first item, for which call to predicate f(*iter) holds true.  <a href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">More...</a><br /></td></tr>
<tr class="separator:adad2aaee725330a629c1fa9af8cf7e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr std</td></tr>
<tr class="memdesc:aab6fd32a8b3335eec93b94331d4293b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of an element in tuple 't', for which call to predicate f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple.  <a href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">More...</a><br /></td></tr>
<tr class="separator:aab6fd32a8b3335eec93b94331d4293b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T &gt; </td></tr>
<tr class="memitem:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">find</a> (Container &amp;&amp;cont, const T &amp;item)</td></tr>
<tr class="memdesc:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds first item in container 'cont' that is equal to 'item', returns iterator for container, or index for tuples.  <a href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">More...</a><br /></td></tr>
<tr class="separator:ae6a73bbed8b818abff4ab4e7c2b9af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b36ab023620ad0de3855f2f892d400f"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T &gt; </td></tr>
<tr class="memitem:a6b36ab023620ad0de3855f2f892d400f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6b36ab023620ad0de3855f2f892d400f">contains</a> (const Container &amp;cont, const T &amp;item)</td></tr>
<tr class="memdesc:a6b36ab023620ad0de3855f2f892d400f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if container <code>cont</code> contains at least one occurence of <code>item</code>, returns true/false.  <a href="namespaceemlabcpp.html#a6b36ab023620ad0de3855f2f892d400f">More...</a><br /></td></tr>
<tr class="separator:a6b36ab023620ad0de3855f2f892d400f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr void <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a>(Container &amp;&amp;cont</td></tr>
<tr class="memdesc:a670099942b8cdd3d2cc28760b1717d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">More...</a><br /></td></tr>
<tr class="separator:a670099942b8cdd3d2cc28760b1717d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685395cc470dfed697a40d2c718af4e9"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </td></tr>
<tr class="memitem:a685395cc470dfed697a40d2c718af4e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:a685395cc470dfed697a40d2c718af4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">More...</a><br /></td></tr>
<tr class="separator:a685395cc470dfed697a40d2c718af4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516fc25d05dfa6a69f022964b2a6a807"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a516fc25d05dfa6a69f022964b2a6a807"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a516fc25d05dfa6a69f022964b2a6a807">min_max_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a516fc25d05dfa6a69f022964b2a6a807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x)' to each element of container 'cont', returns the largest and the smallest return value.  <a href="namespaceemlabcpp.html#a516fc25d05dfa6a69f022964b2a6a807">More...</a><br /></td></tr>
<tr class="separator:a516fc25d05dfa6a69f022964b2a6a807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa144487d11d6484b636482caa35a1cf1"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:aa144487d11d6484b636482caa35a1cf1"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa144487d11d6484b636482caa35a1cf1">max_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:aa144487d11d6484b636482caa35a1cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls.  <a href="namespaceemlabcpp.html#aa144487d11d6484b636482caa35a1cf1">More...</a><br /></td></tr>
<tr class="separator:aa144487d11d6484b636482caa35a1cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffd06a15a35e011691274cc98d14767"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:aaffd06a15a35e011691274cc98d14767"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaffd06a15a35e011691274cc98d14767">min_elem</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:aaffd06a15a35e011691274cc98d14767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x) to each element of container 'cont&lsquo;, returns the smallest return value of 'f(x)&rsquo; calls.  <a href="namespaceemlabcpp.html#aaffd06a15a35e011691274cc98d14767">More...</a><br /></td></tr>
<tr class="separator:aaffd06a15a35e011691274cc98d14767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1377f84042c48380be9118421fb97e6f"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:a1377f84042c48380be9118421fb97e6f"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1377f84042c48380be9118421fb97e6f">count</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a1377f84042c48380be9118421fb97e6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the predicate 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'.  <a href="namespaceemlabcpp.html#a1377f84042c48380be9118421fb97e6f">More...</a><br /></td></tr>
<tr class="separator:a1377f84042c48380be9118421fb97e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fde2ce524bee976e0c6c74c0be2917"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:ad5fde2ce524bee976e0c6c74c0be2917"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity(), T <a class="el" href="namespaceemlabcpp.html#a4b323693e8d1a33bad5c12c63709fe3b">init</a>={})</td></tr>
<tr class="memdesc:ad5fde2ce524bee976e0c6c74c0be2917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item.  <a href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">More...</a><br /></td></tr>
<tr class="separator:ad5fde2ce524bee976e0c6c74c0be2917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234414158becfed39f1b4958c694a8d9"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T , typename BinaryCallable &gt; </td></tr>
<tr class="memitem:a234414158becfed39f1b4958c694a8d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a234414158becfed39f1b4958c694a8d9">accumulate</a> (const Container &amp;cont, T <a class="el" href="namespaceemlabcpp.html#a4b323693e8d1a33bad5c12c63709fe3b">init</a>, BinaryCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:a234414158becfed39f1b4958c694a8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, returns a result of last application.  <a href="namespaceemlabcpp.html#a234414158becfed39f1b4958c694a8d9">More...</a><br /></td></tr>
<tr class="separator:a234414158becfed39f1b4958c694a8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb03fae2e4aecd67b1f163e1ab523e89"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:aeb03fae2e4aecd67b1f163e1ab523e89"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeb03fae2e4aecd67b1f163e1ab523e89">avg</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:aeb03fae2e4aecd67b1f163e1ab523e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(x)' to each element of container 'cont' and returns the average value of each call.  <a href="namespaceemlabcpp.html#aeb03fae2e4aecd67b1f163e1ab523e89">More...</a><br /></td></tr>
<tr class="separator:aeb03fae2e4aecd67b1f163e1ab523e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76870aafe8a72795ca80143c32313532"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a76870aafe8a72795ca80143c32313532"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a76870aafe8a72795ca80143c32313532">variance</a> (const Container &amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a76870aafe8a72795ca80143c32313532"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call.  <a href="namespaceemlabcpp.html#a76870aafe8a72795ca80143c32313532">More...</a><br /></td></tr>
<tr class="separator:a76870aafe8a72795ca80143c32313532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8e644a62f8747e59e7766ba811037a"><td class="memTemplParams" colspan="2">template&lt;container LhContainer, container RhContainer, typename BinaryCallable &gt; </td></tr>
<tr class="memitem:a7a8e644a62f8747e59e7766ba811037a"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7a8e644a62f8747e59e7766ba811037a">for_cross_joint</a> (const LhContainer &amp;lh_cont, const RhContainer &amp;rh_cont, BinaryCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:a7a8e644a62f8747e59e7766ba811037a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies binary callable 'f(x,y)' to each combination of items <code>x</code> from <code>lh_cont</code> and <code>y</code> from <code>rh_cont</code>  <a href="namespaceemlabcpp.html#a7a8e644a62f8747e59e7766ba811037a">More...</a><br /></td></tr>
<tr class="separator:a7a8e644a62f8747e59e7766ba811037a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d80507cffdd192a333f6bd9c272e97a"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:a2d80507cffdd192a333f6bd9c272e97a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2d80507cffdd192a333f6bd9c272e97a">any_of</a> (const Container &amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a2d80507cffdd192a333f6bd9c272e97a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns true for at least one item <code>x</code> in 'cont'.  <a href="namespaceemlabcpp.html#a2d80507cffdd192a333f6bd9c272e97a">More...</a><br /></td></tr>
<tr class="separator:a2d80507cffdd192a333f6bd9c272e97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638fe803e243841625659a697eb71463"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:a638fe803e243841625659a697eb71463"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a638fe803e243841625659a697eb71463">none_of</a> (const Container &amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a638fe803e243841625659a697eb71463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns false for all items in 'cont'.  <a href="namespaceemlabcpp.html#a638fe803e243841625659a697eb71463">More...</a><br /></td></tr>
<tr class="separator:a638fe803e243841625659a697eb71463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab724dd793953a308bea8dba2118aade"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:aab724dd793953a308bea8dba2118aade"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aab724dd793953a308bea8dba2118aade">all_of</a> (const Container &amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:aab724dd793953a308bea8dba2118aade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns true for all items in 'cont'.  <a href="namespaceemlabcpp.html#aab724dd793953a308bea8dba2118aade">More...</a><br /></td></tr>
<tr class="separator:aab724dd793953a308bea8dba2118aade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e0fe9ab6b7190faf578ec3e5f72301"><td class="memTemplParams" colspan="2">template&lt;range_container LhContainer, range_container RhContainer, typename BinaryPredicateCallable  = std::equal_to&lt; void &gt;&gt; </td></tr>
<tr class="memitem:ac1e0fe9ab6b7190faf578ec3e5f72301"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac1e0fe9ab6b7190faf578ec3e5f72301">equal</a> (const LhContainer &amp;lh, const RhContainer &amp;rh, BinaryPredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::equal_to&lt; void &gt;{})</td></tr>
<tr class="memdesc:ac1e0fe9ab6b7190faf578ec3e5f72301"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if containers 'lh' and 'rh' has same size and calls to predicate <code>f</code> - <code>f(lh[i],rh[i])</code> return true for each item.  <a href="namespaceemlabcpp.html#ac1e0fe9ab6b7190faf578ec3e5f72301">More...</a><br /></td></tr>
<tr class="separator:ac1e0fe9ab6b7190faf578ec3e5f72301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memTemplParams" colspan="2">template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memTemplItemLeft" align="right" valign="top">ResultContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae8555060e43c2b8cdd8d91bb248b9a6d">map_f</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls callable <code>f(x)</code> for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned.  <a href="namespaceemlabcpp.html#ae8555060e43c2b8cdd8d91bb248b9a6d">More...</a><br /></td></tr>
<tr class="separator:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911a0fc83869772cacfc4d21772268f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a1911a0fc83869772cacfc4d21772268f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1911a0fc83869772cacfc4d21772268f">map_f_to_a</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity()) <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>(!<a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; Container &gt;)</td></tr>
<tr class="memdesc:a1911a0fc83869772cacfc4d21772268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls callable <code>f(cont[i])</code> for i = 0...N and stores the result in array of an size N.  <a href="namespaceemlabcpp.html#a1911a0fc83869772cacfc4d21772268f">More...</a><br /></td></tr>
<tr class="separator:a1911a0fc83869772cacfc4d21772268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c1cbc5b728494acb47daebb913fd96"><td class="memTemplParams" colspan="2">template&lt;range_container Container, typename T , container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:a31c1cbc5b728494acb47daebb913fd96"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a31c1cbc5b728494acb47daebb913fd96">joined</a> (const Container &amp;cont, const T &amp;val, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity())</td></tr>
<tr class="memdesc:a31c1cbc5b728494acb47daebb913fd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applies callable <code>f</code> to each item in container <code>cont</code> and contacts results with operator+, <code>val</code> is used as a separator between the items.  <a href="namespaceemlabcpp.html#a31c1cbc5b728494acb47daebb913fd96">More...</a><br /></td></tr>
<tr class="separator:a31c1cbc5b728494acb47daebb913fd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85136552afa4d0a86dd1fb078223cdd"><td class="memTemplParams" colspan="2">template&lt;container Container, typename Iterator &gt; </td></tr>
<tr class="memitem:af85136552afa4d0a86dd1fb078223cdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af85136552afa4d0a86dd1fb078223cdd">copy</a> (const Container &amp;cont, Iterator iter)</td></tr>
<tr class="separator:af85136552afa4d0a86dd1fb078223cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a263e4623147eea2c226d8b9bcafc7"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename NullCallable &gt; </td></tr>
<tr class="memitem:a92a263e4623147eea2c226d8b9bcafc7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a92a263e4623147eea2c226d8b9bcafc7">for_each_index</a> (const NullCallable &amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:a92a263e4623147eea2c226d8b9bcafc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N.  <a href="namespaceemlabcpp.html#a92a263e4623147eea2c226d8b9bcafc7">More...</a><br /></td></tr>
<tr class="separator:a92a263e4623147eea2c226d8b9bcafc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae434316a87fef12fc4d05dd543dddf7"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename PredicateCallable &gt; </td></tr>
<tr class="memitem:aae434316a87fef12fc4d05dd543dddf7"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aae434316a87fef12fc4d05dd543dddf7">find_if_index</a> (const PredicateCallable &amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:aae434316a87fef12fc4d05dd543dddf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N until first call that returns true.  <a href="namespaceemlabcpp.html#aae434316a87fef12fc4d05dd543dddf7">More...</a><br /></td></tr>
<tr class="separator:aae434316a87fef12fc4d05dd543dddf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced106ff9e1a26187bb4872197cc1a7c"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename PredicateCallable &gt; </td></tr>
<tr class="memitem:aced106ff9e1a26187bb4872197cc1a7c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aced106ff9e1a26187bb4872197cc1a7c">until_index</a> (const PredicateCallable &amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="memdesc:aced106ff9e1a26187bb4872197cc1a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes predicate <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true.  <a href="namespaceemlabcpp.html#aced106ff9e1a26187bb4872197cc1a7c">More...</a><br /></td></tr>
<tr class="separator:aced106ff9e1a26187bb4872197cc1a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35de9105fe961a808d8e0f3a2cb58bf2">requires</a> (!requires(Callable <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}) const expr auto <a class="el" href="namespaceemlabcpp.html#a22bdba517ae1cfa5e6b4f2e54e407bb1">select_index</a>(IndexType i</td></tr>
<tr class="memdesc:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function expectes bounded value as index input and callable.  <a href="namespaceemlabcpp.html#a35de9105fe961a808d8e0f3a2cb58bf2">More...</a><br /></td></tr>
<tr class="separator:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdba517ae1cfa5e6b4f2e54e407bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a22bdba517ae1cfa5e6b4f2e54e407bb1">select_index</a> (i, [&amp;<a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, &amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>]&lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();})</td></tr>
<tr class="separator:a22bdba517ae1cfa5e6b4f2e54e407bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8d77f50ca9dd31e43365e38debbd42fa">requires</a> (Callable <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="separator:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e2e3e15b0c77fff6674ed7e6e1f67e"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab1e2e3e15b0c77fff6674ed7e6e1f67e">select_index</a> (IndexType i, const Callable &amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="separator:ab1e2e3e15b0c77fff6674ed7e6e1f67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f187ac1e10327a8c941d80b3b6b1e4"><td class="memTemplParams" colspan="2">template&lt;typename... Args, std::size_t N = sizeof...( Args )&gt; </td></tr>
<tr class="memitem:ae2f187ac1e10327a8c941d80b3b6b1e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; std::byte, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae2f187ac1e10327a8c941d80b3b6b1e4">bytes</a> (const Args &amp;... args)</td></tr>
<tr class="separator:ae2f187ac1e10327a8c941d80b3b6b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a51bc55ba3cb21b9294e89cdda68b1f98">convert_view</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator &gt; </td></tr>
<tr class="memitem:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8a7d1590aa2cb61d0e710f02fea01474">convert_view_n</a> (Iterator begin, std::size_t n)</td></tr>
<tr class="separator:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1either.html">either</a>&lt; std::tuple&lt; Ts... &gt;, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">assemble_optionals</a> (std::optional&lt; Ts &gt; &amp;&amp;... opt)</td></tr>
<tr class="memdesc:ac30a98c58cf8a76fa9363a0d19c09486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function gets a set of various std::optionals and either returns all their values assembled as tuple or '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag" title="Marks empty assembly.">empty_assembly_tag</a>' implicating that some of the optionals was empty.  <a href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">More...</a><br /></td></tr>
<tr class="separator:ac30a98c58cf8a76fa9363a0d19c09486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306d3a03f11c2e95874c23956020a755"><td class="memTemplParams" colspan="2">template&lt;typename FirstE , typename... Eithers&gt; </td></tr>
<tr class="memitem:a306d3a03f11c2e95874c23956020a755"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a306d3a03f11c2e95874c23956020a755">assemble_left_collect_right</a> (FirstE &amp;&amp;first, Eithers &amp;&amp;... others) <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>(std</td></tr>
<tr class="memdesc:a306d3a03f11c2e95874c23956020a755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function expects eithers of any left type, but same right type.  <a href="namespaceemlabcpp.html#a306d3a03f11c2e95874c23956020a755">More...</a><br /></td></tr>
<tr class="separator:a306d3a03f11c2e95874c23956020a755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bdb9e4992c495c755d900b23435840"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a39bdb9e4992c495c755d900b23435840"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a39bdb9e4992c495c755d900b23435840">requires</a> (std::is_enum_v&lt; Enum &gt;) auto convert_enum(Enum val)</td></tr>
<tr class="memdesc:a39bdb9e4992c495c755d900b23435840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string-like name of the enum value <code>val</code>  <a href="namespaceemlabcpp.html#a39bdb9e4992c495c755d900b23435840">More...</a><br /></td></tr>
<tr class="separator:a39bdb9e4992c495c755d900b23435840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66eda67f0ba6fe671bc52b639616ef97"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a66eda67f0ba6fe671bc52b639616ef97">encode_cobs</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; source, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; target)</td></tr>
<tr class="memdesc:a66eda67f0ba6fe671bc52b639616ef97"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: make this no inline.  <a href="namespaceemlabcpp.html#a66eda67f0ba6fe671bc52b639616ef97">More...</a><br /></td></tr>
<tr class="separator:a66eda67f0ba6fe671bc52b639616ef97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287862121b428bfa9cc668e1f774e2d5"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a287862121b428bfa9cc668e1f774e2d5">decode_cobs</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; source, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; target)</td></tr>
<tr class="memdesc:a287862121b428bfa9cc668e1f774e2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer.  <a href="namespaceemlabcpp.html#a287862121b428bfa9cc668e1f774e2d5">More...</a><br /></td></tr>
<tr class="separator:a287862121b428bfa9cc668e1f774e2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb69734e95cc40cd53e2f01531183d7"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a1eb69734e95cc40cd53e2f01531183d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt;, <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1eb69734e95cc40cd53e2f01531183d7">cobs_decode_view</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt; data)</td></tr>
<tr class="separator:a1eb69734e95cc40cd53e2f01531183d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecb966a998ea6497e7b378bca2681c8"><td class="memTemplParams" colspan="2">template&lt;decomposable_0 T&gt; </td></tr>
<tr class="memitem:afecb966a998ea6497e7b378bca2681c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afecb966a998ea6497e7b378bca2681c8">decompose</a> (T &amp;&amp;)</td></tr>
<tr class="separator:afecb966a998ea6497e7b378bca2681c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5e72f5ad9fec2b8f70d4f8e0e5ec0d23">compose</a> (Tuple tpl)</td></tr>
<tr class="separator:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab124463ea669779e32ea4428088a01c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab124463ea669779e32ea4428088a01c4">EMLABCPP_GENERATE_DECOMPOSE</a> (16, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) template&lt; typename T &gt; using decomposed_type</td></tr>
<tr class="separator:ab124463ea669779e32ea4428088a01c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51181e92ac66d2a113b7c0e5b9a2718e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a51181e92ac66d2a113b7c0e5b9a2718e"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a51181e92ac66d2a113b7c0e5b9a2718e">distance_of</a> (const <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; N &gt; &amp;l, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;p)</td></tr>
<tr class="separator:a51181e92ac66d2a113b7c0e5b9a2718e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fabc0e3695f7218ab026b253d56ea6e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0fabc0e3695f7218ab026b253d56ea6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0fabc0e3695f7218ab026b253d56ea6e">distance_of</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;p, const <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; N &gt; &amp;<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>)</td></tr>
<tr class="separator:a0fabc0e3695f7218ab026b253d56ea6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1806b61b0659c26b8a0a53288ecfa313"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a1806b61b0659c26b8a0a53288ecfa313"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1806b61b0659c26b8a0a53288ecfa313">point_cast</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;v)</td></tr>
<tr class="separator:a1806b61b0659c26b8a0a53288ecfa313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa63f3a0229b43ff56952dbb4e191f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a3cfa63f3a0229b43ff56952dbb4e191f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;p)</td></tr>
<tr class="separator:a3cfa63f3a0229b43ff56952dbb4e191f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fe2550fd1fae3aab0b4791d8e58efa"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a63fe2550fd1fae3aab0b4791d8e58efa"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a63fe2550fd1fae3aab0b4791d8e58efa">operator*</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; a, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="memdesc:a63fe2550fd1fae3aab0b4791d8e58efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of points multiplies each coordinate of A by coordinate of B on same dimension.  <a href="namespaceemlabcpp.html#a63fe2550fd1fae3aab0b4791d8e58efa">More...</a><br /></td></tr>
<tr class="separator:a63fe2550fd1fae3aab0b4791d8e58efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d491045b619755db02e72cfa69e772"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a65d491045b619755db02e72cfa69e772"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a65d491045b619755db02e72cfa69e772">operator-</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; a, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="memdesc:a65d491045b619755db02e72cfa69e772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of subtraction of A from B, viz -= operator.  <a href="namespaceemlabcpp.html#a65d491045b619755db02e72cfa69e772">More...</a><br /></td></tr>
<tr class="separator:a65d491045b619755db02e72cfa69e772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57aae6e5cd5a893e35a12622960dc79b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a57aae6e5cd5a893e35a12622960dc79b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57aae6e5cd5a893e35a12622960dc79b">operator+</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; a, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="memdesc:a57aae6e5cd5a893e35a12622960dc79b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of addition a to b, viz += operator.  <a href="namespaceemlabcpp.html#a57aae6e5cd5a893e35a12622960dc79b">More...</a><br /></td></tr>
<tr class="separator:a57aae6e5cd5a893e35a12622960dc79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cf7c57e3d0c20cf08c0f4562e32fe9"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a57cf7c57e3d0c20cf08c0f4562e32fe9"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57cf7c57e3d0c20cf08c0f4562e32fe9">operator-</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; a, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="memdesc:a57cf7c57e3d0c20cf08c0f4562e32fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of subtraction a to b, viz += operator.  <a href="namespaceemlabcpp.html#a57cf7c57e3d0c20cf08c0f4562e32fe9">More...</a><br /></td></tr>
<tr class="separator:a57cf7c57e3d0c20cf08c0f4562e32fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9977373a20edbc718c415668d82b0893"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a9977373a20edbc718c415668d82b0893"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9977373a20edbc718c415668d82b0893">distance_of</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="memdesc:a9977373a20edbc718c415668d82b0893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns euclidian distance of point A from point B.  <a href="namespaceemlabcpp.html#a9977373a20edbc718c415668d82b0893">More...</a><br /></td></tr>
<tr class="separator:a9977373a20edbc718c415668d82b0893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0c8873bbc692d1700c0f3a5603d620"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a7b0c8873bbc692d1700c0f3a5603d620"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7b0c8873bbc692d1700c0f3a5603d620">point_angle</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="separator:a7b0c8873bbc692d1700c0f3a5603d620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e570f89d7f0975b1cff5b2ec8cd7e3"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a26e570f89d7f0975b1cff5b2ec8cd7e3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a26e570f89d7f0975b1cff5b2ec8cd7e3">lineary_interpolate_path</a> (const std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &gt; &amp;ipath, float d_step)</td></tr>
<tr class="separator:a26e570f89d7f0975b1cff5b2ec8cd7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a3b65521b77f85095c0130ef945fe"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aaf2a3b65521b77f85095c0130ef945fe"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaf2a3b65521b77f85095c0130ef945fe">axis_projection_distance</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;axis_direction)</td></tr>
<tr class="memdesc:aaf2a3b65521b77f85095c0130ef945fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate distance of projection of point A.  <a href="namespaceemlabcpp.html#aaf2a3b65521b77f85095c0130ef945fe">More...</a><br /></td></tr>
<tr class="separator:aaf2a3b65521b77f85095c0130ef945fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">steps</a> (<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a> dist, float dist_step, float angle_step)</td></tr>
<tr class="memdesc:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns steps necessary for linear interpolation of distance between poses 'dis', such that:  <a href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">More...</a><br /></td></tr>
<tr class="separator:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b460db38cf4162f2102f01e6f42616c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0b460db38cf4162f2102f01e6f42616c">operator&lt;</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;y)</td></tr>
<tr class="separator:a0b460db38cf4162f2102f01e6f42616c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae905e83f27246077252ae1308f0fda07"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae905e83f27246077252ae1308f0fda07">operator==</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;y)</td></tr>
<tr class="memdesc:ae905e83f27246077252ae1308f0fda07"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares poses on their position and orientation  <a href="namespaceemlabcpp.html#ae905e83f27246077252ae1308f0fda07">More...</a><br /></td></tr>
<tr class="separator:ae905e83f27246077252ae1308f0fda07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f2745b15d83802490aa46fc8e25102"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a45f2745b15d83802490aa46fc8e25102">operator!=</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;y)</td></tr>
<tr class="memdesc:a45f2745b15d83802490aa46fc8e25102"><td class="mdescLeft">&#160;</td><td class="mdescRight">negation of operator== between poses  <a href="namespaceemlabcpp.html#a45f2745b15d83802490aa46fc8e25102">More...</a><br /></td></tr>
<tr class="separator:a45f2745b15d83802490aa46fc8e25102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081ada5ee8e130abc77d8471f570661"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac081ada5ee8e130abc77d8471f570661">distance_of</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;y)</td></tr>
<tr class="memdesc:ac081ada5ee8e130abc77d8471f570661"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns PoseDistance between provided poses  <a href="namespaceemlabcpp.html#ac081ada5ee8e130abc77d8471f570661">More...</a><br /></td></tr>
<tr class="separator:ac081ada5ee8e130abc77d8471f570661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130ed4c792c2efaf92b76eb607a433c3"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a130ed4c792c2efaf92b76eb607a433c3">almost_equal</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;y, float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="memdesc:a130ed4c792c2efaf92b76eb607a433c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">two poses are almost equal when their orientations and positions are almost equal  <a href="namespaceemlabcpp.html#a130ed4c792c2efaf92b76eb607a433c3">More...</a><br /></td></tr>
<tr class="separator:a130ed4c792c2efaf92b76eb607a433c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe90ef4b53557e6198f75e4e3f0e86f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1fe90ef4b53557e6198f75e4e3f0e86f">lin_interp</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;from, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;goal, float factor)</td></tr>
<tr class="memdesc:a1fe90ef4b53557e6198f75e4e3f0e86f"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation between base se and goal pose, with factor 0 'base' is returned, with factor 1 'goal' is returned.  <a href="namespaceemlabcpp.html#a1fe90ef4b53557e6198f75e4e3f0e86f">More...</a><br /></td></tr>
<tr class="separator:a1fe90ef4b53557e6198f75e4e3f0e86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ddb76ca74c38e8582a5fa4180da7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa68ddb76ca74c38e8582a5fa4180da7b">lineary_interpolate_path</a> (const std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; &amp;ipath, float d_step, float a_step)</td></tr>
<tr class="separator:aa68ddb76ca74c38e8582a5fa4180da7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc504832a0c2ee50c85b216971c170a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">transform</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;a, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="memdesc:a0cc504832a0c2ee50c85b216971c170a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point A is rotated based on 'transformation' orientation and than moved based on 'transformation' position.  <a href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">More...</a><br /></td></tr>
<tr class="separator:a0cc504832a0c2ee50c85b216971c170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61331372de6b7c1f226a19df31b820bc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a61331372de6b7c1f226a19df31b820bc">transform</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;v, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="separator:a61331372de6b7c1f226a19df31b820bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6416b91bd33ea2a47540c131ba789fe"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae6416b91bd33ea2a47540c131ba789fe">transform</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="memdesc:ae6416b91bd33ea2a47540c131ba789fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose X is rotated based on 'transformation' orientation and than moved based on 'transformation' position.  <a href="namespaceemlabcpp.html#ae6416b91bd33ea2a47540c131ba789fe">More...</a><br /></td></tr>
<tr class="separator:ae6416b91bd33ea2a47540c131ba789fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdc7d913ad6f5537d3c78d1fe0518dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fdc7d913ad6f5537d3c78d1fe0518dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0fdc7d913ad6f5537d3c78d1fe0518dd">transform</a> (const <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; &amp;mm, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="separator:a0fdc7d913ad6f5537d3c78d1fe0518dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116807f9c41ac80621918fff7446c987"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a116807f9c41ac80621918fff7446c987">inverse</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x)</td></tr>
<tr class="separator:a116807f9c41ac80621918fff7446c987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b509189c2527a5023267e866b85d68"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9b509189c2527a5023267e866b85d68"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae9b509189c2527a5023267e866b85d68">inverse_transform</a> (const T &amp;item, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="separator:ae9b509189c2527a5023267e866b85d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ac88872a7d3a671951eba53e721de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a585ac88872a7d3a671951eba53e721de">rotate</a> (const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;x, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;quat)</td></tr>
<tr class="memdesc:a585ac88872a7d3a671951eba53e721de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose X is rotated based on quaternion 'quad'.  <a href="namespaceemlabcpp.html#a585ac88872a7d3a671951eba53e721de">More...</a><br /></td></tr>
<tr class="separator:a585ac88872a7d3a671951eba53e721de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9f2c9f70372883377a906c4ee7c8dc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4d9f2c9f70372883377a906c4ee7c8dc">inverse</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:a4d9f2c9f70372883377a906c4ee7c8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c4e6187b766c3b0fcfb4721228f5d9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa3c4e6187b766c3b0fcfb4721228f5d9">operator-</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:aa3c4e6187b766c3b0fcfb4721228f5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3cab8faa406c3fc0e6c197d7663f12"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s)</td></tr>
<tr class="separator:a8e3cab8faa406c3fc0e6c197d7663f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fc2eeaf683b868d3ec7eed8fe6f69a"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af6fc2eeaf683b868d3ec7eed8fe6f69a">norm2_of</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:af6fc2eeaf683b868d3ec7eed8fe6f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86203b42f9478701d1f52443d5729a3"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa86203b42f9478701d1f52443d5729a3">angle_shortest_path</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;m, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;n)</td></tr>
<tr class="separator:aa86203b42f9478701d1f52443d5729a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2a793ecef21878567a88585e7f7b6b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeb2a793ecef21878567a88585e7f7b6b">slerp</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s, float <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>)</td></tr>
<tr class="separator:aeb2a793ecef21878567a88585e7f7b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027de18cdf34aaf5bf22b05130b6c208"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a027de18cdf34aaf5bf22b05130b6c208">operator==</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s)</td></tr>
<tr class="separator:a027de18cdf34aaf5bf22b05130b6c208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a114fd45fa6f5d2994e375e6863c00c"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5a114fd45fa6f5d2994e375e6863c00c">operator!=</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s)</td></tr>
<tr class="separator:a5a114fd45fa6f5d2994e375e6863c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3969b7ad5f8da7ae8d8c01fd2a0909f6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3969b7ad5f8da7ae8d8c01fd2a0909f6">operator&lt;</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s)</td></tr>
<tr class="separator:a3969b7ad5f8da7ae8d8c01fd2a0909f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddf667e5164035a1b42febb28df6dda"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7ddf667e5164035a1b42febb28df6dda">operator*</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s)</td></tr>
<tr class="separator:a7ddf667e5164035a1b42febb28df6dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82c713fbe2af2876043efec81216254"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa82c713fbe2af2876043efec81216254">operator*</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;x)</td></tr>
<tr class="separator:aa82c713fbe2af2876043efec81216254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecbf2e7b498f7c5d2eb3985f198547f"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abecbf2e7b498f7c5d2eb3985f198547f">operator*</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;x, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:abecbf2e7b498f7c5d2eb3985f198547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853e4e996373808d81cd415c60aecd55"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a853e4e996373808d81cd415c60aecd55">operator+</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;lh, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;rh)</td></tr>
<tr class="separator:a853e4e996373808d81cd415c60aecd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d682324e6ca417852d4bcaecb77db23"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0d682324e6ca417852d4bcaecb77db23">almost_equal</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;s, float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="separator:a0d682324e6ca417852d4bcaecb77db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502c46ab09d85973cfcaaf05be835ac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af502c46ab09d85973cfcaaf05be835ac">shortest_arc_quat</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; x, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; y)</td></tr>
<tr class="separator:af502c46ab09d85973cfcaaf05be835ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f930afac742df6f8f0ace5d9c220508"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8f930afac742df6f8f0ace5d9c220508">rotate</a> (const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;x, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:a8f930afac742df6f8f0ace5d9c220508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9602763edb5f01eed83307c5c63ad73"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af9602763edb5f01eed83307c5c63ad73">rotate</a> (const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;x, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:af9602763edb5f01eed83307c5c63ad73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94e0bd03b2708f3260f665730929fb1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae94e0bd03b2708f3260f665730929fb1">rotate</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;v, const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;q)</td></tr>
<tr class="separator:ae94e0bd03b2708f3260f665730929fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c868b270298a6e752372a1809dc03d0"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, std::size_t U&gt; </td></tr>
<tr class="memitem:a8c868b270298a6e752372a1809dc03d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8c868b270298a6e752372a1809dc03d0">center_of</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, U &gt; &amp;s)</td></tr>
<tr class="separator:a8c868b270298a6e752372a1809dc03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6189ac849a51ae66a922cd84c9af8254"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a6189ac849a51ae66a922cd84c9af8254"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6189ac849a51ae66a922cd84c9af8254">volume_of</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, N &gt; &amp;<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>)</td></tr>
<tr class="separator:a6189ac849a51ae66a922cd84c9af8254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37668b1023850f199c917bcf2131523c"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a37668b1023850f199c917bcf2131523c"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37668b1023850f199c917bcf2131523c">operator&lt;</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:a37668b1023850f199c917bcf2131523c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78453f63bffe0ddbe927529c68875dc4"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a78453f63bffe0ddbe927529c68875dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a78453f63bffe0ddbe927529c68875dc4">operator&gt;</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:a78453f63bffe0ddbe927529c68875dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2749663d773cccf70a46c26fafb132"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:add2749663d773cccf70a46c26fafb132"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#add2749663d773cccf70a46c26fafb132">operator&lt;=</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:add2749663d773cccf70a46c26fafb132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8345b253a90bb775245754b4e6307216"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a8345b253a90bb775245754b4e6307216"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8345b253a90bb775245754b4e6307216">operator&gt;=</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:a8345b253a90bb775245754b4e6307216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32193fca8f431c8887d0a5402866074"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:aa32193fca8f431c8887d0a5402866074"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa32193fca8f431c8887d0a5402866074">operator==</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:aa32193fca8f431c8887d0a5402866074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a44460972cfa981d6af54caba9f8b2"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:ac7a44460972cfa981d6af54caba9f8b2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac7a44460972cfa981d6af54caba9f8b2">operator!=</a> (const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;rh)</td></tr>
<tr class="separator:ac7a44460972cfa981d6af54caba9f8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070cde263f31325ae8cece3af6e7d23a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a070cde263f31325ae8cece3af6e7d23a">get_triangle_sphere_center</a> (const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="separator:a070cde263f31325ae8cece3af6e7d23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42832216d185dc06feea7414a0318c7"><td class="memItemLeft" align="right" valign="top">constexpr vec&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac42832216d185dc06feea7414a0318c7">normal_of</a> (const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;tri)</td></tr>
<tr class="separator:ac42832216d185dc06feea7414a0318c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a080e14602b2565d26cb92bff4c637ad5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a080e14602b2565d26cb92bff4c637ad5">transform</a> (const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;t, const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;transformation)</td></tr>
<tr class="separator:a080e14602b2565d26cb92bff4c637ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcc7c52513935a9585f1b633244cd4c"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:abdcc7c52513935a9585f1b633244cd4c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abdcc7c52513935a9585f1b633244cd4c">scale</a> (const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; N &gt; &amp;t, const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;scales)</td></tr>
<tr class="separator:abdcc7c52513935a9585f1b633244cd4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaf966cca60b8622ed6758c976a4a69"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </td></tr>
<tr class="memitem:a6aaf966cca60b8622ed6758c976a4a69"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6aaf966cca60b8622ed6758c976a4a69">operator*</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, T s)</td></tr>
<tr class="memdesc:a6aaf966cca60b8622ed6758c976a4a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#a6aaf966cca60b8622ed6758c976a4a69">More...</a><br /></td></tr>
<tr class="separator:a6aaf966cca60b8622ed6758c976a4a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c6dcc7bdeae73e7695e529b2a542c9"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:aa2c6dcc7bdeae73e7695e529b2a542c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa2c6dcc7bdeae73e7695e529b2a542c9">operator*</a> (T s, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aa2c6dcc7bdeae73e7695e529b2a542c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#aa2c6dcc7bdeae73e7695e529b2a542c9">More...</a><br /></td></tr>
<tr class="separator:aa2c6dcc7bdeae73e7695e529b2a542c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bf364734336953acece2da91f7cd5a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </td></tr>
<tr class="memitem:ad8bf364734336953acece2da91f7cd5a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad8bf364734336953acece2da91f7cd5a">operator/</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, T s)</td></tr>
<tr class="memdesc:ad8bf364734336953acece2da91f7cd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#ad8bf364734336953acece2da91f7cd5a">More...</a><br /></td></tr>
<tr class="separator:ad8bf364734336953acece2da91f7cd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7721009a36753730f1afa6be47dbf28b"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a7721009a36753730f1afa6be47dbf28b"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7721009a36753730f1afa6be47dbf28b">dot</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;b)</td></tr>
<tr class="memdesc:a7721009a36753730f1afa6be47dbf28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between A and B.  <a href="namespaceemlabcpp.html#a7721009a36753730f1afa6be47dbf28b">More...</a><br /></td></tr>
<tr class="separator:a7721009a36753730f1afa6be47dbf28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01057565d5ebaf62d92c2a45cfdde65b"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a01057565d5ebaf62d92c2a45cfdde65b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a01057565d5ebaf62d92c2a45cfdde65b">length2_of</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a01057565d5ebaf62d92c2a45cfdde65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared distance of A from [0,0,0], this is a squared length of vector represented by A.  <a href="namespaceemlabcpp.html#a01057565d5ebaf62d92c2a45cfdde65b">More...</a><br /></td></tr>
<tr class="separator:a01057565d5ebaf62d92c2a45cfdde65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea33175760f7e4286188490bacd98ac3"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:aea33175760f7e4286188490bacd98ac3"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aea33175760f7e4286188490bacd98ac3">length_of</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aea33175760f7e4286188490bacd98ac3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distance of A from [0,0,0], this is a length of vector represented by A.  <a href="namespaceemlabcpp.html#aea33175760f7e4286188490bacd98ac3">More...</a><br /></td></tr>
<tr class="separator:aea33175760f7e4286188490bacd98ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2416235ee550b6758f4e804d71d612"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:aab2416235ee550b6758f4e804d71d612"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aab2416235ee550b6758f4e804d71d612">normalized</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a)</td></tr>
<tr class="memdesc:aab2416235ee550b6758f4e804d71d612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates normalized version of A, this means that length(A) equals to 1.  <a href="namespaceemlabcpp.html#aab2416235ee550b6758f4e804d71d612">More...</a><br /></td></tr>
<tr class="separator:aab2416235ee550b6758f4e804d71d612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306420110ac2a2a1ecc364e0053c1e30"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a306420110ac2a2a1ecc364e0053c1e30"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a306420110ac2a2a1ecc364e0053c1e30">abs</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a306420110ac2a2a1ecc364e0053c1e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates absolute version of A - removing signs on all dimensions.  <a href="namespaceemlabcpp.html#a306420110ac2a2a1ecc364e0053c1e30">More...</a><br /></td></tr>
<tr class="separator:a306420110ac2a2a1ecc364e0053c1e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30565e3c9f95b08ee5cd25294bc375d7"><td class="memTemplParams" colspan="2">template&lt;vec_point_derived Derived&gt; </td></tr>
<tr class="memitem:a30565e3c9f95b08ee5cd25294bc375d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a30565e3c9f95b08ee5cd25294bc375d7">almost_equal</a> (const Derived &amp;a, const Derived &amp;b, float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="memdesc:a30565e3c9f95b08ee5cd25294bc375d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if A and B are equal within specified tolerance, this means that difference of all coordinates of A and B has to be within that epsilon.  <a href="namespaceemlabcpp.html#a30565e3c9f95b08ee5cd25294bc375d7">More...</a><br /></td></tr>
<tr class="separator:a30565e3c9f95b08ee5cd25294bc375d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c784ba1275978f98555df83478109c8"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a8c784ba1275978f98555df83478109c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;b)</td></tr>
<tr class="separator:a8c784ba1275978f98555df83478109c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5098342c4801b4a7d9ec75b1143f7801"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a5098342c4801b4a7d9ec75b1143f7801"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Derived &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5098342c4801b4a7d9ec75b1143f7801">min</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;b)</td></tr>
<tr class="separator:a5098342c4801b4a7d9ec75b1143f7801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81ee08c08bd405c0e3def37de64f126"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:ac81ee08c08bd405c0e3def37de64f126"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac81ee08c08bd405c0e3def37de64f126">dimensional_max</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;b)</td></tr>
<tr class="memdesc:ac81ee08c08bd405c0e3def37de64f126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a C, where C[i] = max(A[i], B[i]) holds for 0 &lt;= i &lt; N.  <a href="namespaceemlabcpp.html#ac81ee08c08bd405c0e3def37de64f126">More...</a><br /></td></tr>
<tr class="separator:ac81ee08c08bd405c0e3def37de64f126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9345d163bdab63d39dec5d99354c81"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a5d9345d163bdab63d39dec5d99354c81"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5d9345d163bdab63d39dec5d99354c81">dimensional_min</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;b)</td></tr>
<tr class="memdesc:a5d9345d163bdab63d39dec5d99354c81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a C, where C[i] = min(A[i], B[i]) holds for 0 &lt;= i &lt; N.  <a href="namespaceemlabcpp.html#a5d9345d163bdab63d39dec5d99354c81">More...</a><br /></td></tr>
<tr class="separator:a5d9345d163bdab63d39dec5d99354c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85dd86813ed16ef311a88daac50792d"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction  = std::identity, typename Derived  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:aa85dd86813ed16ef311a88daac50792d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa85dd86813ed16ef311a88daac50792d">dimensional_min_max_elem</a> (const Container &amp;cont, UnaryFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>=std::identity{})</td></tr>
<tr class="separator:aa85dd86813ed16ef311a88daac50792d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526b633aba78654db2ac46377bd5b2da"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a526b633aba78654db2ac46377bd5b2da"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a526b633aba78654db2ac46377bd5b2da">lin_interp</a> (const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;from, const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;goal, float factor)</td></tr>
<tr class="separator:a526b633aba78654db2ac46377bd5b2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebffc4f0df356683a2b9b2a595e90e40"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aebffc4f0df356683a2b9b2a595e90e40"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aebffc4f0df356683a2b9b2a595e90e40">operator+</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; lh, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;rh)</td></tr>
<tr class="separator:aebffc4f0df356683a2b9b2a595e90e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc03fbfa97fbe6458f075c4be65ce33"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aefc03fbfa97fbe6458f075c4be65ce33">cross_product</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;b)</td></tr>
<tr class="memdesc:aefc03fbfa97fbe6458f075c4be65ce33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cross product between points A and B.  <a href="namespaceemlabcpp.html#aefc03fbfa97fbe6458f075c4be65ce33">More...</a><br /></td></tr>
<tr class="separator:aefc03fbfa97fbe6458f075c4be65ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac699c992dfb572a61d18dde2a4c302a8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac699c992dfb572a61d18dde2a4c302a8">normal_of</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; &amp;a)</td></tr>
<tr class="memdesc:ac699c992dfb572a61d18dde2a4c302a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a normal to a point A in two dimensions.  <a href="namespaceemlabcpp.html#ac699c992dfb572a61d18dde2a4c302a8">More...</a><br /></td></tr>
<tr class="separator:ac699c992dfb572a61d18dde2a4c302a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1646f426f259ab7e7f8d4ebbb1f5a4f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:af1646f426f259ab7e7f8d4ebbb1f5a4f"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af1646f426f259ab7e7f8d4ebbb1f5a4f">vector_angle</a> (const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;a, const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;b)</td></tr>
<tr class="separator:af1646f426f259ab7e7f8d4ebbb1f5a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620a32406486ae5b889d41d446c4a8b0"><td class="memItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a620a32406486ae5b889d41d446c4a8b0">reset_color</a> ()</td></tr>
<tr class="separator:a620a32406486ae5b889d41d446c4a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c59e260f99791d626a9665243323d0"><td class="memItemLeft" align="right" valign="top">consteval std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a69c59e260f99791d626a9665243323d0">stem_of</a> (const std::string_view file)</td></tr>
<tr class="separator:a69c59e260f99791d626a9665243323d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512f1fd6d6a6aa3d5094088865158e23"><td class="memTemplParams" colspan="2">template&lt;matrix_like LH, matrix_like RH&gt; </td></tr>
<tr class="memitem:a512f1fd6d6a6aa3d5094088865158e23"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a512f1fd6d6a6aa3d5094088865158e23">requires</a> (LH::rows==RH::rows &amp;&amp;LH::cols==RH::cols) const expr auto operator</td></tr>
<tr class="separator:a512f1fd6d6a6aa3d5094088865158e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ee7e0f160b1450636b4a460f27e18a"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:ac4ee7e0f160b1450636b4a460f27e18a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac4ee7e0f160b1450636b4a460f27e18a">requires</a> (M::rows==2 &amp;&amp;M::cols==2) const expr auto determinant(const M &amp;m)</td></tr>
<tr class="separator:ac4ee7e0f160b1450636b4a460f27e18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82d48e74c20cfcb88f46dd2ba5688b9"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:af82d48e74c20cfcb88f46dd2ba5688b9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af82d48e74c20cfcb88f46dd2ba5688b9">requires</a> (M::rows &gt; 2 &amp;&amp;M::cols==M::rows) const expr auto determinant(const M &amp;m)</td></tr>
<tr class="separator:af82d48e74c20cfcb88f46dd2ba5688b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9679354218890ed9c289c674a125378"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:ae9679354218890ed9c289c674a125378"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">requires</a> (M::rows==1 &amp;&amp;M::cols==1) const expr <a class="el" href="classemlabcpp_1_1matrix.html">matrix</a>&lt; M</td></tr>
<tr class="separator:ae9679354218890ed9c289c674a125378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea91805d160a2eda9dfc9f0f29477351"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Writer , typename T &gt; </td></tr>
<tr class="memitem:aea91805d160a2eda9dfc9f0f29477351"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aea91805d160a2eda9dfc9f0f29477351">pretty_print_serialize_basic</a> (Writer &amp;&amp;w, const T &amp;val)</td></tr>
<tr class="separator:aea91805d160a2eda9dfc9f0f29477351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb43f873b880adf7247a54e0d0b4a03"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:afcb43f873b880adf7247a54e0d0b4a03"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afcb43f873b880adf7247a54e0d0b4a03">pretty_stream_write</a> (<a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;os, const Ts &amp;... item)</td></tr>
<tr class="separator:afcb43f873b880adf7247a54e0d0b4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf06ccbfbc6633b4244c7295fdc98cf"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename... Ts&gt; </td></tr>
<tr class="memitem:a8bf06ccbfbc6633b4244c7295fdc98cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structemlabcpp_1_1buffer__writer.html">buffer_writer</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8bf06ccbfbc6633b4244c7295fdc98cf">pretty_print_buffer</a> (const Ts &amp;... item)</td></tr>
<tr class="separator:a8bf06ccbfbc6633b4244c7295fdc98cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a54421dadf3639047daa6aab4fc470"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a53a54421dadf3639047daa6aab4fc470"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a53a54421dadf3639047daa6aab4fc470">requires</a> (std::is_pointer_v&lt; T &gt;) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pretty__printer">pretty_printer</a>&lt; T &gt;</td></tr>
<tr class="separator:a53a54421dadf3639047daa6aab4fc470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed05683098f9a93c5b694ff9b9f3c16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abed05683098f9a93c5b694ff9b9f3c16"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abed05683098f9a93c5b694ff9b9f3c16">requires</a> (std::is_enum_v&lt; T &gt;) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pretty__printer">pretty_printer</a>&lt; T &gt;</td></tr>
<tr class="separator:abed05683098f9a93c5b694ff9b9f3c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add7921925c77c6350a91d55d9471bdc1"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:add7921925c77c6350a91d55d9471bdc1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#add7921925c77c6350a91d55d9471bdc1">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a>&lt; N &gt; &amp;sb)</td></tr>
<tr class="separator:add7921925c77c6350a91d55d9471bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplParams" colspan="2">template&lt;typename... Callables&gt; </td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab077da8cbabe4cc68820537ddc602b91">matcher</a> (Callables &amp;&amp;...) -&gt; <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td></tr>
<tr class="separator:ab077da8cbabe4cc68820537ddc602b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a63a6aaa5fc338d3d342d90a14225fe82">apply_on_match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">operator*</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a384e4bb5a921ff231358ff63aeecbe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together.  <a href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">More...</a><br /></td></tr>
<tr class="separator:a384e4bb5a921ff231358ff63aeecbe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">operator/</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted.  <a href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">More...</a><br /></td></tr>
<tr class="separator:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplParams" colspan="2">template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a5519896c5f0324265089711b6a020642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of physical quantity is square root of it's value and the exponents are divided in half.  <a href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">More...</a><br /></td></tr>
<tr class="separator:a5519896c5f0324265089711b6a020642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplParams" colspan="2">template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a9b9eb800885b61e8071ef11e69debdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power of physical quantity is power of root of it's value and the exponents are multiplied by the value.  <a href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">More...</a><br /></td></tr>
<tr class="separator:a9b9eb800885b61e8071ef11e69debdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc080f9334a6fec6101a6d803f7cb28"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aadc080f9334a6fec6101a6d803f7cb28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aadc080f9334a6fec6101a6d803f7cb28">update_limits</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt; lim)</td></tr>
<tr class="separator:aadc080f9334a6fec6101a6d803f7cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578d4bcbce0973184093fa8cce2da33"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:ac578d4bcbce0973184093fa8cce2da33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac578d4bcbce0973184093fa8cce2da33">update_output</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, float output)</td></tr>
<tr class="separator:ac578d4bcbce0973184093fa8cce2da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7bb8b8ced9bb2a501cc61ced29e7801d">update</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, TimeType now, float measured, float desired)</td></tr>
<tr class="memdesc:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this reularly, the meaning of time value 'now' is up to you, just be consistent.  <a href="namespaceemlabcpp.html#a7bb8b8ced9bb2a501cc61ced29e7801d">More...</a><br /></td></tr>
<tr class="separator:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37fb61edcdf95a5c2fc63e29d2431946">operator+</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="memdesc:a37fb61edcdf95a5c2fc63e29d2431946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#a37fb61edcdf95a5c2fc63e29d2431946">More...</a><br /></td></tr>
<tr class="separator:a37fb61edcdf95a5c2fc63e29d2431946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec5f53bd49815db80874c10f4742f92"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a7ec5f53bd49815db80874c10f4742f92"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7ec5f53bd49815db80874c10f4742f92">operator-</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="memdesc:a7ec5f53bd49815db80874c10f4742f92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#a7ec5f53bd49815db80874c10f4742f92">More...</a><br /></td></tr>
<tr class="separator:a7ec5f53bd49815db80874c10f4742f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc235c95c20406e05b11a433e3ed7857"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:afc235c95c20406e05b11a433e3ed7857"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afc235c95c20406e05b11a433e3ed7857">operator-</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; val)</td></tr>
<tr class="memdesc:afc235c95c20406e05b11a433e3ed7857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides negation of the quantity.  <a href="namespaceemlabcpp.html#afc235c95c20406e05b11a433e3ed7857">More...</a><br /></td></tr>
<tr class="separator:afc235c95c20406e05b11a433e3ed7857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a18ed069c328b94893a379a85d855f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </td></tr>
<tr class="memitem:a49a18ed069c328b94893a379a85d855f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a49a18ed069c328b94893a379a85d855f">operator&lt;</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, const RhValueType rhs)</td></tr>
<tr class="memdesc:a49a18ed069c328b94893a379a85d855f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides abillity to compare quantity with non-quantity arithmetic value.  <a href="namespaceemlabcpp.html#a49a18ed069c328b94893a379a85d855f">More...</a><br /></td></tr>
<tr class="separator:a49a18ed069c328b94893a379a85d855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c42d6c592410c5073ecfb18431a4d04"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </td></tr>
<tr class="memitem:a1c42d6c592410c5073ecfb18431a4d04"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c42d6c592410c5073ecfb18431a4d04">operator&lt;</a> (const LhValueType lhs, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rhs)</td></tr>
<tr class="memdesc:a1c42d6c592410c5073ecfb18431a4d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides abillity to compare quantity with non-quantity arithmetic value.  <a href="namespaceemlabcpp.html#a1c42d6c592410c5073ecfb18431a4d04">More...</a><br /></td></tr>
<tr class="separator:a1c42d6c592410c5073ecfb18431a4d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1b0db510277c2522d504eabc6821e3"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a9a1b0db510277c2522d504eabc6821e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9a1b0db510277c2522d504eabc6821e3">operator*</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto val)</td></tr>
<tr class="memdesc:a9a1b0db510277c2522d504eabc6821e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a9a1b0db510277c2522d504eabc6821e3">More...</a><br /></td></tr>
<tr class="separator:a9a1b0db510277c2522d504eabc6821e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0176bf0d3582d8fa997f2ae98869d099"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a0176bf0d3582d8fa997f2ae98869d099"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0176bf0d3582d8fa997f2ae98869d099">operator/</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto val)</td></tr>
<tr class="memdesc:a0176bf0d3582d8fa997f2ae98869d099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a0176bf0d3582d8fa997f2ae98869d099">More...</a><br /></td></tr>
<tr class="separator:a0176bf0d3582d8fa997f2ae98869d099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad94cfee3e6e80c1e90bc767e6ace9f7e">abs</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with absolute value of internal value.  <a href="namespaceemlabcpp.html#ad94cfee3e6e80c1e90bc767e6ace9f7e">More...</a><br /></td></tr>
<tr class="separator:ad94cfee3e6e80c1e90bc767e6ace9f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a364f72aef7b46ed76b90e1f7a054fc32">cos</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; u)</td></tr>
<tr class="memdesc:a364f72aef7b46ed76b90e1f7a054fc32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cosinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#a364f72aef7b46ed76b90e1f7a054fc32">More...</a><br /></td></tr>
<tr class="separator:a364f72aef7b46ed76b90e1f7a054fc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d3eb598a75856181b79136ed06dbd8"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:aa3d3eb598a75856181b79136ed06dbd8"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa3d3eb598a75856181b79136ed06dbd8">sin</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; u)</td></tr>
<tr class="memdesc:aa3d3eb598a75856181b79136ed06dbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#aa3d3eb598a75856181b79136ed06dbd8">More...</a><br /></td></tr>
<tr class="separator:aa3d3eb598a75856181b79136ed06dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82bc958527847885bdfc4005b22271e6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a82bc958527847885bdfc4005b22271e6"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">max</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lh, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rh)</td></tr>
<tr class="memdesc:a82bc958527847885bdfc4005b22271e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with maximum value of one of the quantities.  <a href="namespaceemlabcpp.html#a82bc958527847885bdfc4005b22271e6">More...</a><br /></td></tr>
<tr class="separator:a82bc958527847885bdfc4005b22271e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">min</a> (const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lh, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; rh)</td></tr>
<tr class="memdesc:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with minimum value of one of the quantities.  <a href="namespaceemlabcpp.html#ab4db09819cc4cc5a21ed238dd2e30d6a">More...</a><br /></td></tr>
<tr class="separator:ab4db09819cc4cc5a21ed238dd2e30d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a244aa2b00962ce96249bb72e5d07b0c1">operator*</a> (const ValueType val, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:a244aa2b00962ce96249bb72e5d07b0c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a244aa2b00962ce96249bb72e5d07b0c1">More...</a><br /></td></tr>
<tr class="separator:a244aa2b00962ce96249bb72e5d07b0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memTemplItemLeft" align="right" valign="top">constexpr ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1e7c3c010fa2b7cffe9478558c1d9df6">operator/</a> (const ValueType val, const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q)</td></tr>
<tr class="memdesc:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a1e7c3c010fa2b7cffe9478558c1d9df6">More...</a><br /></td></tr>
<tr class="separator:a1e7c3c010fa2b7cffe9478558c1d9df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range</a> (Numeric from, Numeric to)</td></tr>
<tr class="memdesc:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [from, to)  <a href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">More...</a><br /></td></tr>
<tr class="separator:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace588590ccd59087b704005a3c04caae"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:ace588590ccd59087b704005a3c04caae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ace588590ccd59087b704005a3c04caae">range</a> (Numeric to)</td></tr>
<tr class="memdesc:ace588590ccd59087b704005a3c04caae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [0, to)  <a href="namespaceemlabcpp.html#ace588590ccd59087b704005a3c04caae">More...</a><br /></td></tr>
<tr class="separator:ace588590ccd59087b704005a3c04caae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2254b75f92599473cee7451ded051a0e"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a2254b75f92599473cee7451ded051a0e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2254b75f92599473cee7451ded051a0e">operator&lt;=&gt;</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:a2254b75f92599473cee7451ded051a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4e80e0e361283130d83856b68f4e6d"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:abe4e80e0e361283130d83856b68f4e6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abe4e80e0e361283130d83856b68f4e6d">operator==</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:abe4e80e0e361283130d83856b68f4e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afaabfb4832972f3f9c7589a82ac8ac4f">operator!=</a> (const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:afaabfb4832972f3f9c7589a82ac8ac4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640640991a3cfee97b11ab4df8759583"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a640640991a3cfee97b11ab4df8759583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a640640991a3cfee97b11ab4df8759583">operator&lt;=&gt;</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:a640640991a3cfee97b11ab4df8759583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaccb739b9336c5bd977ad988c3d336"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:accaccb739b9336c5bd977ad988c3d336"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#accaccb739b9336c5bd977ad988c3d336">operator==</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:accaccb739b9336c5bd977ad988c3d336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaa5569071253ac2623f7130fd1ff9d3a">operator!=</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh)</td></tr>
<tr class="separator:aaa5569071253ac2623f7130fd1ff9d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b48062894b569667fa98dbf5ceeeae"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a66b48062894b569667fa98dbf5ceeeae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a66b48062894b569667fa98dbf5ceeeae">swap</a> (const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;rh) noexcept</td></tr>
<tr class="separator:a66b48062894b569667fa98dbf5ceeeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac813ec118aa63294f4ed7955f389e289"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ac813ec118aa63294f4ed7955f389e289"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1subscript__iterator.html">iterators::subscript_iterator</a>&lt; Container &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac813ec118aa63294f4ed7955f389e289">subscript_view</a> (Container &amp;cont)</td></tr>
<tr class="separator:ac813ec118aa63294f4ed7955f389e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5b62f09ff5468bc513cac30ace3d6c58">pretty_type_name</a> ()</td></tr>
<tr class="separator:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acd74c7df9ccef5ce376d2c3fe2ef8908">requires</a> (sizeof(uint8_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3dcd56ce6fdffb4ebcf8a4c079335d8e">requires</a> (sizeof(uint16_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac39ed97224e397106e08c6e04012e62a">requires</a> (sizeof(uint32_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:ac39ed97224e397106e08c6e04012e62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2acb59e904f4530e0e8d42e98f67bcaa">requires</a> (sizeof(uint64_t)==N) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;</td></tr>
<tr class="separator:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f323f095107eec70dbb1db1387711"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:a541f323f095107eec70dbb1db1387711"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a541f323f095107eec70dbb1db1387711">operator==</a> (const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;rh)</td></tr>
<tr class="separator:a541f323f095107eec70dbb1db1387711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8d7465ddd19bb5f2eaa845a6cc78b8e0">operator!=</a> (const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;rh)</td></tr>
<tr class="separator:a8d7465ddd19bb5f2eaa845a6cc78b8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view</a> (Container &amp;cont) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td></tr>
<tr class="memdesc:a4b726ddab4f550f3e186f177243cb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container deduction guide uses iterator_of_t.  <a href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">More...</a><br /></td></tr>
<tr class="separator:a4b726ddab4f550f3e186f177243cb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c2da6250c29d0cf3d6a0cfecaa1e45"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a57c2da6250c29d0cf3d6a0cfecaa1e45"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">view_n</a> (Iter begin, const std::size_t n)</td></tr>
<tr class="memdesc:a57c2da6250c29d0cf3d6a0cfecaa1e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range!  <a href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">More...</a><br /></td></tr>
<tr class="separator:a57c2da6250c29d0cf3d6a0cfecaa1e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcf3cf10bd4814024f7177751b63c26"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a7dcf3cf10bd4814024f7177751b63c26"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7dcf3cf10bd4814024f7177751b63c26">data_view</a> (Container &amp;cont)</td></tr>
<tr class="separator:a7dcf3cf10bd4814024f7177751b63c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8a44534f893fb67e883a5a8b396ef4"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:acd8a44534f893fb67e883a5a8b396ef4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acd8a44534f893fb67e883a5a8b396ef4">trim_view</a> (Container &amp;cont, const float r)</td></tr>
<tr class="memdesc:acd8a44534f893fb67e883a5a8b396ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items.  <a href="namespaceemlabcpp.html#acd8a44534f893fb67e883a5a8b396ef4">More...</a><br /></td></tr>
<tr class="separator:acd8a44534f893fb67e883a5a8b396ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">reversed</a> (<a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;<a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype(std::rbegin(<a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>)) &gt;</td></tr>
<tr class="memdesc:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view to the Container in reverse order.  <a href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">More...</a><br /></td></tr>
<tr class="separator:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a26f7af9b55c2f2728eb7c5687b2c1"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator &gt; </td></tr>
<tr class="memitem:ad5a26f7af9b55c2f2728eb7c5687b2c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad5a26f7af9b55c2f2728eb7c5687b2c1">string_serialize_view</a> (auto &amp;&amp;w, const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator, EndIterator &gt; &amp;output)</td></tr>
<tr class="separator:ad5a26f7af9b55c2f2728eb7c5687b2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8d699d3167f848b3eb1e6d49dd2d20"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a1b8d699d3167f848b3eb1e6d49dd2d20"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1b8d699d3167f848b3eb1e6d49dd2d20">visit_index</a> (Visitor &amp;&amp;vis, const Variant &amp;var)</td></tr>
<tr class="separator:a1b8d699d3167f848b3eb1e6d49dd2d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="memdesc:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimplementation of <code>std::visit</code>.  <a href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">More...</a><br /></td></tr>
<tr class="separator:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="memdesc:a75cf44a6df8173ea7a46979f57546332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <code>visit</code> and <code>std::apply</code> into one step - provided variant is expanded with <code>visit</code> and <code>apply</code> is called on the present alternative, items from <code>apply</code> are passed to calle to visitor <code>vis</code>.  <a href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">More...</a><br /></td></tr>
<tr class="separator:a75cf44a6df8173ea7a46979f57546332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4a90457babf1c49444a526a98007a751">operator+</a> (<a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; lh, std::ptrdiff_t m)</td></tr>
<tr class="separator:a4a90457babf1c49444a526a98007a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a163dd8154f05ef8a818183d0d44cbcdc">operator!=</a> (const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;lh, const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;rh)</td></tr>
<tr class="separator:a163dd8154f05ef8a818183d0d44cbcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplParams" colspan="2">template&lt;range_container... Ts&gt; </td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip</a> (Ts &amp;&amp;... cont)</td></tr>
<tr class="memdesc:a41ab261a0f296f3c9862e59e12339885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of zip iterators for specified containers.  <a href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">More...</a><br /></td></tr>
<tr class="separator:a41ab261a0f296f3c9862e59e12339885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afe935e56d6376df9f87d0d015a3baecc">enumerate</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:afe935e56d6376df9f87d0d015a3baecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplParams" colspan="2">template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl</a> (TuplesTuple &amp;&amp;tpls, std::index_sequence&lt; ItemIndexes... &gt;, std::index_sequence&lt; TupleIndexes... &gt;)</td></tr>
<tr class="separator:aa8b8f5742901528282a9da6b8317e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d4ae07c2d875b52377456faf19fe92"><td class="memTemplParams" colspan="2">template&lt;gettable_container Tuple, gettable_container... Tuples&gt; </td></tr>
<tr class="memitem:a81d4ae07c2d875b52377456faf19fe92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a81d4ae07c2d875b52377456faf19fe92">zip</a> (Tuple &amp;&amp;frst, Tuples &amp;&amp;... tpls)</td></tr>
<tr class="memdesc:a81d4ae07c2d875b52377456faf19fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips a set of gettable containers of same size into a tuples.  <a href="namespaceemlabcpp.html#a81d4ae07c2d875b52377456faf19fe92">More...</a><br /></td></tr>
<tr class="separator:a81d4ae07c2d875b52377456faf19fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a20db02f115d34db629106a39c5194e18"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a> = 1.19e-07<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a></td></tr>
<tr class="separator:a20db02f115d34db629106a39c5194e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa7db523ecb529a3835ce0f1175fb4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a></td></tr>
<tr class="separator:a6aa7db523ecb529a3835ce0f1175fb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3571963bbe0982f9987b78b111c626"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a> {}</td></tr>
<tr class="separator:a9f3571963bbe0982f9987b78b111c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">bounded_constant</a> = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, N, N &gt;{}</td></tr>
<tr class="memdesc:a7b5a68de4881301e46697c48654d8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type alias for bounded index constants.  <a href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">More...</a><br /></td></tr>
<tr class="separator:a7b5a68de4881301e46697c48654d8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">bounded_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#aa15d5c022409d351cd45334d7501dc72">detail::bounded_derived_test</a>( val ); }</td></tr>
<tr class="memdesc:add79493bcf07bd4c54afffe3a0f3ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that matchestype deriving from bounded.  <a href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">More...</a><br /></td></tr>
<tr class="separator:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a></td></tr>
<tr class="separator:a94924279b38cf1803ee0f01cb4889b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a></td></tr>
<tr class="separator:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5494e6f6f24a2fd7e7ccfaecb31944b3">arithmetic_like</a> = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td></tr>
<tr class="separator:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td></tr>
<tr class="separator:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a></td></tr>
<tr class="separator:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a></td></tr>
<tr class="memdesc:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible  <a href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">More...</a><br /></td></tr>
<tr class="separator:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a> = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt;</td></tr>
<tr class="separator:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a></td></tr>
<tr class="separator:ad5b78b4d7a2e426170153951069c76cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f5be4da9ac6f367034af1f5028827"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ValueType &gt; </td></tr>
<tr class="memitem:ae70f5be4da9ac6f367034af1f5028827"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae70f5be4da9ac6f367034af1f5028827">range_container_with</a></td></tr>
<tr class="separator:ae70f5be4da9ac6f367034af1f5028827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a></td></tr>
<tr class="separator:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplParams" colspan="2">template&lt;typename UnaryCallable , typename Container &gt; </td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abeb742c691973ef2d34b0ace4d8eef15">container_invocable</a></td></tr>
<tr class="separator:abeb742c691973ef2d34b0ace4d8eef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplParams" colspan="2">template&lt;typename UnaryCallable , typename ReturnValue , typename... Args&gt; </td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5219e24bd076b3c65f56c69b9025dd69">invocable_returning</a></td></tr>
<tr class="separator:a5219e24bd076b3c65f56c69b9025dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a></td></tr>
<tr class="separator:a27325f314502897567307b29b2b03776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Variant &gt; </td></tr>
<tr class="memitem:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5a66cad0d4226d39ffd692e16bcfc076">alternative_of</a></td></tr>
<tr class="memdesc:a5a66cad0d4226d39ffd692e16bcfc076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thanks for the solution goes to PJBoy@libera.  <a href="namespaceemlabcpp.html#a5a66cad0d4226d39ffd692e16bcfc076">More...</a><br /></td></tr>
<tr class="separator:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3895ca2fd367021e74c1915f724c0242"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a3895ca2fd367021e74c1915f724c0242"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3895ca2fd367021e74c1915f724c0242">element_of</a></td></tr>
<tr class="separator:a3895ca2fd367021e74c1915f724c0242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af124e29aa89adc5fce430ee7fdda3cc4">with_value_type</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> { typename T::value_type; }</td></tr>
<tr class="separator:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8fd33adfcfe872f4402d4b61b41113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Signature &gt; </td></tr>
<tr class="memitem:afc8fd33adfcfe872f4402d4b61b41113"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afc8fd33adfcfe872f4402d4b61b41113">with_signature</a> = std::same_as&lt; typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a>&lt; T &gt;::signature, Signature &gt;</td></tr>
<tr class="separator:afc8fd33adfcfe872f4402d4b61b41113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f6b4dc0a35260a281aa436f5401cce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24f6b4dc0a35260a281aa436f5401cce"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a24f6b4dc0a35260a281aa436f5401cce">with_push_back</a></td></tr>
<tr class="separator:a24f6b4dc0a35260a281aa436f5401cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459242c17dfd40402115fe8a63d21622"><td class="memTemplParams" colspan="2">template&lt;typename T , typename LH , typename RH &gt; </td></tr>
<tr class="memitem:a459242c17dfd40402115fe8a63d21622"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a459242c17dfd40402115fe8a63d21622">either_uniquely_right_item</a></td></tr>
<tr class="separator:a459242c17dfd40402115fe8a63d21622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a></td></tr>
<tr class="separator:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6adfccd266cb01c6cfd376ea222c110"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6adfccd266cb01c6cfd376ea222c110"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad6adfccd266cb01c6cfd376ea222c110">decomposable_0</a> = <a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a>&lt; T &gt; &amp;&amp; ( <a class="el" href="namespaceemlabcpp_1_1detail.html#a10e61621464f2e4cc1316387d1b70b19">detail::decompose_count</a>&lt; T &gt;() == 0 )</td></tr>
<tr class="separator:ad6adfccd266cb01c6cfd376ea222c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7fdeaa7689b2455a087e965cbc7b3d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5b7fdeaa7689b2455a087e965cbc7b3d">neutral_quat</a> { 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 1.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> }</td></tr>
<tr class="separator:a5b7fdeaa7689b2455a087e965cbc7b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183135aadf6bd4c3bd69d06b05b50407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a183135aadf6bd4c3bd69d06b05b50407"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a183135aadf6bd4c3bd69d06b05b50407">vec_point_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8ca7a3c5bc16d1b3a13b068bf7a7c8be">detail::vec_point_derived_test</a>( val ); }</td></tr>
<tr class="separator:a183135aadf6bd4c3bd69d06b05b50407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3933e60ced207f516b389cc37ab278de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3933e60ced207f516b389cc37ab278de">x_axis</a> { 1, 0, 0 }</td></tr>
<tr class="memdesc:a3933e60ced207f516b389cc37ab278de"><td class="mdescLeft">&#160;</td><td class="mdescRight">instances of constants in the code for X/Y/Z axis  <a href="namespaceemlabcpp.html#a3933e60ced207f516b389cc37ab278de">More...</a><br /></td></tr>
<tr class="separator:a3933e60ced207f516b389cc37ab278de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf41298fd59d19888d3fee5cea2fe4d8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaf41298fd59d19888d3fee5cea2fe4d8">y_axis</a> { 0, 1, 0 }</td></tr>
<tr class="separator:aaf41298fd59d19888d3fee5cea2fe4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9562476a49ff3f90e84d658dd3bafbb9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9562476a49ff3f90e84d658dd3bafbb9">z_axis</a> { 0, 0, 1 }</td></tr>
<tr class="separator:a9562476a49ff3f90e84d658dd3bafbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3959b862aa2e1cc006ab40cb96de64a2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3959b862aa2e1cc006ab40cb96de64a2">INFO_LOGGER_COLORS</a> = { .time = &quot;33&quot;, .file = &quot;128&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;164&quot; }</td></tr>
<tr class="separator:a3959b862aa2e1cc006ab40cb96de64a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040c9fa2d6c0e4a28649479052ad8f8d"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a040c9fa2d6c0e4a28649479052ad8f8d">DEBUG_LOGGER_COLORS</a> = { .time = &quot;250&quot;, .file = &quot;252&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;248&quot; }</td></tr>
<tr class="separator:a040c9fa2d6c0e4a28649479052ad8f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04c4ddd773c5ae47bf78d051770a30a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa04c4ddd773c5ae47bf78d051770a30a">ERROR_LOGGER_COLORS</a> = { .time = &quot;196&quot;, .file = &quot;197&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;198&quot; }</td></tr>
<tr class="separator:aa04c4ddd773c5ae47bf78d051770a30a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71244dcc912784b08768c6ae041c37bc"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a71244dcc912784b08768c6ae041c37bc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a71244dcc912784b08768c6ae041c37bc">matrix_like</a></td></tr>
<tr class="separator:a71244dcc912784b08768c6ae041c37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0ddf4f4fdd45dfc13d5420c34b446"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0b0ddf4f4fdd45dfc13d5420c34b446"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae0b0ddf4f4fdd45dfc13d5420c34b446">pretty_printable</a></td></tr>
<tr class="separator:ae0b0ddf4f4fdd45dfc13d5420c34b446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">pi</a> = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> }</td></tr>
<tr class="memdesc:a7cac9e89744ae1ec8ad817df33d291f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants of units that are relevant for us.  <a href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">More...</a><br /></td></tr>
<tr class="separator:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a869ab03f1bd49e1adc49de513ad86ba4">quantity_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8be65555da61958326df0b50c6ee2bd8">detail::quantity_derived_test</a>( val ); }</td></tr>
<tr class="memdesc:a869ab03f1bd49e1adc49de513ad86ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept satisfies any type <code>T</code> that inherits from any form of <code>quantity&lt;U&gt;</code>.  <a href="namespaceemlabcpp.html#a869ab03f1bd49e1adc49de513ad86ba4">More...</a><br /></td></tr>
<tr class="separator:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aff43a196db9cecc357e6f4452638b32f">is_view_v</a> = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aff43a196db9cecc357e6f4452638b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae5e4923a149af384640fe5d3759dcc9a">are_same_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td></tr>
<tr class="separator:ae5e4923a149af384640fe5d3759dcc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Us&gt; </td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8574533cb7c969125a6fde8f5063eff2">tuple_has_type_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td></tr>
<tr class="separator:a8574533cb7c969125a6fde8f5063eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a633f5fea14133c23b25a75cd57a8805d">is_std_tuple_v</a> = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a633f5fea14133c23b25a75cd57a8805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1d463be90e36b5d5be447e407fca17bf">is_std_array_v</a> = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a1d463be90e36b5d5be447e407fca17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa5277a3e558d32758ca0e4770ed5e1eb">is_std_vector_v</a> = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">static_size_v</a> = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td></tr>
<tr class="memdesc:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marked deprecated on 19.4.2021.  <a href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">More...</a><br /></td></tr>
<tr class="separator:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adaca063c7275419f3999bd854c88de3d">has_static_size_v</a> = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td></tr>
<tr class="separator:adaca063c7275419f3999bd854c88de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cdce6706f4b40d478521925ca85f8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a></td></tr>
<tr class="separator:ac1cdce6706f4b40d478521925ca85f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (C) 2020 Jan Veverak Koniarik. </p>
<p>Copyright (C) 2023 Jan Veverak Koniarik.</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structemlabcpp_1_1empty__assembly__tag" id="structemlabcpp_1_1empty__assembly__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1empty__assembly__tag">&#9670;&nbsp;</a></span>emlabcpp::empty_assembly_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::empty_assembly_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Marks empty assembly. </p>
</div>
</div>
</div>
<a name="classemlabcpp_1_1function__view" id="classemlabcpp_1_1function__view"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classemlabcpp_1_1function__view">&#9670;&nbsp;</a></span>emlabcpp::function_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class emlabcpp::function_view</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Signature&gt;<br />
class emlabcpp::function_view&lt; Signature &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1pose__distance" id="structemlabcpp_1_1pose__distance"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pose__distance">&#9670;&nbsp;</a></span>emlabcpp::pose_distance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pose_distance</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>distance between two poses in space, represented as 'space distance' and 'angular distance' </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a86cfd1cc45e85428b1d42ea979b19b7e"></a>float</td>
<td class="fieldname">
angle_dist</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a746c782172b5cd06a357056a324f437b"></a>float</td>
<td class="fieldname">
dist</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1log__colors" id="structemlabcpp_1_1log__colors"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1log__colors">&#9670;&nbsp;</a></span>emlabcpp::log_colors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::log_colors</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::log_colors:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1log__colors__coll__graph.svg" width="178" height="247"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a16da217837876e1ca186c4edf83590a1"></a>string_view</td>
<td class="fieldname">
file</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a33c5ed3dba4f9efa0836eeeec747e47b"></a>string_view</td>
<td class="fieldname">
line</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="af175fa386686fa863a3f581d48e05167"></a>string_view</td>
<td class="fieldname">
time</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1log__color__stub" id="structemlabcpp_1_1log__color__stub"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1log__color__stub">&#9670;&nbsp;</a></span>emlabcpp::log_color_stub</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::log_color_stub</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::log_color_stub:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1log__color__stub__coll__graph.svg" width="199" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a947ae8250161b2045cebbac076cbb06f"></a>string_view</td>
<td class="fieldname">
c</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1pretty__printer" id="structemlabcpp_1_1pretty__printer"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pretty__printer">&#9670;&nbsp;</a></span>emlabcpp::pretty_printer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pretty_printer</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct emlabcpp::pretty_printer&lt; T &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1pid__coefficients" id="structemlabcpp_1_1pid__coefficients"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pid__coefficients">&#9670;&nbsp;</a></span>emlabcpp::pid_coefficients</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pid_coefficients</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a655b9d57207a6513eefd69f5099fdae2"></a>float</td>
<td class="fieldname">
d</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a99ba17ee27bed7c782d9364b7b614eae"></a>float</td>
<td class="fieldname">
i</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac0b0048d94d97cc9884974fe74898b69"></a>float</td>
<td class="fieldname">
p</td>
<td class="fielddoc">
coeficients </td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1pid__config" id="structemlabcpp_1_1pid__config"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pid__config">&#9670;&nbsp;</a></span>emlabcpp::pid_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pid_config</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure to configure the pid regulator. </p>
</div><div id="dynsection-2" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-2-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::pid_config:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1pid__config__coll__graph.svg" width="398" height="142"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a096dcb0c9bf6af343c832bebada97419"></a><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__coefficients">pid_coefficients</a></td>
<td class="fieldname">
coefficients</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a22314e3c7c4363b32d39914c8c473c3c"></a><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt;</td>
<td class="fieldname">
limits</td>
<td class="fielddoc">
limits the output of the pid regulator and internal anti-windup mechanism </td></tr>
</table>

</div>
</div>
<a name="classemlabcpp_1_1static__function__base" id="classemlabcpp_1_1static__function__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classemlabcpp_1_1static__function__base">&#9670;&nbsp;</a></span>emlabcpp::static_function_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class emlabcpp::static_function_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename CallableType, std::size_t Capacity, std::size_t Align&gt;<br />
class emlabcpp::static_function_base&lt; CallableType, Capacity, Align &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1iterator__of" id="structemlabcpp_1_1iterator__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1iterator__of">&#9670;&nbsp;</a></span>emlabcpp::iterator_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::iterator_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container&gt;<br />
struct emlabcpp::iterator_of&lt; Container &gt;</h3>

<hr  />
<p> <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a> is structure where <a class="el" href="namespaceemlabcpp.html#abb6468ad7836780268a9d6ed31b017bc">iterator_of&lt;Container&gt;::type</a> returns type of iterator that is returned by cont.begin(); </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abb6468ad7836780268a9d6ed31b017bc"></a>typedef decltype(begin(declval&lt; add_lvalue_reference_t&lt; Container &gt; &gt;()))</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1are__same" id="structemlabcpp_1_1are__same"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1are__same">&#9670;&nbsp;</a></span>emlabcpp::are_same</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::are_same</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename...&gt;<br />
struct emlabcpp::are_same&lt;... &gt;</h3>

<hr  />
<p> are_same&lt;Ts..&gt;::value is true if all Ts... are equal types. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1tuple__has__type" id="structemlabcpp_1_1tuple__has__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1tuple__has__type">&#9670;&nbsp;</a></span>emlabcpp::tuple_has_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::tuple_has_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Tuple&gt;<br />
struct emlabcpp::tuple_has_type&lt; T, Tuple &gt;</h3>

<hr  />
<p> tuple_has_type&lt;T, Tuple&gt;::value is true if Tuple s std::tuple and contains type T </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1signature__of" id="structemlabcpp_1_1signature__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1signature__of">&#9670;&nbsp;</a></span>emlabcpp::signature_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::signature_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Signature&gt;<br />
struct emlabcpp::signature_of&lt; Signature &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4" id="structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4">&#9670;&nbsp;</a></span>emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnType, typename... Args&gt;<br />
struct emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a1d6031bb6774f9e0fdd9127e753b4429"></a></td>
<td class="fieldname">
args_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaf6b1e41353c5010a20ce6ae5543a98d"></a>typedef ReturnType</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a04896856a5012f04869873b5f6431cf8"></a></td>
<td class="fieldname">
signature</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1mapped" id="structemlabcpp_1_1mapped"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1mapped">&#9670;&nbsp;</a></span>emlabcpp::mapped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::mapped</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container, typename UnaryCallable&gt;<br />
struct emlabcpp::mapped&lt; Container, UnaryCallable &gt;</h3>

<hr  />
<p> mapped&lt;T,F&gt;::type is type returned by instance of F::operator() when applied on items from instance of T. It can differentiate between tuples or containers </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1select__utype" id="structemlabcpp_1_1select__utype"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1select__utype">&#9670;&nbsp;</a></span>emlabcpp::select_utype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::select_utype</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t&gt;<br />
struct emlabcpp::select_utype&lt; size_t &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1type__map" id="structemlabcpp_1_1type__map"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__map">&#9670;&nbsp;</a></span>emlabcpp::type_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, template&lt; typename &gt; class&gt;<br />
struct emlabcpp::type_map&lt; typename, class &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4" id="structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4">&#9670;&nbsp;</a></span>emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename... Ts, template&lt; typename &gt; class Fun&gt;<br />
struct emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a7e53b3be429836ebe9e7cdecc239f7d8"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1type__tag" id="structemlabcpp_1_1type__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__tag">&#9670;&nbsp;</a></span>emlabcpp::type_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct emlabcpp::type_tag&lt; T &gt;</h3>

<hr  />
 </div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa956ddce4f2384a729e45e5b6a83c212"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1index__of" id="structemlabcpp_1_1index__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1index__of">&#9670;&nbsp;</a></span>emlabcpp::index_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::index_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Variant&gt;<br />
struct emlabcpp::index_of&lt; T, Variant &gt;</h3>

<hr  />
 </div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9f7b213031fa424abf6cc3d1d04ac1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7b213031fa424abf6cc3d1d04ac1ca">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">emlabcpp::acceleration</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a034dcea22b6c4c252c6127ffd7078a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034dcea22b6c4c252c6127ffd7078a7d">&#9670;&nbsp;</a></span>amount_of_substance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a034dcea22b6c4c252c6127ffd7078a7d">emlabcpp::amount_of_substance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa050c988b29285083320111dc7b90ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa050c988b29285083320111dc7b90ca">&#9670;&nbsp;</a></span>angle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">emlabcpp::angle</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0893503dba0b6cfd0ebd72ceb358f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0893503dba0b6cfd0ebd72ceb358f20">&#9670;&nbsp;</a></span>angular_velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af0893503dba0b6cfd0ebd72ceb358f20">emlabcpp::angular_velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eca5b22a706c436b22c929c45b773ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca5b22a706c436b22c929c45b773ef">&#9670;&nbsp;</a></span>area</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a4eca5b22a706c436b22c929c45b773ef">emlabcpp::area</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afde778df7140459ee3df4cf32bf7566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde778df7140459ee3df4cf32bf7566e">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afde778df7140459ee3df4cf32bf7566e">emlabcpp::byte</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2eceaa8b0d9ceb67162be01c8a803f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2eceaa8b0d9ceb67162be01c8a803f7">&#9670;&nbsp;</a></span>current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae2eceaa8b0d9ceb67162be01c8a803f7">emlabcpp::current</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ac05592b4c728910966af0c89b13a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ac05592b4c728910966af0c89b13a8">&#9670;&nbsp;</a></span>distance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">emlabcpp::distance</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf27b9093d0831dd17c88bcce4f9330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf27b9093d0831dd17c88bcce4f9330">&#9670;&nbsp;</a></span>force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aabf27b9093d0831dd17c88bcce4f9330">emlabcpp::force</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 1, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d67880c6a526098821b950d000c2d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d67880c6a526098821b950d000c2d79">&#9670;&nbsp;</a></span>frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a0d67880c6a526098821b950d000c2d79">emlabcpp::frequency</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98ab53b012e339a9621604b203df856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ab53b012e339a9621604b203df856e">&#9670;&nbsp;</a></span>iterator_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">emlabcpp::iterator_of_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a458a21111b267fd6b9727f821974f859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458a21111b267fd6b9727f821974f859">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">emlabcpp::length</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a068a535d76f319e21113bceb0fdb8fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068a535d76f319e21113bceb0fdb8fbe">&#9670;&nbsp;</a></span>line</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">emlabcpp::line</a> = typedef std::array&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, 2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5e1be68f8469a0ef8388b17b94406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5e1be68f8469a0ef8388b17b94406e">&#9670;&nbsp;</a></span>luminous_intensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5c5e1be68f8469a0ef8388b17b94406e">emlabcpp::luminous_intensity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf111745a0eec5119748333b9640afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf111745a0eec5119748333b9640afca">&#9670;&nbsp;</a></span>mapped_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryCallable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abf111745a0eec5119748333b9640afca">emlabcpp::mapped_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620d7b1d1801843cd1a7356bcc341e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620d7b1d1801843cd1a7356bcc341e3e">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a620d7b1d1801843cd1a7356bcc341e3e">emlabcpp::mass</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf48f5a991078e6acfe3db1e7762675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf48f5a991078e6acfe3db1e7762675">&#9670;&nbsp;</a></span>power</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abbf48f5a991078e6acfe3db1e7762675">emlabcpp::power</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af96516bd702e891771257f4dc279a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96516bd702e891771257f4dc279a2f2">&#9670;&nbsp;</a></span>radius</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af96516bd702e891771257f4dc279a2f2">emlabcpp::radius</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48e239b7c22e51004fc26dd043d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48e239b7c22e51004fc26dd043d32b9">&#9670;&nbsp;</a></span>resistance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae48e239b7c22e51004fc26dd043d32b9">emlabcpp::resistance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -2, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac223240cfaa32fcb48f0daa06c78a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac223240cfaa32fcb48f0daa06c78a9e2">&#9670;&nbsp;</a></span>select_utype_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">emlabcpp::select_utype_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; N &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a803520b1d525d0030e528bc67b402b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803520b1d525d0030e528bc67b402b53">&#9670;&nbsp;</a></span>static_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , std::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a803520b1d525d0030e528bc67b402b53">emlabcpp::static_function</a> = typedef <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a>&lt; Signature, Capacity, alignof( void* ) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a845bc83f874f1d97f649fbe0137c913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845bc83f874f1d97f649fbe0137c913c">&#9670;&nbsp;</a></span>temp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a845bc83f874f1d97f649fbe0137c913c">emlabcpp::temp</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35fa23942849e26dc612a6608eb2ec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fa23942849e26dc612a6608eb2ec02">&#9670;&nbsp;</a></span>timeq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">emlabcpp::timeq</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af17d6009cc0a80e2faa67f36d49a1e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17d6009cc0a80e2faa67f36d49a1e64">&#9670;&nbsp;</a></span>triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">emlabcpp::triangle</a> = typedef <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, 2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbd4de918223b1144d32fcef8a9dfe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd4de918223b1144d32fcef8a9dfe2a">&#9670;&nbsp;</a></span>type_map_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename &gt; class Fun&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afbd4de918223b1144d32fcef8a9dfe2a">emlabcpp::type_map_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a>&lt; T, Fun &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a151948c6a8488f45e3d7834f876be469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151948c6a8488f45e3d7834f876be469">&#9670;&nbsp;</a></span>unitless</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a151948c6a8488f45e3d7834f876be469">emlabcpp::unitless</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type alieases of physical quantity for used quantities. </p>

</div>
</div>
<a id="a1133bfe4782c135fcdb04c3de43fc0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133bfe4782c135fcdb04c3de43fc0a1">&#9670;&nbsp;</a></span>velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">emlabcpp::velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c9a554fd1715665000628242b77a474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9a554fd1715665000628242b77a474">&#9670;&nbsp;</a></span>voltage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1c9a554fd1715665000628242b77a474">emlabcpp::voltage</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f05bc39f7d9b7332f437d5a7b19156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f05bc39f7d9b7332f437d5a7b19156c">&#9670;&nbsp;</a></span>volume</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5f05bc39f7d9b7332f437d5a7b19156c">emlabcpp::volume</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 3, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa815694613f8d89e804ac10b1395eeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa815694613f8d89e804ac10b1395eeca">&#9670;&nbsp;</a></span>contiguous_container_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eeca">emlabcpp::contiguous_container_type</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa815694613f8d89e804ac10b1395eecaacb4fb1757fb37c43cded35d3eb857c43"></a>ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa815694613f8d89e804ac10b1395eecaa8eee8e217391199668cbac89472ace53"></a>OBJECT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a453799fa0ff8d942480b0bcc3dbf7f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453799fa0ff8d942480b0bcc3dbf7f10">&#9670;&nbsp;</a></span>contiguous_request_adapter_errors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10">emlabcpp::contiguous_request_adapter_errors</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a7e94d60ca52c8bf6da26a0a479f08d21"></a>MISSING_NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a9bf67e4befa0dcd99caa7f01f2c9b714"></a>WRONG_TYPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a3396545d99c2f2d78dd20411b4a66ad2"></a>CHILD_MISSING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10aba7de5bc6888294e5884b024a4c894f1"></a>FULL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a98cc8be30884776ff941bb6ae93946fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cc8be30884776ff941bb6ae93946fd">&#9670;&nbsp;</a></span>contiguous_tree_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fd">emlabcpp::contiguous_tree_type</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fdaecc2e9c313faddb07e7da223c1dc5c3f"></a>VALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fda8eee8e217391199668cbac89472ace53"></a>OBJECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fdacb4fb1757fb37c43cded35d3eb857c43"></a>ARRAY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a4d26e4c3f680aa9ba3a5469a253cca55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d26e4c3f680aa9ba3a5469a253cca55">&#9670;&nbsp;</a></span>log_severity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a4d26e4c3f680aa9ba3a5469a253cca55">emlabcpp::log_severity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d26e4c3f680aa9ba3a5469a253cca55adc30ec20708ef7b0f641ef78b7880a15"></a>DEBUG&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d26e4c3f680aa9ba3a5469a253cca55a551b723eafd6a31d444fcb2f5920fbd3"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad94cfee3e6e80c1e90bc767e6ace9f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94cfee3e6e80c1e90bc767e6ace9f7e">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with absolute value of internal value. </p>

</div>
</div>
<a id="a306420110ac2a2a1ecc364e0053c1e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306420110ac2a2a1ecc364e0053c1e30">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates absolute version of A - removing signs on all dimensions. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a234414158becfed39f1b4958c694a8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234414158becfed39f1b4958c694a8d9">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T , typename BinaryCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::accumulate </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, returns a result of last application. </p>
<p>NOLINT(bugprone-use-after-move)</p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a4b323693e8d1a33bad5c12c63709fe3b">init()</a>.</p>

</div>
</div>
<a id="aab724dd793953a308bea8dba2118aade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab724dd793953a308bea8dba2118aade">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::all_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns true for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2d80507cffdd192a333f6bd9c272e97a">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a30565e3c9f95b08ee5cd25294bc375d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30565e3c9f95b08ee5cd25294bc375d7">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;vec_point_derived Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Derived &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if A and B are equal within specified tolerance, this means that difference of all coordinates of A and B has to be within that epsilon. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aab724dd793953a308bea8dba2118aade">all_of()</a>, <a class="el" href="namespaceemlabcpp.html#af4898d31a822e25963cab32a985e89f4">almost_equal()</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a130ed4c792c2efaf92b76eb607a433c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130ed4c792c2efaf92b76eb607a433c3">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>two poses are almost equal when their orientations and positions are almost equal </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#af4898d31a822e25963cab32a985e89f4">almost_equal()</a>, <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a0d682324e6ca417852d4bcaecb77db23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d682324e6ca417852d4bcaecb77db23">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aab724dd793953a308bea8dba2118aade">all_of()</a>, and <a class="el" href="namespaceemlabcpp.html#af4898d31a822e25963cab32a985e89f4">almost_equal()</a>.</p>

</div>
</div>
<a id="af4898d31a822e25963cab32a985e89f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4898d31a822e25963cab32a985e89f4">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a306420110ac2a2a1ecc364e0053c1e30">abs()</a>.</p>

</div>
</div>
<a id="aa86203b42f9478701d1f52443d5729a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa86203b42f9478701d1f52443d5729a3">&#9670;&nbsp;</a></span>angle_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::angle_shortest_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, <a class="el" href="namespaceemlabcpp.html#af6fc2eeaf683b868d3ec7eed8fe6f69a">norm2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="a2d80507cffdd192a333f6bd9c272e97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d80507cffdd192a333f6bd9c272e97a">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::any_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns true for at least one item <code>x</code> in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a63a6aaa5fc338d3d342d90a14225fe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a6aaa5fc338d3d342d90a14225fe82">&#9670;&nbsp;</a></span>apply_on_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit()</a>.</p>

</div>
</div>
<a id="a75cf44a6df8173ea7a46979f57546332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf44a6df8173ea7a46979f57546332">&#9670;&nbsp;</a></span>apply_on_visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines <code>visit</code> and <code>std::apply</code> into one step - provided variant is expanded with <code>visit</code> and <code>apply</code> is called on the present alternative, items from <code>apply</code> are passed to calle to visitor <code>vis</code>. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="a306d3a03f11c2e95874c23956020a755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306d3a03f11c2e95874c23956020a755">&#9670;&nbsp;</a></span>assemble_left_collect_right()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstE , typename... Eithers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::assemble_left_collect_right </td>
          <td>(</td>
          <td class="paramtype">FirstE &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eithers &amp;&amp;...&#160;</td>
          <td class="paramname"><em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function expects eithers of any left type, but same right type. </p>
<p>These are acceessed and either tuple of <em>all</em> left items is returned or vector of any of right items.</p>
<p>This returns appropiated either&lt; std::tuple&lt; LeftItems... &gt;, <a class="el" href="classemlabcpp_1_1static__vector.html" title="Data container for up to N elements.">static_vector</a>&lt; Righitems, N &gt;&gt;. This is handy for uses cases when you have expected values of multiple functions on the left, / and their errors on the right. It either returns all values or the errors that happend. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac30a98c58cf8a76fa9363a0d19c09486">assemble_optionals()</a>.</p>

</div>
</div>
<a id="ac30a98c58cf8a76fa9363a0d19c09486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30a98c58cf8a76fa9363a0d19c09486">&#9670;&nbsp;</a></span>assemble_optionals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1either.html">either</a>&lt; std::tuple&lt; Ts... &gt;, <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag">empty_assembly_tag</a> &gt; emlabcpp::assemble_optionals </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; Ts &gt; &amp;&amp;...&#160;</td>
          <td class="paramname"><em>opt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function gets a set of various std::optionals and either returns all their values assembled as tuple or '<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1empty__assembly__tag" title="Marks empty assembly.">empty_assembly_tag</a>' implicating that some of the optionals was empty. </p>

</div>
</div>
<a id="aeb03fae2e4aecd67b1f163e1ab523e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb03fae2e4aecd67b1f163e1ab523e89">&#9670;&nbsp;</a></span>avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::avg </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(x)' to each element of container 'cont' and returns the average value of each call. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="aaf2a3b65521b77f85095c0130ef945fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a3b65521b77f85095c0130ef945fe">&#9670;&nbsp;</a></span>axis_projection_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::axis_projection_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to calculate distance of projection of point A. </p>
<p>That point is projected on axis defined only by it's direction - 'axis_direction'. The distance of that projection from the [0,0,0] coordinate is returned. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="ae2f187ac1e10327a8c941d80b3b6b1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f187ac1e10327a8c941d80b3b6b1e4">&#9670;&nbsp;</a></span>bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, std::size_t N = sizeof...( Args )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; std::byte, N &gt; emlabcpp::bytes </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a3ff32c2bf0005fcdbab5763193f239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3ff32c2bf0005fcdbab5763193f239">&#9670;&nbsp;</a></span>ceil_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::ceil_to </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>takes an value <code>val</code> and rounds it up to nearest multiply of <code>base</code> </p>

</div>
</div>
<a id="a8c868b270298a6e752372a1809dc03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c868b270298a6e752372a1809dc03d0">&#9670;&nbsp;</a></span>center_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, std::size_t U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; emlabcpp::center_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aeb03fae2e4aecd67b1f163e1ab523e89">avg()</a>, <a class="el" href="namespaceemlabcpp.html#a1806b61b0659c26b8a0a53288ecfa313">point_cast()</a>, <a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="a1eb69734e95cc40cd53e2f01531183d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb69734e95cc40cd53e2f01531183d7">&#9670;&nbsp;</a></span>cobs_decode_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt;, <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt; &gt; emlabcpp::cobs_decode_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, and <a class="el" href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">find()</a>.</p>

</div>
</div>
<a id="a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e72f5ad9fec2b8f70d4f8e0e5ec0d23">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::compose </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>tpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a631eb361805aa7459b944503f7538951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631eb361805aa7459b944503f7538951">&#9670;&nbsp;</a></span>cont_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::cont_size </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the container, regardless of what it is. </p>

</div>
</div>
<a id="a6b36ab023620ad0de3855f2f892d400f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b36ab023620ad0de3855f2f892d400f">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::contains </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if container <code>cont</code> contains at least one occurence of <code>item</code>, returns true/false. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size()</a>, and <a class="el" href="namespaceemlabcpp.html#ae6a73bbed8b818abff4ab4e7c2b9af68">find()</a>.</p>

</div>
</div>
<a id="a51bc55ba3cb21b9294e89cdda68b1f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bc55ba3cb21b9294e89cdda68b1f98">&#9670;&nbsp;</a></span>convert_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a7d1590aa2cb61d0e710f02fea01474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d1590aa2cb61d0e710f02fea01474">&#9670;&nbsp;</a></span>convert_view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view_n </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">view_n()</a>.</p>

</div>
</div>
<a id="af85136552afa4d0a86dd1fb078223cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85136552afa4d0a86dd1fb078223cdd">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::copy </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>.</p>

</div>
</div>
<a id="a364f72aef7b46ed76b90e1f7a054fc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364f72aef7b46ed76b90e1f7a054fc32">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::cos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cosinus of the quantity as scalar. </p>

</div>
</div>
<a id="a1377f84042c48380be9118421fb97e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1377f84042c48380be9118421fb97e6f">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::count </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the predicate 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="aefc03fbfa97fbe6458f075c4be65ce33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc03fbfa97fbe6458f075c4be65ce33">&#9670;&nbsp;</a></span>cross_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::cross_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates cross product between points A and B. </p>

</div>
</div>
<a id="a7dcf3cf10bd4814024f7177751b63c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcf3cf10bd4814024f7177751b63c26">&#9670;&nbsp;</a></span>data_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::data_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a57c2da6250c29d0cf3d6a0cfecaa1e45">view_n()</a>.</p>

</div>
</div>
<a id="a287862121b428bfa9cc668e1f774e2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287862121b428bfa9cc668e1f774e2d5">&#9670;&nbsp;</a></span>decode_cobs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte* &gt; &gt; emlabcpp::decode_cobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer. </p>
<p>Note that this does not expect 0 at the end. </p>

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1view.html#a307e340890bedc068c2cac28e2f86896">emlabcpp::view&lt; Iterator, EndIterator &gt;::end()</a>, <a class="el" href="classemlabcpp_1_1view.html#aa3f0ea5c04b558312cdb77c20664fd7f">emlabcpp::view&lt; Iterator, EndIterator &gt;::front()</a>, <a class="el" href="structemlabcpp_1_1cobs__decoder.html#a5e5580278c364e7c388983570a73646c">emlabcpp::cobs_decoder::iter()</a>, and <a class="el" href="namespaceemlabcpp.html#a254ed4de50fc497ac961253ac3625040">tail()</a>.</p>

</div>
</div>
<a id="afecb966a998ea6497e7b378bca2681c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecb966a998ea6497e7b378bca2681c8">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;decomposable_0 T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple emlabcpp::decompose </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac81ee08c08bd405c0e3def37de64f126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81ee08c08bd405c0e3def37de64f126">&#9670;&nbsp;</a></span>dimensional_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::dimensional_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a C, where C[i] = max(A[i], B[i]) holds for 0 &lt;= i &lt; N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a5d9345d163bdab63d39dec5d99354c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9345d163bdab63d39dec5d99354c81">&#9670;&nbsp;</a></span>dimensional_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::dimensional_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a C, where C[i] = min(A[i], B[i]) holds for 0 &lt;= i &lt; N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5098342c4801b4a7d9ec75b1143f7801">min()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="aa85dd86813ed16ef311a88daac50792d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85dd86813ed16ef311a88daac50792d">&#9670;&nbsp;</a></span>dimensional_min_max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction  = std::identity, typename Derived  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; Derived &gt; emlabcpp::dimensional_min_max_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51181e92ac66d2a113b7c0e5b9a2718e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51181e92ac66d2a113b7c0e5b9a2718e">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, and <a class="el" href="namespaceemlabcpp.html#a01057565d5ebaf62d92c2a45cfdde65b">length2_of()</a>.</p>

</div>
</div>
<a id="a9977373a20edbc718c415668d82b0893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9977373a20edbc718c415668d82b0893">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns euclidian distance of point A from point B. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>, and <a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum()</a>.</p>

</div>
</div>
<a id="a0fabc0e3695f7218ab026b253d56ea6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fabc0e3695f7218ab026b253d56ea6e">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a51181e92ac66d2a113b7c0e5b9a2718e">distance_of()</a>.</p>

</div>
</div>
<a id="ac081ada5ee8e130abc77d8471f570661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac081ada5ee8e130abc77d8471f570661">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a> emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns PoseDistance between provided poses </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa86203b42f9478701d1f52443d5729a3">angle_shortest_path()</a>, <a class="el" href="namespaceemlabcpp.html#a51181e92ac66d2a113b7c0e5b9a2718e">distance_of()</a>, <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a8e3cab8faa406c3fc0e6c197d7663f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3cab8faa406c3fc0e6c197d7663f12">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7721009a36753730f1afa6be47dbf28b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7721009a36753730f1afa6be47dbf28b">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between A and B. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum()</a>.</p>

</div>
</div>
<a id="ab124463ea669779e32ea4428088a01c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab124463ea669779e32ea4428088a01c4">&#9670;&nbsp;</a></span>EMLABCPP_GENERATE_DECOMPOSE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::EMLABCPP_GENERATE_DECOMPOSE </td>
          <td>(</td>
          <td class="paramtype">16&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a3&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a4&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a5&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a6&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a7&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a8&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a9&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a10&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a11&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a12&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a13&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a14&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a15&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66eda67f0ba6fe671bc52b639616ef97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66eda67f0ba6fe671bc52b639616ef97">&#9670;&nbsp;</a></span>encode_cobs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte* &gt; &gt; emlabcpp::encode_cobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO: make this no inline. </p>
<p>Encodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer. Note that this does not store 0 at the end. </p>

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, <a class="el" href="namespaceemlabcpp.html#a1377f84042c48380be9118421fb97e6f">count()</a>, and <a class="el" href="classemlabcpp_1_1view.html#a307e340890bedc068c2cac28e2f86896">emlabcpp::view&lt; Iterator, EndIterator &gt;::end()</a>.</p>

</div>
</div>
<a id="afe935e56d6376df9f87d0d015a3baecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe935e56d6376df9f87d0d015a3baecc">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::enumerate </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip()</a>.</p>

</div>
</div>
<a id="ac1e0fe9ab6b7190faf578ec3e5f72301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e0fe9ab6b7190faf578ec3e5f72301">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container LhContainer, range_container RhContainer, typename BinaryPredicateCallable  = std::equal_to&lt; void &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::equal </td>
          <td>(</td>
          <td class="paramtype">const LhContainer &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhContainer &amp;&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::equal_to&lt;&#160;void&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if containers 'lh' and 'rh' has same size and calls to predicate <code>f</code> - <code>f(lh[i],rh[i])</code> return true for each item. </p>
<p>Default callable is equality. all 0 &lt;= i &lt; size() </p>

</div>
</div>
<a id="ae6a73bbed8b818abff4ab4e7c2b9af68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a73bbed8b818abff4ab4e7c2b9af68">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds first item in container 'cont' that is equal to 'item', returns iterator for container, or index for tuples. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>.</p>

</div>
</div>
<a id="adad2aaee725330a629c1fa9af8cf7e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2aaee725330a629c1fa9af8cf7e37">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator for first item, for which call to predicate f(*iter) holds true. </p>
<p>end() iterator is returned otherwise. The end() iterator is taken once, before the container is iterated. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="aae434316a87fef12fc4d05dd543dddf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae434316a87fef12fc4d05dd543dddf7">&#9670;&nbsp;</a></span>find_if_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename PredicateCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::find_if_index </td>
          <td>(</td>
          <td class="paramtype">const PredicateCallable &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N until first call that returns true. </p>
<p>Function returns the index on which predicate returned true. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a7a8e644a62f8747e59e7766ba811037a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8e644a62f8747e59e7766ba811037a">&#9670;&nbsp;</a></span>for_cross_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container LhContainer, container RhContainer, typename BinaryCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_cross_joint </td>
          <td>(</td>
          <td class="paramtype">const LhContainer &amp;&#160;</td>
          <td class="paramname"><em>lh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhContainer &amp;&#160;</td>
          <td class="paramname"><em>rh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies binary callable 'f(x,y)' to each combination of items <code>x</code> from <code>lh_cont</code> and <code>y</code> from <code>rh_cont</code> </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, and <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>.</p>

</div>
</div>
<a id="a685395cc470dfed697a40d2c718af4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685395cc470dfed697a40d2c718af4e9">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f' to each element of container 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a92a263e4623147eea2c226d8b9bcafc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a263e4623147eea2c226d8b9bcafc7">&#9670;&nbsp;</a></span>for_each_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename NullCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each_index </td>
          <td>(</td>
          <td class="paramtype">const NullCallable &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a070cde263f31325ae8cece3af6e7d23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070cde263f31325ae8cece3af6e7d23a">&#9670;&nbsp;</a></span>get_triangle_sphere_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::get_triangle_sphere_center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefc03fbfa97fbe6458f075c4be65ce33">cross_product()</a>, <a class="el" href="namespaceemlabcpp.html#aab2416235ee550b6758f4e804d71d612">normalized()</a>, <a class="el" href="namespaceemlabcpp.html#a1806b61b0659c26b8a0a53288ecfa313">point_cast()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="a4b323693e8d1a33bad5c12c63709fe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b323693e8d1a33bad5c12c63709fe3b">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::init </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips last item of container. </p>

</div>
</div>
<a id="a116807f9c41ac80621918fff7446c987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116807f9c41ac80621918fff7446c987">&#9670;&nbsp;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a4d9f2c9f70372883377a906c4ee7c8dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9f2c9f70372883377a906c4ee7c8dc">&#9670;&nbsp;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9b509189c2527a5023267e866b85d68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b509189c2527a5023267e866b85d68">&#9670;&nbsp;</a></span>inverse_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::inverse_transform </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a116807f9c41ac80621918fff7446c987">inverse()</a>, and <a class="el" href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">transform()</a>.</p>

</div>
</div>
<a id="a31c1cbc5b728494acb47daebb913fd96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c1cbc5b728494acb47daebb913fd96">&#9670;&nbsp;</a></span>joined()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, typename T , container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::joined </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function applies callable <code>f</code> to each item in container <code>cont</code> and contacts results with operator+, <code>val</code> is used as a separator between the items. </p>
<p>Returns <code>f(cont[0]) + val + f(cont[1]) + val + ... + val + f(cont[n]);</code>. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a254ed4de50fc497ac961253ac3625040">tail()</a>.</p>

</div>
</div>
<a id="a01057565d5ebaf62d92c2a45cfdde65b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01057565d5ebaf62d92c2a45cfdde65b">&#9670;&nbsp;</a></span>length2_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::length2_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns squared distance of A from [0,0,0], this is a squared length of vector represented by A. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum()</a>.</p>

</div>
</div>
<a id="aea33175760f7e4286188490bacd98ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea33175760f7e4286188490bacd98ac3">&#9670;&nbsp;</a></span>length_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::length_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distance of A from [0,0,0], this is a length of vector represented by A. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a01057565d5ebaf62d92c2a45cfdde65b">length2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="a1fe90ef4b53557e6198f75e4e3f0e86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe90ef4b53557e6198f75e4e3f0e86f">&#9670;&nbsp;</a></span>lin_interp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::lin_interp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear interpolation between base se and goal pose, with factor 0 'base' is returned, with factor 1 'goal' is returned. </p>
<p>With factor 0.5, pose between 'base' and 'goal' pose is returned </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, and <a class="el" href="namespaceemlabcpp.html#aeb2a793ecef21878567a88585e7f7b6b">slerp()</a>.</p>

</div>
</div>
<a id="a526b633aba78654db2ac46377bd5b2da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526b633aba78654db2ac46377bd5b2da">&#9670;&nbsp;</a></span>lin_interp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::lin_interp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a26e570f89d7f0975b1cff5b2ec8cd7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e570f89d7f0975b1cff5b2ec8cd7e3">&#9670;&nbsp;</a></span>lineary_interpolate_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &gt; emlabcpp::lineary_interpolate_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ipath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a51181e92ac66d2a113b7c0e5b9a2718e">distance_of()</a>, <a class="el" href="namespaceemlabcpp.html#a1fe90ef4b53557e6198f75e4e3f0e86f">lin_interp()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="aa68ddb76ca74c38e8582a5fa4180da7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68ddb76ca74c38e8582a5fa4180da7b">&#9670;&nbsp;</a></span>lineary_interpolate_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; emlabcpp::lineary_interpolate_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ipath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a51181e92ac66d2a113b7c0e5b9a2718e">distance_of()</a>, <a class="el" href="namespaceemlabcpp.html#a1fe90ef4b53557e6198f75e4e3f0e86f">lin_interp()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">steps()</a>.</p>

</div>
</div>
<a id="ae8555060e43c2b8cdd8d91bb248b9a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8555060e43c2b8cdd8d91bb248b9a6d">&#9670;&nbsp;</a></span>map_f()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultContainer emlabcpp::map_f </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls callable <code>f(x)</code> for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned. </p>
<p>The behavior depends on what kind of 'ResultContainer' is used, rules are in this order:</p><ol type="1">
<li>std::array is constructed and <code>res[i] = f(cont[i])</code> is used for i = 0...N</li>
<li>if 'ResultContainer' has <code>push_back(x)</code> method, that is used to insert result of calls to <code>f(x)</code></li>
<li><code>insert(x)</code> method is used to insert result of calls to <code>f(x)</code> </li>
</ol>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a1911a0fc83869772cacfc4d21772268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1911a0fc83869772cacfc4d21772268f">&#9670;&nbsp;</a></span>map_f_to_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; emlabcpp::map_f_to_a </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls callable <code>f(cont[i])</code> for i = 0...N and stores the result in array of an size N. </p>
<p>Calls callable f(cont[i]) for i = 0...N and stores the result in array of an appropiate size.</p>
<p>The function requires size 'N' as template parameter</p>
<p>THe size <code>N</code> is infered from container. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a0abef993d302d6b6d93fe877ca62491c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abef993d302d6b6d93fe877ca62491c">&#9670;&nbsp;</a></span>map_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;arithmetic_operators T, arithmetic_operators U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U emlabcpp::map_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps input value 'input' from input range to equivalent value in output range </p>

</div>
</div>
<a id="a57181a407fd6f29a50664f8ba4cb44cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57181a407fd6f29a50664f8ba4cb44cd">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="ab077da8cbabe4cc68820537ddc602b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab077da8cbabe4cc68820537ddc602b91">&#9670;&nbsp;</a></span>matcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structemlabcpp_1_1matcher.html">emlabcpp::matcher</a> </td>
          <td>(</td>
          <td class="paramtype">Callables &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82bc958527847885bdfc4005b22271e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82bc958527847885bdfc4005b22271e6">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with maximum value of one of the quantities. </p>

</div>
</div>
<a id="a8c784ba1275978f98555df83478109c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c784ba1275978f98555df83478109c8">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa144487d11d6484b636482caa35a1cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa144487d11d6484b636482caa35a1cf1">&#9670;&nbsp;</a></span>max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::max_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls. </p>
<p>Returns lowest value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, and <a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max()</a>.</p>

</div>
</div>
<a id="ab4db09819cc4cc5a21ed238dd2e30d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4db09819cc4cc5a21ed238dd2e30d6a">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with minimum value of one of the quantities. </p>

</div>
</div>
<a id="a5098342c4801b4a7d9ec75b1143f7801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5098342c4801b4a7d9ec75b1143f7801">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Derived&amp; emlabcpp::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaffd06a15a35e011691274cc98d14767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffd06a15a35e011691274cc98d14767">&#9670;&nbsp;</a></span>min_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::min_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x) to each element of container 'cont&lsquo;, returns the smallest return value of 'f(x)&rsquo; calls. </p>
<p>Returns maximum value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max()</a>, and <a class="el" href="namespaceemlabcpp.html#a5098342c4801b4a7d9ec75b1143f7801">min()</a>.</p>

</div>
</div>
<a id="a516fc25d05dfa6a69f022964b2a6a807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516fc25d05dfa6a69f022964b2a6a807">&#9670;&nbsp;</a></span>min_max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; emlabcpp::min_max_elem </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x)' to each element of container 'cont', returns the largest and the smallest return value. </p>
<p>of 'f(x)' calls. Returns the default value of the 'f(x)' return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, <a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max()</a>, <a class="el" href="namespaceemlabcpp.html#a5098342c4801b4a7d9ec75b1143f7801">min()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a638fe803e243841625659a697eb71463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638fe803e243841625659a697eb71463">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::none_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns false for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a2d80507cffdd192a333f6bd9c272e97a">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="af6fc2eeaf683b868d3ec7eed8fe6f69a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fc2eeaf683b868d3ec7eed8fe6f69a">&#9670;&nbsp;</a></span>norm2_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::norm2_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>.</p>

</div>
</div>
<a id="ac42832216d185dc06feea7414a0318c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42832216d185dc06feea7414a0318c7">&#9670;&nbsp;</a></span>normal_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr vec&lt; 3 &gt; emlabcpp::normal_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefc03fbfa97fbe6458f075c4be65ce33">cross_product()</a>.</p>

</div>
</div>
<a id="ac699c992dfb572a61d18dde2a4c302a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac699c992dfb572a61d18dde2a4c302a8">&#9670;&nbsp;</a></span>normal_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; emlabcpp::normal_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a normal to a point A in two dimensions. </p>

</div>
</div>
<a id="aab2416235ee550b6758f4e804d71d612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2416235ee550b6758f4e804d71d612">&#9670;&nbsp;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::normalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates normalized version of A, this means that length(A) equals to 1. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aea33175760f7e4286188490bacd98ac3">length_of()</a>.</p>

</div>
</div>
<a id="a45f2745b15d83802490aa46fc8e25102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f2745b15d83802490aa46fc8e25102">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>negation of operator== between poses </p>

</div>
</div>
<a id="a5a114fd45fa6f5d2994e375e6863c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a114fd45fa6f5d2994e375e6863c00c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7a44460972cfa981d6af54caba9f8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a44460972cfa981d6af54caba9f8b2">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afaabfb4832972f3f9c7589a82ac8ac4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaabfb4832972f3f9c7589a82ac8ac4f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa5569071253ac2623f7130fd1ff9d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5569071253ac2623f7130fd1ff9d3a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d7465ddd19bb5f2eaa845a6cc78b8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7465ddd19bb5f2eaa845a6cc78b8e0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a163dd8154f05ef8a818183d0d44cbcdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a163dd8154f05ef8a818183d0d44cbcdc">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abecbf2e7b498f7c5d2eb3985f198547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecbf2e7b498f7c5d2eb3985f198547f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa82c713fbe2af2876043efec81216254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa82c713fbe2af2876043efec81216254">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ddf667e5164035a1b42febb28df6dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddf667e5164035a1b42febb28df6dda">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a244aa2b00962ce96249bb72e5d07b0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244aa2b00962ce96249bb72e5d07b0c1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const ValueType&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="a6aaf966cca60b8622ed6758c976a4a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaf966cca60b8622ed6758c976a4a69">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a384e4bb5a921ff231358ff63aeecbe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384e4bb5a921ff231358ff63aeecbe77">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together. </p>

</div>
</div>
<a id="a63fe2550fd1fae3aab0b4791d8e58efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fe2550fd1fae3aab0b4791d8e58efa">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of points multiplies each coordinate of A by coordinate of B on same dimension. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a9a1b0db510277c2522d504eabc6821e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1b0db510277c2522d504eabc6821e3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of quantity by it's value_type. </p>

</div>
</div>
<a id="aa2c6dcc7bdeae73e7695e529b2a542c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c6dcc7bdeae73e7695e529b2a542c9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

</div>
</div>
<a id="a853e4e996373808d81cd415c60aecd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853e4e996373808d81cd415c60aecd55">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a57aae6e5cd5a893e35a12622960dc79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57aae6e5cd5a893e35a12622960dc79b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of addition a to b, viz += operator. </p>

</div>
</div>
<a id="a37fb61edcdf95a5c2fc63e29d2431946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fb61edcdf95a5c2fc63e29d2431946">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="aebffc4f0df356683a2b9b2a595e90e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebffc4f0df356683a2b9b2a595e90e40">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a90457babf1c49444a526a98007a751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a90457babf1c49444a526a98007a751">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afc235c95c20406e05b11a433e3ed7857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc235c95c20406e05b11a433e3ed7857">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides negation of the quantity. </p>

</div>
</div>
<a id="aa3c4e6187b766c3b0fcfb4721228f5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c4e6187b766c3b0fcfb4721228f5d9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65d491045b619755db02e72cfa69e772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d491045b619755db02e72cfa69e772">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of subtraction of A from B, viz -= operator. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="a57cf7c57e3d0c20cf08c0f4562e32fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cf7c57e3d0c20cf08c0f4562e32fe9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of subtraction a to b, viz += operator. </p>

</div>
</div>
<a id="a7ec5f53bd49815db80874c10f4742f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec5f53bd49815db80874c10f4742f92">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="a1e7c3c010fa2b7cffe9478558c1d9df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7c3c010fa2b7cffe9478558c1d9df6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ValueType emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype">const ValueType&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="ad8bf364734336953acece2da91f7cd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bf364734336953acece2da91f7cd5a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a1fdcd2bf6efc13dd21e3298c777d4982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdcd2bf6efc13dd21e3298c777d4982">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted. </p>

</div>
</div>
<a id="a0176bf0d3582d8fa997f2ae98869d099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0176bf0d3582d8fa997f2ae98869d099">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of quantity by it's value_type. </p>

</div>
</div>
<a id="a1c42d6c592410c5073ecfb18431a4d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c42d6c592410c5073ecfb18431a4d04">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const LhValueType&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides abillity to compare quantity with non-quantity arithmetic value. </p>

</div>
</div>
<a id="a0b460db38cf4162f2102f01e6f42616c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b460db38cf4162f2102f01e6f42616c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a49a18ed069c328b94893a379a85d855f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a18ed069c328b94893a379a85d855f">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhValueType&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides abillity to compare quantity with non-quantity arithmetic value. </p>

</div>
</div>
<a id="a3969b7ad5f8da7ae8d8c01fd2a0909f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3969b7ad5f8da7ae8d8c01fd2a0909f6">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a37668b1023850f199c917bcf2131523c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37668b1023850f199c917bcf2131523c">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="add7921925c77c6350a91d55d9471bdc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add7921925c77c6350a91d55d9471bdc1">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add2749663d773cccf70a46c26fafb132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2749663d773cccf70a46c26fafb132">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2254b75f92599473cee7451ded051a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2254b75f92599473cee7451ded051a0e">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#af6923c24f500869e457a4ca7f2fb9426">emlabcpp::static_circular_buffer&lt; T, N &gt;::begin()</a>, and <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#aa8165951ae18e5a305ee580be7c749d4">emlabcpp::static_circular_buffer&lt; T, N &gt;::end()</a>.</p>

</div>
</div>
<a id="a640640991a3cfee97b11ab4df8759583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640640991a3cfee97b11ab4df8759583">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae905e83f27246077252ae1308f0fda07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae905e83f27246077252ae1308f0fda07">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compares poses on their position and orientation </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a027de18cdf34aaf5bf22b05130b6c208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027de18cdf34aaf5bf22b05130b6c208">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa32193fca8f431c8887d0a5402866074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32193fca8f431c8887d0a5402866074">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac1e0fe9ab6b7190faf578ec3e5f72301">equal()</a>.</p>

</div>
</div>
<a id="abe4e80e0e361283130d83856b68f4e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4e80e0e361283130d83856b68f4e6d">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#a4a90f093a980231b0156e8ed33c6e1f1">emlabcpp::static_circular_buffer&lt; T, N &gt;::size()</a>.</p>

</div>
</div>
<a id="accaccb739b9336c5bd977ad988c3d336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaccb739b9336c5bd977ad988c3d336">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a541f323f095107eec70dbb1db1387711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541f323f095107eec70dbb1db1387711">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1view.html#a307e340890bedc068c2cac28e2f86896">emlabcpp::view&lt; Iterator, EndIterator &gt;::end()</a>, and <a class="el" href="classemlabcpp_1_1view.html#af2e8f0748de03d25eb586ef4fbe0bb13">emlabcpp::view&lt; Iterator, EndIterator &gt;::size()</a>.</p>

</div>
</div>
<a id="a78453f63bffe0ddbe927529c68875dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78453f63bffe0ddbe927529c68875dc4">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8345b253a90bb775245754b4e6307216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8345b253a90bb775245754b4e6307216">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b0c8873bbc692d1700c0f3a5603d620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b0c8873bbc692d1700c0f3a5603d620">&#9670;&nbsp;</a></span>point_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::point_angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#af1646f426f259ab7e7f8d4ebbb1f5a4f">vector_angle()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="a1806b61b0659c26b8a0a53288ecfa313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1806b61b0659c26b8a0a53288ecfa313">&#9670;&nbsp;</a></span>point_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; emlabcpp::point_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b9eb800885b61e8071ef11e69debdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9eb800885b61e8071ef11e69debdf6">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power of physical quantity is power of root of it's value and the exponents are multiplied by the value. </p>

</div>
</div>
<a id="a8bf06ccbfbc6633b4244c7295fdc98cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf06ccbfbc6633b4244c7295fdc98cf">&#9670;&nbsp;</a></span>pretty_print_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structemlabcpp_1_1buffer__writer.html">buffer_writer</a>&lt; N &gt; emlabcpp::pretty_print_buffer </td>
          <td>(</td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea91805d160a2eda9dfc9f0f29477351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea91805d160a2eda9dfc9f0f29477351">&#9670;&nbsp;</a></span>pretty_print_serialize_basic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Writer , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::pretty_print_serialize_basic </td>
          <td>(</td>
          <td class="paramtype">Writer &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcb43f873b880adf7247a54e0d0b4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb43f873b880adf7247a54e0d0b4a03">&#9670;&nbsp;</a></span>pretty_stream_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; emlabcpp::pretty_stream_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a> auto &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Ts &amp;...&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b62f09ff5468bc513cac30ace3d6c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b62f09ff5468bc513cac30ace3d6c58">&#9670;&nbsp;</a></span>pretty_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::pretty_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr  />
<p> / central function for returning name of type that can demangle if necessary </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="acf5a156c767ed17a892cc7e9b5acd2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5a156c767ed17a892cc7e9b5acd2b1">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [from, to) </p>

</div>
</div>
<a id="ace588590ccd59087b704005a3c04caae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace588590ccd59087b704005a3c04caae">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [0, to) </p>

</div>
</div>
<a id="aab6fd32a8b3335eec93b94331d4293b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fd32a8b3335eec93b94331d4293b0">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns index of an element in tuple 't', for which call to predicate f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, and <a class="el" href="namespaceemlabcpp_1_1impl.html#a502794f0cc63c9d3399dfcedd60bd48e">emlabcpp::impl::find_if_impl()</a>.</p>

</div>
</div>
<a id="a670099942b8cdd3d2cc28760b1717d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670099942b8cdd3d2cc28760b1717d7c">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies unary callable 'f' to each element of container 'cont'. </p>

</div>
</div>
<a id="a35de9105fe961a808d8e0f3a2cb58bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35de9105fe961a808d8e0f3a2cb58bf2">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!requires(Callable <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function expectes bounded value as index input and callable. </p>
<p>Based on the value of index, <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> is called with template argument <code>std::size_t</code> with internal value of provided index. Expectes the bounded value to be valid (that is within the range) </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a8d77f50ca9dd31e43365e38debbd42fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d77f50ca9dd31e43365e38debbd42fa">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a512f1fd6d6a6aa3d5094088865158e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512f1fd6d6a6aa3d5094088865158e23">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like LH, matrix_like RH&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">LH::rows&#160;</td>
          <td class="paramname"> = <code>=RH::rows&#160;&amp;&amp;LH::cols==RH::cols</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="af82d48e74c20cfcb88f46dd2ba5688b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82d48e74c20cfcb88f46dd2ba5688b9">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2 &amp;&amp;M::cols&#160;</td>
          <td class="paramname"> = <code>=&#160;M::rows</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="ae9679354218890ed9c289c674a125378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9679354218890ed9c289c674a125378">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname"> = <code>=&#160;1&#160;&amp;&amp;&#160;M::cols&#160;==&#160;1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="ac4ee7e0f160b1450636b4a460f27e18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ee7e0f160b1450636b4a460f27e18a">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname"> = <code>=&#160;2&#160;&amp;&amp;&#160;M::cols&#160;==&#160;2</code></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dcd56ce6fdffb4ebcf8a4c079335d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd56ce6fdffb4ebcf8a4c079335d8e">&#9670;&nbsp;</a></span>requires() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint16_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac39ed97224e397106e08c6e04012e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39ed97224e397106e08c6e04012e62a">&#9670;&nbsp;</a></span>requires() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint32_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2acb59e904f4530e0e8d42e98f67bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acb59e904f4530e0e8d42e98f67bcaa">&#9670;&nbsp;</a></span>requires() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint64_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd74c7df9ccef5ce376d2c3fe2ef8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd74c7df9ccef5ce376d2c3fe2ef8908">&#9670;&nbsp;</a></span>requires() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint8_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;N</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39bdb9e4992c495c755d900b23435840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bdb9e4992c495c755d900b23435840">&#9670;&nbsp;</a></span>requires() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">std::is_enum_v&lt; Enum &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string-like name of the enum value <code>val</code> </p>

</div>
</div>
<a id="abed05683098f9a93c5b694ff9b9f3c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed05683098f9a93c5b694ff9b9f3c16">&#9670;&nbsp;</a></span>requires() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">std::is_enum_v&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53a54421dadf3639047daa6aab4fc470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a54421dadf3639047daa6aab4fc470">&#9670;&nbsp;</a></span>requires() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">std::is_pointer_v&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620a32406486ae5b889d41d446c4a8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620a32406486ae5b889d41d446c4a8b0">&#9670;&nbsp;</a></span>reset_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">consteval std::string_view emlabcpp::reset_color </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fe2d2bf491db344cf04e4c2b9d799b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2d2bf491db344cf04e4c2b9d799b8">&#9670;&nbsp;</a></span>reversed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::reversed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype( std::rbegin( <a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a> ) ) &gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns view to the Container in reverse order. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>.</p>

</div>
</div>
<a id="a8f930afac742df6f8f0ace5d9c220508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f930afac742df6f8f0ace5d9c220508">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a116807f9c41ac80621918fff7446c987">inverse()</a>.</p>

</div>
</div>
<a id="a585ac88872a7d3a671951eba53e721de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ac88872a7d3a671951eba53e721de">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pose X is rotated based on quaternion 'quad'. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="af9602763edb5f01eed83307c5c63ad73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9602763edb5f01eed83307c5c63ad73">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a116807f9c41ac80621918fff7446c987">inverse()</a>.</p>

</div>
</div>
<a id="ae94e0bd03b2708f3260f665730929fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94e0bd03b2708f3260f665730929fb1">&#9670;&nbsp;</a></span>rotate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1806b61b0659c26b8a0a53288ecfa313">point_cast()</a>, <a class="el" href="namespaceemlabcpp.html#a585ac88872a7d3a671951eba53e721de">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="abdcc7c52513935a9585f1b633244cd4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdcc7c52513935a9585f1b633244cd4c">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; N &gt; emlabcpp::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>scales</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22bdba517ae1cfa5e6b4f2e54e407bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bdba517ae1cfa5e6b4f2e54e407bb1">&#9670;&nbsp;</a></span>select_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">i&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[&amp;res, &amp;f] &lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();}&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="ab1e2e3e15b0c77fff6674ed7e6e1f67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e2e3e15b0c77fff6674ed7e6e1f67e">&#9670;&nbsp;</a></span>select_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Callable &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="af502c46ab09d85973cfcaaf05be835ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502c46ab09d85973cfcaaf05be835ac">&#9670;&nbsp;</a></span>shortest_arc_quat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::shortest_arc_quat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefc03fbfa97fbe6458f075c4be65ce33">cross_product()</a>, <a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>, <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, <a class="el" href="namespaceemlabcpp.html#aab2416235ee550b6758f4e804d71d612">normalized()</a>, <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="a1aef6c41e29219cbbc8538767c0e1f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aef6c41e29219cbbc8538767c0e1f0e">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int emlabcpp::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sign of variable T: -1,0,1 </p>

</div>
</div>
<a id="aa3d3eb598a75856181b79136ed06dbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d3eb598a75856181b79136ed06dbd8">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sinus of the quantity as scalar. </p>

</div>
</div>
<a id="aeb2a793ecef21878567a88585e7f7b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2a793ecef21878567a88585e7f7b6b">&#9670;&nbsp;</a></span>slerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::slerp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa86203b42f9478701d1f52443d5729a3">angle_shortest_path()</a>, <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, and <a class="el" href="namespaceemlabcpp.html#aa3d3eb598a75856181b79136ed06dbd8">sin()</a>.</p>

</div>
</div>
<a id="a5519896c5f0324265089711b6a020642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5519896c5f0324265089711b6a020642">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square root of physical quantity is square root of it's value and the exponents are divided in half. </p>

</div>
</div>
<a id="a69c59e260f99791d626a9665243323d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c59e260f99791d626a9665243323d0">&#9670;&nbsp;</a></span>stem_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">consteval std::string_view emlabcpp::stem_of </td>
          <td>(</td>
          <td class="paramtype">const std::string_view&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a95b7c5f71b2d2128143bbd09bc6cb341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b7c5f71b2d2128143bbd09bc6cb341">&#9670;&nbsp;</a></span>steps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dist_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns steps necessary for linear interpolation of distance between poses 'dis', such that: </p>
<ul>
<li>the number of steps is minimized</li>
<li>space distance between interpolated poses is smaller than dist_step</li>
<li>angle distance between interpolated poses is smaller than angle_step </li>
</ul>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a86cfd1cc45e85428b1d42ea979b19b7e">emlabcpp::pose_distance::angle_dist</a>, <a class="el" href="namespaceemlabcpp.html#a746c782172b5cd06a357056a324f437b">emlabcpp::pose_distance::dist</a>, and <a class="el" href="namespaceemlabcpp.html#a8c784ba1275978f98555df83478109c8">max()</a>.</p>

</div>
</div>
<a id="ad5a26f7af9b55c2f2728eb7c5687b2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a26f7af9b55c2f2728eb7c5687b2c1">&#9670;&nbsp;</a></span>string_serialize_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename EndIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::string_serialize_view </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator, EndIterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac813ec118aa63294f4ed7955f389e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac813ec118aa63294f4ed7955f389e289">&#9670;&nbsp;</a></span>subscript_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1subscript__iterator.html">iterators::subscript_iterator</a>&lt; Container &gt; &gt; emlabcpp::subscript_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5fde2ce524bee976e0c6c74c0be2917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fde2ce524bee976e0c6c74c0be2917">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::sum </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item. </p>

</div>
</div>
<a id="a66b48062894b569667fa98dbf5ceeeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b48062894b569667fa98dbf5ceeeae">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a254ed4de50fc497ac961253ac3625040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254ed4de50fc497ac961253ac3625040">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::tail </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips first item of container. </p>

</div>
</div>
<a id="a0fdc7d913ad6f5537d3c78d1fe0518dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdc7d913ad6f5537d3c78d1fe0518dd">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1min__max.html#a8b3d9b948aeacf4261611ee2fc26eb64">emlabcpp::min_max&lt; T &gt;::max</a>, <a class="el" href="structemlabcpp_1_1min__max.html#ac4cc0b5a0f2485f3524e3cf74500407a">emlabcpp::min_max&lt; T &gt;::min</a>, and <a class="el" href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">transform()</a>.</p>

</div>
</div>
<a id="a0cc504832a0c2ee50c85b216971c170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc504832a0c2ee50c85b216971c170a">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point A is rotated based on 'transformation' orientation and than moved based on 'transformation' position. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, <a class="el" href="namespaceemlabcpp.html#a585ac88872a7d3a671951eba53e721de">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="ae6416b91bd33ea2a47540c131ba789fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6416b91bd33ea2a47540c131ba789fe">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pose X is rotated based on 'transformation' orientation and than moved based on 'transformation' position. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, and <a class="el" href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">transform()</a>.</p>

</div>
</div>
<a id="a080e14602b2565d26cb92bff4c637ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a080e14602b2565d26cb92bff4c637ad5">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a0cc504832a0c2ee50c85b216971c170a">transform()</a>.</p>

</div>
</div>
<a id="a61331372de6b7c1f226a19df31b820bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61331372de6b7c1f226a19df31b820bc">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, <a class="el" href="namespaceemlabcpp.html#a585ac88872a7d3a671951eba53e721de">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#a3cfa63f3a0229b43ff56952dbb4e191f">vector_cast()</a>.</p>

</div>
</div>
<a id="acd8a44534f893fb67e883a5a8b396ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8a44534f893fb67e883a5a8b396ef4">&#9670;&nbsp;</a></span>trim_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt; emlabcpp::trim_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items. </p>
<p>This can be used to get the dataset without first/last 5% for example, by using r=0.1 </p>

</div>
</div>
<a id="aa8b8f5742901528282a9da6b8317e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b8f5742901528282a9da6b8317e7b5">&#9670;&nbsp;</a></span>tuple_zip_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::tuple_zip_impl </td>
          <td>(</td>
          <td class="paramtype">TuplesTuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tpls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; ItemIndexes... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; TupleIndexes... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="aced106ff9e1a26187bb4872197cc1a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced106ff9e1a26187bb4872197cc1a7c">&#9670;&nbsp;</a></span>until_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, typename PredicateCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::until_index </td>
          <td>(</td>
          <td class="paramtype">const PredicateCallable &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes predicate <code><a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true. </p>
<p>Function returns whenever the <code>f</code> was called or not. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>.</p>

</div>
</div>
<a id="a7bb8b8ced9bb2a501cc61ced29e7801d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb8b8ced9bb2a501cc61ced29e7801d">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float emlabcpp::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeType&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this reularly, the meaning of time value 'now' is up to you, just be consistent. </p>
<p>Algorithm changes it's internal value output to the value that should be set to a 'thing' that controls measured_ value. It tries to control the 'thing' so the measured eventually converges to 'desired' value</p>
<p>improvements from naive PID:</p><ul>
<li>we work with derivation of measured, not error (error jumps in case you change desired value a lot)</li>
<li>we store i_sum entirely (i * sum_) instead of just the sum_, makes it easier to change the scale of i (imagine what happens when you store sum_, use i*sum_ in the formula nad change i from 1 to 100) </li>
</ul>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="namespaceemlabcpp.html#a096dcb0c9bf6af343c832bebada97419">emlabcpp::pid_config::coefficients</a>, <a class="el" href="namespaceemlabcpp.html#a655b9d57207a6513eefd69f5099fdae2">emlabcpp::pid_coefficients::d</a>, <a class="el" href="namespaceemlabcpp.html#a99ba17ee27bed7c782d9364b7b614eae">emlabcpp::pid_coefficients::i</a>, <a class="el" href="structemlabcpp_1_1pid.html#aea36c0fe6d20f767789035378d57fb44">emlabcpp::pid&lt; TimeType &gt;::i_sum</a>, <a class="el" href="structemlabcpp_1_1pid.html#aaeebf0506e1b2d30502abdfa3e33073a">emlabcpp::pid&lt; TimeType &gt;::last_measured</a>, <a class="el" href="structemlabcpp_1_1pid.html#ab22ac70cb2ecdfe8cdd3d4498695ab10">emlabcpp::pid&lt; TimeType &gt;::last_time</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, <a class="el" href="structemlabcpp_1_1min__max.html#a8b3d9b948aeacf4261611ee2fc26eb64">emlabcpp::min_max&lt; T &gt;::max</a>, <a class="el" href="structemlabcpp_1_1min__max.html#ac4cc0b5a0f2485f3524e3cf74500407a">emlabcpp::min_max&lt; T &gt;::min</a>, <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>, and <a class="el" href="namespaceemlabcpp.html#ac0b0048d94d97cc9884974fe74898b69">emlabcpp::pid_coefficients::p</a>.</p>

</div>
</div>
<a id="aadc080f9334a6fec6101a6d803f7cb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc080f9334a6fec6101a6d803f7cb28">&#9670;&nbsp;</a></span>update_limits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::update_limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="structemlabcpp_1_1pid.html#aea36c0fe6d20f767789035378d57fb44">emlabcpp::pid&lt; TimeType &gt;::i_sum</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, <a class="el" href="structemlabcpp_1_1min__max.html#a8b3d9b948aeacf4261611ee2fc26eb64">emlabcpp::min_max&lt; T &gt;::max</a>, <a class="el" href="structemlabcpp_1_1min__max.html#ac4cc0b5a0f2485f3524e3cf74500407a">emlabcpp::min_max&lt; T &gt;::min</a>, and <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>.</p>

</div>
</div>
<a id="ac578d4bcbce0973184093fa8cce2da33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac578d4bcbce0973184093fa8cce2da33">&#9670;&nbsp;</a></span>update_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::update_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, <a class="el" href="structemlabcpp_1_1min__max.html#a8b3d9b948aeacf4261611ee2fc26eb64">emlabcpp::min_max&lt; T &gt;::max</a>, <a class="el" href="structemlabcpp_1_1min__max.html#ac4cc0b5a0f2485f3524e3cf74500407a">emlabcpp::min_max&lt; T &gt;::min</a>, and <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>.</p>

</div>
</div>
<a id="a76870aafe8a72795ca80143c32313532"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76870aafe8a72795ca80143c32313532">&#9670;&nbsp;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::variance </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call. </p>
<p>The <code>f</code> is applied twice to each element. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aeb03fae2e4aecd67b1f163e1ab523e89">avg()</a>, <a class="el" href="namespaceemlabcpp.html#a631eb361805aa7459b944503f7538951">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#ad5fde2ce524bee976e0c6c74c0be2917">sum()</a>.</p>

</div>
</div>
<a id="af1646f426f259ab7e7f8d4ebbb1f5a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1646f426f259ab7e7f8d4ebbb1f5a4f">&#9670;&nbsp;</a></span>vector_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::vector_angle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a8e3cab8faa406c3fc0e6c197d7663f12">dot()</a>, <a class="el" href="namespaceemlabcpp.html#a01057565d5ebaf62d92c2a45cfdde65b">length2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="a3cfa63f3a0229b43ff56952dbb4e191f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfa63f3a0229b43ff56952dbb4e191f">&#9670;&nbsp;</a></span>vector_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; N &gt; emlabcpp::vector_cast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b726ddab4f550f3e186f177243cb09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b726ddab4f550f3e186f177243cb09b">&#9670;&nbsp;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">emlabcpp::view</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The container deduction guide uses iterator_of_t. </p>

</div>
</div>
<a id="a57c2da6250c29d0cf3d6a0cfecaa1e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c2da6250c29d0cf3d6a0cfecaa1e45">&#9670;&nbsp;</a></span>view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt; emlabcpp::view_n </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range! </p>

</div>
</div>
<a id="a6e4b7b6dd8a3a27f7f7bcea52f265b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplementation of <code>std::visit</code>. </p>
<p>This one trades worse complexity (linear) in favor of less assembly generated. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1b8d699d3167f848b3eb1e6d49dd2d20">visit_index()</a>.</p>

</div>
</div>
<a id="a1b8d699d3167f848b3eb1e6d49dd2d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8d699d3167f848b3eb1e6d49dd2d20">&#9670;&nbsp;</a></span>visit_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::visit_index </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Variant &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp_1_1detail.html#ae62a62600226a000600fed5337655cbc">emlabcpp::detail::linear_index_visit_impl()</a>.</p>

</div>
</div>
<a id="a6189ac849a51ae66a922cd84c9af8254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6189ac849a51ae66a922cd84c9af8254">&#9670;&nbsp;</a></span>volume_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::volume_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; N &gt;, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a306420110ac2a2a1ecc364e0053c1e30">abs()</a>, <a class="el" href="namespaceemlabcpp.html#af85136552afa4d0a86dd1fb078223cdd">copy()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="classemlabcpp_1_1simplex.html#a1d4f76faf3b981d25919fdfd3f7c21da">emlabcpp::simplex&lt; Item, N &gt;::size()</a>.</p>

</div>
</div>
<a id="a41ab261a0f296f3c9862e59e12339885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ab261a0f296f3c9862e59e12339885">&#9670;&nbsp;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a view of zip iterators for specified containers. </p>
<p>Beware that the function does not check that containers have same size of ranges. If the size differs, increments of begin iterator will never equal to the end iterator. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view()</a>.</p>

</div>
</div>
<a id="a81d4ae07c2d875b52377456faf19fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d4ae07c2d875b52377456faf19fe92">&#9670;&nbsp;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Tuple, gettable_container... Tuples&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>frst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuples &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tpls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips a set of gettable containers of same size into a tuples. </p>
<p>zip(tuple&lt;A,B&gt;(), tuple&lt;C,D&gt;()) -&gt; tuple&lt;tuple&lt;A,C&gt;, &lt;tuple&lt;B,d&gt;&gt;; </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5a66cad0d4226d39ffd692e16bcfc076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a66cad0d4226d39ffd692e16bcfc076">&#9670;&nbsp;</a></span>alternative_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::alternative_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []&lt; <span class="keyword">typename</span>... Ts &gt;( std::variant&lt; Ts... &gt;* ) {</div>
<div class="line">        <span class="keywordflow">return</span> ( std::same_as&lt; T, Ts &gt; || ... );</div>
<div class="line">}( <span class="keyword">static_cast&lt;</span> Variant* <span class="keyword">&gt;</span>( nullptr ) )</div>
</div><!-- fragment -->
<p>Thanks for the solution goes to PJBoy@libera. </p>

</div>
</div>
<a id="ae5e4923a149af384640fe5d3759dcc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e4923a149af384640fe5d3759dcc9a">&#9670;&nbsp;</a></span>are_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::are_same_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a61e7321a7721894fde42b2da9bf2cbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7321a7721894fde42b2da9bf2cbd8">&#9670;&nbsp;</a></span>arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70c87fb6240fb7ebbfbb27d7b25b999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70c87fb6240fb7ebbfbb27d7b25b999">&#9670;&nbsp;</a></span>arithmetic_assignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_assignment</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, T b ) {</div>
<div class="line">                                        {</div>
<div class="line">                                                a += b</div>
<div class="line">                                        };</div>
<div class="line">                                        {</div>
<div class="line">                                                a -= b</div>
<div class="line">                                        };</div>
<div class="line">                                        {</div>
<div class="line">                                                a /= b</div>
<div class="line">                                        };</div>
<div class="line">                                        {</div>
<div class="line">                                                a *= b</div>
<div class="line">                                        };</div>
<div class="line">                                }</div>
<div class="ttc" id="anamespaceemlabcpp_1_1impl_html_aa391ac6fa79be363f91ee9cbe2e4c578"><div class="ttname"><a href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">emlabcpp::impl::requires</a></div><div class="ttdeci">requires(!range_container&lt; Container &gt;) std</div><div class="ttdef"><b>Definition:</b> impl.h:78</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5494e6f6f24a2fd7e7ccfaecb31944b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5494e6f6f24a2fd7e7ccfaecb31944b3">&#9670;&nbsp;</a></span>arithmetic_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_like = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94924279b38cf1803ee0f01cb4889b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94924279b38cf1803ee0f01cb4889b24">&#9670;&nbsp;</a></span>arithmetic_operators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, T b ) {</div>
<div class="line">                                       {</div>
<div class="line">                                               a + b</div>
<div class="line">                                               } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">                                       {</div>
<div class="line">                                               a - b</div>
<div class="line">                                               } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">                                       {</div>
<div class="line">                                               a / b</div>
<div class="line">                                               } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">                                       {</div>
<div class="line">                                               a* b</div>
<div class="line">                                               } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">                               }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b5a68de4881301e46697c48654d8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a68de4881301e46697c48654d8477">&#9670;&nbsp;</a></span>bounded_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::bounded_constant = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, N, N &gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple type alias for bounded index constants. </p>

</div>
</div>
<a id="add79493bcf07bd4c54afffe3a0f3ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add79493bcf07bd4c54afffe3a0f3ee00">&#9670;&nbsp;</a></span>bounded_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::bounded_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#aa15d5c022409d351cd45334d7501dc72">detail::bounded_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept that matchestype deriving from bounded. </p>

</div>
</div>
<a id="ac6a5e3253aa7ea8bcd6574b3274c74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5e3253aa7ea8bcd6574b3274c74b6">&#9670;&nbsp;</a></span>container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeb742c691973ef2d34b0ace4d8eef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb742c691973ef2d34b0ace4d8eef15">&#9670;&nbsp;</a></span>container_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryCallable , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container_invocable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> ) { <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>( *cont.begin() ); } ||</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont ) { std::tuple_size&lt; std::decay_t&lt; Container &gt; &gt;::value == 0; } ||</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> ) {</div>
<div class="line">            </div>
<div class="line">            <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>( std::get&lt; 0 &gt;( cont ) );</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceemlabcpp_html_a6aa7db523ecb529a3835ce0f1175fb4c"><div class="ttname"><a href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">emlabcpp::f</a></div><div class="ttdeci">UnaryCallable &amp;&amp; f</div><div class="ttdef"><b>Definition:</b> algorithm.h:166</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_ac1cdce6706f4b40d478521925ca85f8a"><div class="ttname"><a href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">emlabcpp::UnaryCallable</a></div><div class="ttdeci">UnaryCallable</div><div class="ttdef"><b>Definition:</b> types.h:50</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a040c9fa2d6c0e4a28649479052ad8f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040c9fa2d6c0e4a28649479052ad8f8d">&#9670;&nbsp;</a></span>DEBUG_LOGGER_COLORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a> emlabcpp::DEBUG_LOGGER_COLORS = { .time = &quot;250&quot;, .file = &quot;252&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;248&quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a771ceb5d56ed0208c7974b576c6dadc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771ceb5d56ed0208c7974b576c6dadc0">&#9670;&nbsp;</a></span>decomposable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::decomposable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::is_class_v&lt; std::decay_t&lt; T &gt; &gt; &amp;&amp; !</div>
<div class="line">gettable_container&lt; T &gt; &amp;&amp; ( detail::decompose_count&lt; T &gt;() &gt;= 0 )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6adfccd266cb01c6cfd376ea222c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6adfccd266cb01c6cfd376ea222c110">&#9670;&nbsp;</a></span>decomposable_0</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::decomposable_0 = <a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a>&lt; T &gt; &amp;&amp; ( <a class="el" href="namespaceemlabcpp_1_1detail.html#a10e61621464f2e4cc1316387d1b70b19">detail::decompose_count</a>&lt; T &gt;() == 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20db02f115d34db629106a39c5194e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db02f115d34db629106a39c5194e18">&#9670;&nbsp;</a></span>default_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::default_epsilon = 1.19e-07<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a459242c17dfd40402115fe8a63d21622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a459242c17dfd40402115fe8a63d21622">&#9670;&nbsp;</a></span>either_uniquely_right_item</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename LH , typename RH &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::either_uniquely_right_item</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::same_as&lt; std::decay_t&lt; T &gt;, RH &gt; &amp;&amp; !</div>
<div class="line">std::same_as&lt; LH, RH &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3895ca2fd367021e74c1915f724c0242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3895ca2fd367021e74c1915f724c0242">&#9670;&nbsp;</a></span>element_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::element_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []&lt; <span class="keyword">typename</span>... Ts &gt;( std::tuple&lt; Ts... &gt;* ) {</div>
<div class="line">        <span class="keywordflow">return</span> ( std::same_as&lt; T, Ts &gt; || ... );</div>
<div class="line">}( <span class="keyword">static_cast&lt;</span> Tuple* <span class="keyword">&gt;</span>( nullptr ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa04c4ddd773c5ae47bf78d051770a30a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa04c4ddd773c5ae47bf78d051770a30a">&#9670;&nbsp;</a></span>ERROR_LOGGER_COLORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a> emlabcpp::ERROR_LOGGER_COLORS = { .time = &quot;196&quot;, .file = &quot;197&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;198&quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6aa7db523ecb529a3835ce0f1175fb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa7db523ecb529a3835ce0f1175fb4c">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Callable &amp; emlabcpp::f</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        std::apply(</div>
<div class="line">            [&amp;<a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>]&lt; <span class="keyword">typename</span>... Items &gt;( Items&amp;&amp;... items ) {</div>
<div class="line">                    ( <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>( std::forward&lt; Items &gt;( items ) ), ... );</div>
<div class="line">            },</div>
<div class="line">            std::forward&lt; Container &gt;( cont ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb54eee14fc87e50de7f6ed35ad1aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54eee14fc87e50de7f6ed35ad1aba0">&#9670;&nbsp;</a></span>gettable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::gettable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) {</div>
<div class="line">                                     {</div>
<div class="line">                                             std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value</div>
<div class="line">                                             } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">                             }</div>
</div><!-- fragment -->
</div>
</div>
<a id="adaca063c7275419f3999bd854c88de3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca063c7275419f3999bd854c88de3d">&#9670;&nbsp;</a></span>has_static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::has_static_size_v = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr  />
<p> has_static_size&lt;T&gt;::value is true in case type T have size deduceable at compile time </p>

</div>
</div>
<a id="a3959b862aa2e1cc006ab40cb96de64a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3959b862aa2e1cc006ab40cb96de64a2">&#9670;&nbsp;</a></span>INFO_LOGGER_COLORS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1log__colors">log_colors</a> emlabcpp::INFO_LOGGER_COLORS = { .time = &quot;33&quot;, .file = &quot;128&quot;, .<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = &quot;164&quot; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5219e24bd076b3c65f56c69b9025dd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5219e24bd076b3c65f56c69b9025dd69">&#9670;&nbsp;</a></span>invocable_returning</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryCallable , typename ReturnValue , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::invocable_returning</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, Args... args ) {</div>
<div class="line">                                      {</div>
<div class="line">                                              <a class="code" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>( args... )</div>
<div class="line">                                              } -&gt; std::same_as&lt; ReturnValue &gt;;</div>
<div class="line">                              }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d463be90e36b5d5be447e407fca17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d463be90e36b5d5be447e407fca17bf">&#9670;&nbsp;</a></span>is_std_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_array_v = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a633f5fea14133c23b25a75cd57a8805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f5fea14133c23b25a75cd57a8805d">&#9670;&nbsp;</a></span>is_std_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_tuple_v = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5277a3e558d32758ca0e4770ed5e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5277a3e558d32758ca0e4770ed5e1eb">&#9670;&nbsp;</a></span>is_std_vector_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_vector_v = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff43a196db9cecc357e6f4452638b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff43a196db9cecc357e6f4452638b32f">&#9670;&nbsp;</a></span>is_view_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_view_v = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71244dcc912784b08768c6ae041c37bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71244dcc912784b08768c6ae041c37bc">&#9670;&nbsp;</a></span>matrix_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::matrix_like</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">requires</a>( M m, std::size_t i, std::size_t j ) {</div>
<div class="line">                              {</div>
<div class="line">                                      M::rows</div>
<div class="line">                                      } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">                              {</div>
<div class="line">                                      M::cols</div>
<div class="line">                                      } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">                              {</div>
<div class="line">                                      m[i][j]</div>
<div class="line">                                      } -&gt; std::convertible_to&lt; typename M::value_type &gt;;</div>
<div class="line">                      }</div>
<div class="ttc" id="anamespaceemlabcpp_html_ae9679354218890ed9c289c674a125378"><div class="ttname"><a href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">emlabcpp::requires</a></div><div class="ttdeci">requires(M::rows==1 &amp;&amp;M::cols==1) const expr matrix&lt; M</div><div class="ttdef"><b>Definition:</b> matrix.h:380</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b7fdeaa7689b2455a087e965cbc7b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7fdeaa7689b2455a087e965cbc7b3d">&#9670;&nbsp;</a></span>neutral_quat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::neutral_quat { 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a>, 1.<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27325f314502897567307b29b2b03776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27325f314502897567307b29b2b03776">&#9670;&nbsp;</a></span>ostreamlike</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::ostreamlike</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= !</div>
<div class="line">std::is_array_v&lt; T &gt;&amp;&amp; <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T val ) {</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint8_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint16_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint32_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int8_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int16_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int32_t &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, float &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, double &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, bool &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, const void* &gt;;</div>
<div class="line">                               <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, std::nullptr_t &gt;;</div>
<div class="line">                       }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cac9e89744ae1ec8ad817df33d291f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cac9e89744ae1ec8ad817df33d291f1">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> emlabcpp::pi = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#a6aa7db523ecb529a3835ce0f1175fb4c">f</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants of units that are relevant for us. </p>

</div>
</div>
<a id="ae0b0ddf4f4fdd45dfc13d5420c34b446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0ddf4f4fdd45dfc13d5420c34b446">&#9670;&nbsp;</a></span>pretty_printable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::pretty_printable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceemlabcpp.html#abed05683098f9a93c5b694ff9b9f3c16">requires</a>( <span class="keyword">const</span> T&amp; v ) { pretty_printer&lt; T &gt;::print( []( <span class="keyword">const</span> std::string_view ) {}, v ); }</div>
<div class="ttc" id="anamespaceemlabcpp_html_abed05683098f9a93c5b694ff9b9f3c16"><div class="ttname"><a href="namespaceemlabcpp.html#abed05683098f9a93c5b694ff9b9f3c16">emlabcpp::requires</a></div><div class="ttdeci">requires(std::is_enum_v&lt; T &gt;) struct pretty_printer&lt; T &gt;</div><div class="ttdef"><b>Definition:</b> pretty_printer.h:314</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a869ab03f1bd49e1adc49de513ad86ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869ab03f1bd49e1adc49de513ad86ba4">&#9670;&nbsp;</a></span>quantity_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::quantity_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8be65555da61958326df0b50c6ee2bd8">detail::quantity_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept satisfies any type <code>T</code> that inherits from any form of <code>quantity&lt;U&gt;</code>. </p>

</div>
</div>
<a id="a904e4439ee5b6a29ec1c9a5a6d404c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e4439ee5b6a29ec1c9a5a6d404c55">&#9670;&nbsp;</a></span>range_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    ( (</div>
<div class="line">          <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { begin( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { std::begin( a ); } ) &amp;&amp;</div>
<div class="line">      (</div>
<div class="line">          <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { end( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { std::end( a ); } ) ) ||</div>
<div class="line">    std::is_bounded_array_v&lt; T &gt;</div>
</div><!-- fragment -->
<p>so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible </p>

</div>
</div>
<a id="ae70f5be4da9ac6f367034af1f5028827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70f5be4da9ac6f367034af1f5028827">&#9670;&nbsp;</a></span>range_container_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    range_container&lt; T &gt; &amp;&amp; std::same_as&lt; typename T::value_type, ValueType &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5b78b4d7a2e426170153951069c76cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b78b4d7a2e426170153951069c76cf">&#9670;&nbsp;</a></span>referenceable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::referenceable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= is_view&lt; T &gt;::value ||</div>
<div class="line">                                  ( range_container&lt; T &gt; &amp;&amp; !std::is_rvalue_reference_v&lt; T &gt; )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f3571963bbe0982f9987b78b111c626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3571963bbe0982f9987b78b111c626">&#9670;&nbsp;</a></span>res</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return emlabcpp::res {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e849ebc932caa63f7e1e6c67d0c2f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e849ebc932caa63f7e1e6c67d0c2f7b">&#9670;&nbsp;</a></span>static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::static_size_v = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marked deprecated on 19.4.2021. </p>

</div>
</div>
<a id="a8114b1d4bc758992dd14a1d64bd454c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8114b1d4bc758992dd14a1d64bd454c5">&#9670;&nbsp;</a></span>static_sized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::static_sized</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) {</div>
<div class="line">                               {</div>
<div class="line">                                       std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value</div>
<div class="line">                                       } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">                       }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8574533cb7c969125a6fde8f5063eff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574533cb7c969125a6fde8f5063eff2">&#9670;&nbsp;</a></span>tuple_has_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::tuple_has_type_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1cdce6706f4b40d478521925ca85f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cdce6706f4b40d478521925ca85f8a">&#9670;&nbsp;</a></span>UnaryCallable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::UnaryCallable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keyword">using</span> type = decltype( std::declval&lt; UnaryCallable &gt;()(</div>
<div class="line">            std::get&lt; 0 &gt;( std::declval&lt; Container &gt;() ) ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a183135aadf6bd4c3bd69d06b05b50407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183135aadf6bd4c3bd69d06b05b50407">&#9670;&nbsp;</a></span>vec_point_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::vec_point_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8ca7a3c5bc16d1b3a13b068bf7a7c8be">detail::vec_point_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24f6b4dc0a35260a281aa436f5401cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f6b4dc0a35260a281aa436f5401cce">&#9670;&nbsp;</a></span>with_push_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_push_back</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, <span class="keyword">typename</span> <a class="code" href="namespaceemlabcpp_1_1testing.html#a7eba021904701a30cd427b798483dc5f">T::value_type</a> b ) { a.push_back( std::move( b ) ); }</div>
<div class="ttc" id="anamespaceemlabcpp_1_1testing_html_a7eba021904701a30cd427b798483dc5f"><div class="ttname"><a href="namespaceemlabcpp_1_1testing.html#a7eba021904701a30cd427b798483dc5f">emlabcpp::testing::value_type</a></div><div class="ttdeci">std::variant&lt; int64_t, float, bool, string_buffer &gt; value_type</div><div class="ttdef"><b>Definition:</b> base.h:47</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc8fd33adfcfe872f4402d4b61b41113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8fd33adfcfe872f4402d4b61b41113">&#9670;&nbsp;</a></span>with_signature</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_signature = std::same_as&lt; typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a>&lt; T &gt;::signature, Signature &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af124e29aa89adc5fce430ee7fdda3cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af124e29aa89adc5fce430ee7fdda3cc4">&#9670;&nbsp;</a></span>with_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_value_type = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> { typename T::value_type; }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3933e60ced207f516b389cc37ab278de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3933e60ced207f516b389cc37ab278de">&#9670;&nbsp;</a></span>x_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::x_axis { 1, 0, 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>instances of constants in the code for X/Y/Z axis </p>

</div>
</div>
<a id="aaf41298fd59d19888d3fee5cea2fe4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf41298fd59d19888d3fee5cea2fe4d8">&#9670;&nbsp;</a></span>y_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::y_axis { 0, 1, 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9562476a49ff3f90e84d658dd3bafbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9562476a49ff3f90e84d658dd3bafbb9">&#9670;&nbsp;</a></span>z_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::z_axis { 0, 0, 1 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceemlabcpp.html">emlabcpp</a></li>
    <li class="footer">Generated on Wed Jul 12 2023 19:48:29 for emlabcpp by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
