<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>emlabcpp: emlabcpp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">emlabcpp
   </div>
   <div id="projectbrief">modern opinionated embedded C++ library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceemlabcpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">emlabcpp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>MIT License.  
<a href="namespaceemlabcpp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceemlabcpp_1_1bits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1bits.html">bits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1cfg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1cfg.html">cfg</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1cfg"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1coro"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1coro.html">coro</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1coro"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1impl.html">impl</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1impl"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1iterators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1iterators.html">iterators</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1iterators"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1pmr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1pmr.html">pmr</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1pmr"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1protocol"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1protocol.html">protocol</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1protocol"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1rpc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1rpc.html">rpc</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1rpc"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceemlabcpp_1_1testing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp_1_1testing.html">testing</a></td></tr>
<tr class="memdesc:namespaceemlabcpp_1_1testing"><td class="mdescLeft">&#160;</td><td class="mdescRight">MIT License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1convert__to.html">convert_to</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object with <code>operator()</code> that constructs object of type <code>T</code>out of passed-in value.  <a href="structemlabcpp_1_1convert__to.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded.html">bounded</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>bounded</code> class represents a wrapper over type <code>T</code> constrained between <code>MinVal</code> and <code>MaxVal</code> as compile-time constants.  <a href="classemlabcpp_1_1bounded.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1defer.html">defer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code>defer</code> class stores a callable object and ensures it is executed when the <code>defer</code> object goes out of scope.  <a href="classemlabcpp_1_1defer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1bounded__view.html">bounded_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1cobs__encoder.html">cobs_encoder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: make this no inline.  <a href="classemlabcpp_1_1cobs__encoder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1cobs__decoder.html">cobs_decoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__request__adapter.html">contiguous_request_adapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__object__handle.html">contiguous_object_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__array__handle.html">contiguous_array_handle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__node.html">contiguous_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1contiguous__tree.html">contiguous_tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1derived__storage.html">derived_storage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1__member__function__traits"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1__member__function__traits">_member_function_traits</a></td></tr>
<tr class="separator:structemlabcpp_1_1__member__function__traits"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4">_member_function_traits&lt; ReturnType(Object::*)(ArgTypes...) &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classemlabcpp_1_1function__view"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1function__view">function_view</a></td></tr>
<tr class="separator:classemlabcpp_1_1function__view"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1member__function.html">member_function</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1function__view_3_01ReturnType_07ArgTypes_8_8_8_08_01_4.html">function_view&lt; ReturnType(ArgTypes...) &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1point.html">point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing multidimensional point in coordinate system of dimension N.  <a href="classemlabcpp_1_1point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pose__distance"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1pose__distance"><td class="mdescLeft">&#160;</td><td class="mdescRight">distance between two poses in space, represented as 'space distance' and 'angular distance'  <a href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1pose__distance"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pose.html">pose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">represents orientation and position in 3D space  <a href="structemlabcpp_1_1pose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">API and behavior of this is inspired by tf::Quaternion.  <a href="classemlabcpp_1_1quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1linked__list__node__base.html">linked_list_node_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1linked__list__node.html">linked_list_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1matrix.html">matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1transposed__matrix.html">transposed_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1identity__matrix.html">identity_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1rowcol__submatrix.html">rowcol_submatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1generic__iterator"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1generic__iterator">generic_iterator</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1generic__iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1generic__iterator" title="generic_iterator simplifies custom iterator implementation using CRTP.">generic_iterator</a> simplifies custom iterator implementation using CRTP.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1generic__iterator">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1generic__iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1generic__iterator__base.html">generic_iterator_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure representing a range defined by a minimum and a maximum value.  <a href="structemlabcpp_1_1min__max.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1outcome.html">outcome</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>outcome</code> represents tristate resut of some operation, which can succeed, fail or produce an error.  <a href="structemlabcpp_1_1outcome.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> represents all physical units defined using the International System of Units and more.  <a href="structemlabcpp_1_1physical__quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pid__coefficients"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__coefficients">pid_coefficients</a></td></tr>
<tr class="separator:structemlabcpp_1_1pid__coefficients"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1pid__config"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__config">pid_config</a></td></tr>
<tr class="memdesc:structemlabcpp_1_1pid__config"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to configure the pid regulator.  <a href="namespaceemlabcpp.html#structemlabcpp_1_1pid__config">More...</a><br /></td></tr>
<tr class="separator:structemlabcpp_1_1pid__config"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1pid.html">pid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of PID regulator, the object should be constructed and populated with pid&lt;T&gt;::conf structure with configuration values (p,i,d coeficients, min/max output vals).  <a href="structemlabcpp_1_1pid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class representing generic quantity.  <a href="classemlabcpp_1_1quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1tagged__quantity.html">tagged_quantity</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class represents a quantity that uses <code>tags</code> to distinguish quantities instead of inheritance.  <a href="classemlabcpp_1_1tagged__quantity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>result</code> represents an result of some operation, as an alternative to returning just <code>bool</code> with true/false value.  <a href="structemlabcpp_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer__iterator.html">static_circular_buffer_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class implementing circular buffer of any type for up to N elements.  <a href="classemlabcpp_1_1static__circular__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:classemlabcpp_1_1static__function__base"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a></td></tr>
<tr class="separator:classemlabcpp_1_1static__function__base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__function__base_3_01ReturnType_07ArgTypes_8_8_8_08_00_01Capacity_00_01Align_01_4.html">static_function_base&lt; ReturnType(ArgTypes...), Capacity, Align &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1static__storage.html">static_storage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continuous data container that can contain N of uninitialized elements.  <a href="structemlabcpp_1_1static__storage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data container for up to N elements.  <a href="classemlabcpp_1_1static__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1status.html">status</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1iterator__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1iterator__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1data__iterator__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1data__iterator__of">data_iterator_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1data__iterator__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__view.html">is_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1are__same"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a></td></tr>
<tr class="separator:structemlabcpp_1_1are__same"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_01T_00_01Ts_8_8_8_01_4.html">are_same&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1are__same_3_4.html">are_same&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1tuple__has__type"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a></td></tr>
<tr class="separator:structemlabcpp_1_1tuple__has__type"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tuple__has__type_3_01T_00_01std_1_1tuple_3_01Us_8_8_8_01_4_01_4.html">tuple_has_type&lt; T, std::tuple&lt; Us... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1static__size.html">static_size</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1signature__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1signature__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1signature__of_3_01ReturnType_07Class_1_1_5_08_07Args_8_8_8_08_01_4.html">signature_of&lt; ReturnType(Class::*)(Args...) &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1signature__of_3_01ReturnType_07Class_1_1_5_08_07Args_8_8_8_08_01const_01_4.html">signature_of&lt; ReturnType(Class::*)(Args...) const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4">signature_of&lt; ReturnType(Args...) &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1mapped"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a></td></tr>
<tr class="separator:structemlabcpp_1_1mapped"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1mapped_3_01Container_00_01UnaryCallable_01_4.html">mapped&lt; Container, UnaryCallable &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1tag.html">tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1select__utype"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a></td></tr>
<tr class="separator:structemlabcpp_1_1select__utype"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__map"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__map"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4">type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1type__tag"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__tag">type_tag</a></td></tr>
<tr class="separator:structemlabcpp_1_1type__tag"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structemlabcpp_1_1index__of"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1index__of">index_of</a></td></tr>
<tr class="separator:structemlabcpp_1_1index__of"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structemlabcpp_1_1index__of_3_01T_00_01std_1_1variant_3_01Ts_8_8_8_01_4_01_4.html">index_of&lt; T, std::variant&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1view.html">view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class to represent view of some container.  <a href="classemlabcpp_1_1view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">zip_ierator iterates over a group of iterators, where value is a tuple of references to value for each iterator.  <a href="classemlabcpp_1_1zip__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a068a535d76f319e21113bceb0fdb8fbe"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a068a535d76f319e21113bceb0fdb8fbe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a> = std::array&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, 2 &gt;</td></tr>
<tr class="separator:a068a535d76f319e21113bceb0fdb8fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a> = <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, 2 &gt;</td></tr>
<tr class="separator:af17d6009cc0a80e2faa67f36d49a1e64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803520b1d525d0030e528bc67b402b53"><td class="memTemplParams" colspan="2">template&lt;typename Signature , std::size_t Capacity&gt; </td></tr>
<tr class="memitem:a803520b1d525d0030e528bc67b402b53"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a803520b1d525d0030e528bc67b402b53">static_function</a> = <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a>&lt; Signature, Capacity, alignof(void *) &gt;</td></tr>
<tr class="separator:a803520b1d525d0030e528bc67b402b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a79f4f6d31559fec9c62f27ecb5af1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a62a79f4f6d31559fec9c62f27ecb5af1">value_type</a> = T</td></tr>
<tr class="separator:a62a79f4f6d31559fec9c62f27ecb5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d3de1ecae7eb79f5f6073bcb407b70"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a32d3de1ecae7eb79f5f6073bcb407b70">reference</a> = T &amp;</td></tr>
<tr class="separator:a32d3de1ecae7eb79f5f6073bcb407b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1ec622052848f0ddd32df8936a27a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abb1ec622052848f0ddd32df8936a27a8">const_reference</a> = T const  &amp;</td></tr>
<tr class="separator:abb1ec622052848f0ddd32df8936a27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc3e436ef66e826d36130478f13fcc2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5dc3e436ef66e826d36130478f13fcc2">pointer</a> = T *</td></tr>
<tr class="separator:a5dc3e436ef66e826d36130478f13fcc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c089201bec45628e321b5afa38d169b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2c089201bec45628e321b5afa38d169b">const_pointer</a> = T const  *</td></tr>
<tr class="separator:a2c089201bec45628e321b5afa38d169b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f96077b9c4ba6a57d7dc290fb7670c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> = std::size_t</td></tr>
<tr class="separator:a1f96077b9c4ba6a57d7dc290fb7670c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a98ab53b012e339a9621604b203df856e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td></tr>
<tr class="separator:a98ab53b012e339a9621604b203df856e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d2d1e467ceff8661e40aa2f34b24ae"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a11d2d1e467ceff8661e40aa2f34b24ae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a11d2d1e467ceff8661e40aa2f34b24ae">data_iterator_of_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1data__iterator__of">data_iterator_of</a>&lt; Container &gt;::type</td></tr>
<tr class="separator:a11d2d1e467ceff8661e40aa2f34b24ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf111745a0eec5119748333b9640afca"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryCallable &gt; </td></tr>
<tr class="memitem:abf111745a0eec5119748333b9640afca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abf111745a0eec5119748333b9640afca">mapped_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &gt;::type</td></tr>
<tr class="separator:abf111745a0eec5119748333b9640afca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">select_utype_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;::type</td></tr>
<tr class="separator:ac223240cfaa32fcb48f0daa06c78a9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memTemplParams" colspan="2">template&lt;typename T , template&lt; typename &gt; class Fun&gt; </td></tr>
<tr class="memitem:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afbd4de918223b1144d32fcef8a9dfe2a">type_map_t</a> = typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a>&lt; T, Fun &gt;::type</td></tr>
<tr class="separator:afbd4de918223b1144d32fcef8a9dfe2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1bd5361b527ba0c0f4c0cbb50657ec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Variant &gt; </td></tr>
<tr class="memitem:adf1bd5361b527ba0c0f4c0cbb50657ec"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adf1bd5361b527ba0c0f4c0cbb50657ec">index_of_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1index__of">index_of</a>&lt; T, Variant &gt;::value</td></tr>
<tr class="separator:adf1bd5361b527ba0c0f4c0cbb50657ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a151948c6a8488f45e3d7834f876be469"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a151948c6a8488f45e3d7834f876be469">unitless</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a151948c6a8488f45e3d7834f876be469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458a21111b267fd6b9727f821974f859"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a458a21111b267fd6b9727f821974f859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620d7b1d1801843cd1a7356bcc341e3e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a620d7b1d1801843cd1a7356bcc341e3e">mass</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a620d7b1d1801843cd1a7356bcc341e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa23942849e26dc612a6608eb2ec02"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">timeq</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a35fa23942849e26dc612a6608eb2ec02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eceaa8b0d9ceb67162be01c8a803f7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae2eceaa8b0d9ceb67162be01c8a803f7">current</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:ae2eceaa8b0d9ceb67162be01c8a803f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845bc83f874f1d97f649fbe0137c913c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a845bc83f874f1d97f649fbe0137c913c">temp</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a845bc83f874f1d97f649fbe0137c913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034dcea22b6c4c252c6127ffd7078a7d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a034dcea22b6c4c252c6127ffd7078a7d">amount_of_substance</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a034dcea22b6c4c252c6127ffd7078a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5e1be68f8469a0ef8388b17b94406e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5c5e1be68f8469a0ef8388b17b94406e">luminous_intensity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</td></tr>
<tr class="separator:a5c5e1be68f8469a0ef8388b17b94406e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa050c988b29285083320111dc7b90ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</td></tr>
<tr class="separator:afa050c988b29285083320111dc7b90ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde778df7140459ee3df4cf32bf7566e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afde778df7140459ee3df4cf32bf7566e">byte</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</td></tr>
<tr class="separator:afde778df7140459ee3df4cf32bf7566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7b213031fa424abf6cc3d1d04ac1ca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">acceleration</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a9f7b213031fa424abf6cc3d1d04ac1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0893503dba0b6cfd0ebd72ceb358f20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af0893503dba0b6cfd0ebd72ceb358f20">angular_velocity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 1, 0 &gt;</td></tr>
<tr class="separator:af0893503dba0b6cfd0ebd72ceb358f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca5b22a706c436b22c929c45b773ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4eca5b22a706c436b22c929c45b773ef">area</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a4eca5b22a706c436b22c929c45b773ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f05bc39f7d9b7332f437d5a7b19156c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5f05bc39f7d9b7332f437d5a7b19156c">volume</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 3, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a5f05bc39f7d9b7332f437d5a7b19156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1133bfe4782c135fcdb04c3de43fc0a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">velocity</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a1133bfe4782c135fcdb04c3de43fc0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d67880c6a526098821b950d000c2d79"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0d67880c6a526098821b950d000c2d79">frequency</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a0d67880c6a526098821b950d000c2d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf27b9093d0831dd17c88bcce4f9330"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aabf27b9093d0831dd17c88bcce4f9330">force</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 1, -2, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:aabf27b9093d0831dd17c88bcce4f9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf48f5a991078e6acfe3db1e7762675"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abbf48f5a991078e6acfe3db1e7762675">power</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, 0, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:abbf48f5a991078e6acfe3db1e7762675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9a554fd1715665000628242b77a474"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c9a554fd1715665000628242b77a474">voltage</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -1, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:a1c9a554fd1715665000628242b77a474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48e239b7c22e51004fc26dd043d32b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae48e239b7c22e51004fc26dd043d32b9">resistance</a> = <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -2, 0, 0, 0, 0, 0 &gt;</td></tr>
<tr class="separator:ae48e239b7c22e51004fc26dd043d32b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ac05592b4c728910966af0c89b13a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">distance</a> = <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td></tr>
<tr class="separator:a11ac05592b4c728910966af0c89b13a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96516bd702e891771257f4dc279a2f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af96516bd702e891771257f4dc279a2f2">radius</a> = <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td></tr>
<tr class="separator:af96516bd702e891771257f4dc279a2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a98cc8be30884776ff941bb6ae93946fd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fd">contiguous_tree_type</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fdaecc2e9c313faddb07e7da223c1dc5c3f">VALUE</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fda8eee8e217391199668cbac89472ace53">OBJECT</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fdacb4fb1757fb37c43cded35d3eb857c43">ARRAY</a> = 3
<br />
 }</td></tr>
<tr class="separator:a98cc8be30884776ff941bb6ae93946fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa815694613f8d89e804ac10b1395eeca"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eeca">contiguous_container_type</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eecaacb4fb1757fb37c43cded35d3eb857c43">ARRAY</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eecaa8eee8e217391199668cbac89472ace53">OBJECT</a> = 2
<br />
 }</td></tr>
<tr class="separator:aa815694613f8d89e804ac10b1395eeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453799fa0ff8d942480b0bcc3dbf7f10"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10">contiguous_request_adapter_errors</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a7e94d60ca52c8bf6da26a0a479f08d21">MISSING_NODE</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a9bf67e4befa0dcd99caa7f01f2c9b714">WRONG_TYPE</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10a3396545d99c2f2d78dd20411b4a66ad2">CHILD_MISSING</a> = 3
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10aba7de5bc6888294e5884b024a4c894f1">FULL</a> = 4
<br />
 }</td></tr>
<tr class="separator:a453799fa0ff8d942480b0bcc3dbf7f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a6537b772f3e6e4772dfdf8af3774f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57a6537b772f3e6e4772dfdf8af3774f">outcome_e</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a57a6537b772f3e6e4772dfdf8af3774fad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a57a6537b772f3e6e4772dfdf8af3774fa36fc6065a3e970bc3e6b2e59da52bf2a">FAILURE</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#a57a6537b772f3e6e4772dfdf8af3774fabb1ca97ec761fc37101737ba0aa2e7c5">ERROR</a> = 2
<br />
 }</td></tr>
<tr class="separator:a57a6537b772f3e6e4772dfdf8af3774f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bb11365d380040c5e151a237655d4a"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad6bb11365d380040c5e151a237655d4a">result_e</a> : uint8_t { <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ad6bb11365d380040c5e151a237655d4aad0749aaba8b833466dfcbb0428e4f89c">SUCCESS</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespaceemlabcpp.html#ad6bb11365d380040c5e151a237655d4aabb1ca97ec761fc37101737ba0aa2e7c5">ERROR</a> = 1
<br />
 }</td></tr>
<tr class="separator:ad6bb11365d380040c5e151a237655d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a814d6c59042c6b73cca5c9a2272d6316"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a814d6c59042c6b73cca5c9a2272d6316"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a814d6c59042c6b73cca5c9a2272d6316">sign</a> (T const &amp;val)</td></tr>
<tr class="memdesc:a814d6c59042c6b73cca5c9a2272d6316"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns sign of variable T: -1,0,1  <a href="namespaceemlabcpp.html#a814d6c59042c6b73cca5c9a2272d6316">More...</a><br /></td></tr>
<tr class="separator:a814d6c59042c6b73cca5c9a2272d6316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3a3ff32c2bf0005fcdbab5763193f239">ceil_to</a> (T val, T base)</td></tr>
<tr class="memdesc:a3a3ff32c2bf0005fcdbab5763193f239"><td class="mdescLeft">&#160;</td><td class="mdescRight">takes an value <code>val</code> and rounds it up to nearest multiply of <code>base</code>  <a href="namespaceemlabcpp.html#a3a3ff32c2bf0005fcdbab5763193f239">More...</a><br /></td></tr>
<tr class="separator:a3a3ff32c2bf0005fcdbab5763193f239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplParams" colspan="2">template&lt;additive_operators T, arithmetic_operators U&gt; </td></tr>
<tr class="memitem:a0abef993d302d6b6d93fe877ca62491c"><td class="memTemplItemLeft" align="right" valign="top">constexpr U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">map_range</a> (T input, T from_min, T from_max, U to_min, U to_max)</td></tr>
<tr class="memdesc:a0abef993d302d6b6d93fe877ca62491c"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps input value 'input' from input range to equivalent value in output range  <a href="namespaceemlabcpp.html#a0abef993d302d6b6d93fe877ca62491c">More...</a><br /></td></tr>
<tr class="separator:a0abef993d302d6b6d93fe877ca62491c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d314e21017873e9895791defe0635"><td class="memTemplParams" colspan="2">template&lt;container Container&gt; </td></tr>
<tr class="memitem:aff8d314e21017873e9895791defe0635"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aff8d314e21017873e9895791defe0635">cont_size</a> (Container const &amp;cont) noexcept</td></tr>
<tr class="memdesc:aff8d314e21017873e9895791defe0635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the container, regardless of what it is.  <a href="namespaceemlabcpp.html#aff8d314e21017873e9895791defe0635">More...</a><br /></td></tr>
<tr class="separator:aff8d314e21017873e9895791defe0635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae464f57c8582b655e0852bae30a0b8ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae464f57c8582b655e0852bae30a0b8ca"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae464f57c8582b655e0852bae30a0b8ca">almost_equal</a> (T const &amp;lh, T const &amp;rh, float const eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="memdesc:ae464f57c8582b655e0852bae30a0b8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps'.  <a href="namespaceemlabcpp.html#ae464f57c8582b655e0852bae30a0b8ca">More...</a><br /></td></tr>
<tr class="separator:ae464f57c8582b655e0852bae30a0b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231279793ce500e80c1bbb0848ed83c6"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a231279793ce500e80c1bbb0848ed83c6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a231279793ce500e80c1bbb0848ed83c6">tail</a> (Container &amp;&amp;cont, int const step=1)</td></tr>
<tr class="memdesc:a231279793ce500e80c1bbb0848ed83c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips first item of container.  <a href="namespaceemlabcpp.html#a231279793ce500e80c1bbb0848ed83c6">More...</a><br /></td></tr>
<tr class="separator:a231279793ce500e80c1bbb0848ed83c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565474a8d7bb938dd256fdb548c6f6ff"><td class="memTemplParams" colspan="2">template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a565474a8d7bb938dd256fdb548c6f6ff"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a565474a8d7bb938dd256fdb548c6f6ff">init</a> (Container &amp;&amp;cont, int const step=1)</td></tr>
<tr class="memdesc:a565474a8d7bb938dd256fdb548c6f6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns range over Container, which skips last item of container.  <a href="namespaceemlabcpp.html#a565474a8d7bb938dd256fdb548c6f6ff">More...</a><br /></td></tr>
<tr class="separator:a565474a8d7bb938dd256fdb548c6f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad2aaee725330a629c1fa9af8cf7e37"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:adad2aaee725330a629c1fa9af8cf7e37"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if</a> (Container &amp;&amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:adad2aaee725330a629c1fa9af8cf7e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterator for first item, for which call to predicate f(*iter) holds true.  <a href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">More...</a><br /></td></tr>
<tr class="separator:adad2aaee725330a629c1fa9af8cf7e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:aab6fd32a8b3335eec93b94331d4293b0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr std</td></tr>
<tr class="memdesc:aab6fd32a8b3335eec93b94331d4293b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns index of an element in tuple 't', for which call to predicate f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple.  <a href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">More...</a><br /></td></tr>
<tr class="separator:aab6fd32a8b3335eec93b94331d4293b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac599d73fbac6433f70ba199e29e247e0"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T &gt; </td></tr>
<tr class="memitem:ac599d73fbac6433f70ba199e29e247e0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac599d73fbac6433f70ba199e29e247e0">find</a> (Container &amp;&amp;cont, T const &amp;item)</td></tr>
<tr class="memdesc:ac599d73fbac6433f70ba199e29e247e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds first item in container 'cont' that is equal to 'item', returns iterator for container, or index for tuples.  <a href="namespaceemlabcpp.html#ac599d73fbac6433f70ba199e29e247e0">More...</a><br /></td></tr>
<tr class="separator:ac599d73fbac6433f70ba199e29e247e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77a0075c379e93afef4961e57bf88c1"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T &gt; </td></tr>
<tr class="memitem:ac77a0075c379e93afef4961e57bf88c1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac77a0075c379e93afef4961e57bf88c1">contains</a> (Container const &amp;cont, T const &amp;item)</td></tr>
<tr class="memdesc:ac77a0075c379e93afef4961e57bf88c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if container <code>cont</code> contains at least one occurence of <code>item</code>, returns true/false.  <a href="namespaceemlabcpp.html#ac77a0075c379e93afef4961e57bf88c1">More...</a><br /></td></tr>
<tr class="separator:ac77a0075c379e93afef4961e57bf88c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplParams" colspan="2">template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </td></tr>
<tr class="memitem:a670099942b8cdd3d2cc28760b1717d7c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">requires</a> (!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;) const expr void <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a>(Container &amp;&amp;cont</td></tr>
<tr class="memdesc:a670099942b8cdd3d2cc28760b1717d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a670099942b8cdd3d2cc28760b1717d7c">More...</a><br /></td></tr>
<tr class="separator:a670099942b8cdd3d2cc28760b1717d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685395cc470dfed697a40d2c718af4e9"><td class="memTemplParams" colspan="2">template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </td></tr>
<tr class="memitem:a685395cc470dfed697a40d2c718af4e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a685395cc470dfed697a40d2c718af4e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f' to each element of container 'cont'.  <a href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">More...</a><br /></td></tr>
<tr class="separator:a685395cc470dfed697a40d2c718af4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e56e63d61e9a15632f19d5cfc1f6b5"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:ab5e56e63d61e9a15632f19d5cfc1f6b5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab5e56e63d61e9a15632f19d5cfc1f6b5">min_max_elem</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:ab5e56e63d61e9a15632f19d5cfc1f6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x)' to each element of container 'cont', returns the largest and the smallest return value.  <a href="namespaceemlabcpp.html#ab5e56e63d61e9a15632f19d5cfc1f6b5">More...</a><br /></td></tr>
<tr class="separator:ab5e56e63d61e9a15632f19d5cfc1f6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3a1cce893154570d1d004eff0eae44"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a3a3a1cce893154570d1d004eff0eae44"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3a3a1cce893154570d1d004eff0eae44">max_elem</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a3a3a1cce893154570d1d004eff0eae44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls.  <a href="namespaceemlabcpp.html#a3a3a1cce893154570d1d004eff0eae44">More...</a><br /></td></tr>
<tr class="separator:a3a3a1cce893154570d1d004eff0eae44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0854cc8f63fb866604cdba86751aa661"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a0854cc8f63fb866604cdba86751aa661"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0854cc8f63fb866604cdba86751aa661">min_elem</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a0854cc8f63fb866604cdba86751aa661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies unary callable 'f(x) to each element of container 'cont&lsquo;, returns the smallest return value of 'f(x)&rsquo; calls.  <a href="namespaceemlabcpp.html#a0854cc8f63fb866604cdba86751aa661">More...</a><br /></td></tr>
<tr class="separator:a0854cc8f63fb866604cdba86751aa661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036ecd2b344a56d6473500952c3c9db8"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:a036ecd2b344a56d6473500952c3c9db8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a036ecd2b344a56d6473500952c3c9db8">count</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a036ecd2b344a56d6473500952c3c9db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the predicate 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'.  <a href="namespaceemlabcpp.html#a036ecd2b344a56d6473500952c3c9db8">More...</a><br /></td></tr>
<tr class="separator:a036ecd2b344a56d6473500952c3c9db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae5bc0fd1be635cd2666c78c8d69fae"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a3ae5bc0fd1be635cd2666c78c8d69fae"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity(), T <a class="el" href="namespaceemlabcpp.html#a565474a8d7bb938dd256fdb548c6f6ff">init</a>={})</td></tr>
<tr class="memdesc:a3ae5bc0fd1be635cd2666c78c8d69fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item.  <a href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">More...</a><br /></td></tr>
<tr class="separator:a3ae5bc0fd1be635cd2666c78c8d69fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246f1fc9cb6dd2ad9332499ff4574d81"><td class="memTemplParams" colspan="2">template&lt;container Container, typename T , typename BinaryCallable &gt; </td></tr>
<tr class="memitem:a246f1fc9cb6dd2ad9332499ff4574d81"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a246f1fc9cb6dd2ad9332499ff4574d81">accumulate</a> (Container &amp;&amp;cont, T <a class="el" href="namespaceemlabcpp.html#a565474a8d7bb938dd256fdb548c6f6ff">init</a>, BinaryCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a246f1fc9cb6dd2ad9332499ff4574d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, returns a result of last application.  <a href="namespaceemlabcpp.html#a246f1fc9cb6dd2ad9332499ff4574d81">More...</a><br /></td></tr>
<tr class="separator:a246f1fc9cb6dd2ad9332499ff4574d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a3dac72157f60685dedced4c681643"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a51a3dac72157f60685dedced4c681643"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a51a3dac72157f60685dedced4c681643">avg</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a51a3dac72157f60685dedced4c681643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(x)' to each element of container 'cont' and returns the average value of each call.  <a href="namespaceemlabcpp.html#a51a3dac72157f60685dedced4c681643">More...</a><br /></td></tr>
<tr class="separator:a51a3dac72157f60685dedced4c681643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50045da8445468706c19455b429cdfcc"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a50045da8445468706c19455b429cdfcc"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a50045da8445468706c19455b429cdfcc">variance</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a50045da8445468706c19455b429cdfcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies callable 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call.  <a href="namespaceemlabcpp.html#a50045da8445468706c19455b429cdfcc">More...</a><br /></td></tr>
<tr class="separator:a50045da8445468706c19455b429cdfcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671d53ec08de7c34437cf24d07aee0c"><td class="memTemplParams" colspan="2">template&lt;container LhContainer, container RhContainer, typename BinaryCallable &gt; </td></tr>
<tr class="memitem:a9671d53ec08de7c34437cf24d07aee0c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9671d53ec08de7c34437cf24d07aee0c">for_cross_joint</a> (LhContainer &amp;&amp;lh_cont, RhContainer &amp;&amp;rh_cont, BinaryCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a9671d53ec08de7c34437cf24d07aee0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies binary callable 'f(x,y)' to each combination of items <code>x</code> from <code>lh_cont</code> and <code>y</code> from <code>rh_cont</code>  <a href="namespaceemlabcpp.html#a9671d53ec08de7c34437cf24d07aee0c">More...</a><br /></td></tr>
<tr class="separator:a9671d53ec08de7c34437cf24d07aee0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59476e1a770a7c69e3ec745f031f50c5"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:a59476e1a770a7c69e3ec745f031f50c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a59476e1a770a7c69e3ec745f031f50c5">any_of</a> (Container &amp;&amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a59476e1a770a7c69e3ec745f031f50c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns true for at least one item <code>x</code> in 'cont'.  <a href="namespaceemlabcpp.html#a59476e1a770a7c69e3ec745f031f50c5">More...</a><br /></td></tr>
<tr class="separator:a59476e1a770a7c69e3ec745f031f50c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c8cfdb013071f0e1eb609c257eb9d0"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:a37c8cfdb013071f0e1eb609c257eb9d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37c8cfdb013071f0e1eb609c257eb9d0">none_of</a> (Container &amp;&amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a37c8cfdb013071f0e1eb609c257eb9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns false for all items in 'cont'.  <a href="namespaceemlabcpp.html#a37c8cfdb013071f0e1eb609c257eb9d0">More...</a><br /></td></tr>
<tr class="separator:a37c8cfdb013071f0e1eb609c257eb9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39882ff8249fe71fbd0a6a3658c692bb"><td class="memTemplParams" colspan="2">template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </td></tr>
<tr class="memitem:a39882ff8249fe71fbd0a6a3658c692bb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a39882ff8249fe71fbd0a6a3658c692bb">all_of</a> (Container &amp;&amp;cont, PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a39882ff8249fe71fbd0a6a3658c692bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if call to predicate 'f(x)' returns true for all items in 'cont'.  <a href="namespaceemlabcpp.html#a39882ff8249fe71fbd0a6a3658c692bb">More...</a><br /></td></tr>
<tr class="separator:a39882ff8249fe71fbd0a6a3658c692bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504dbf8012c154e4c54aae3af67e08c9"><td class="memTemplParams" colspan="2">template&lt;range_container LhContainer, range_container RhContainer, typename BinaryPredicateCallable  = std::equal_to&lt; void &gt;&gt; </td></tr>
<tr class="memitem:a504dbf8012c154e4c54aae3af67e08c9"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a504dbf8012c154e4c54aae3af67e08c9">equal</a> (LhContainer &amp;&amp;lh, RhContainer &amp;&amp;rh, BinaryPredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::equal_to&lt; void &gt;{})</td></tr>
<tr class="memdesc:a504dbf8012c154e4c54aae3af67e08c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if containers 'lh' and 'rh' has same size and calls to predicate <code>f</code> - <code>f(lh[i],rh[i])</code> return true for each item.  <a href="namespaceemlabcpp.html#a504dbf8012c154e4c54aae3af67e08c9">More...</a><br /></td></tr>
<tr class="separator:a504dbf8012c154e4c54aae3af67e08c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memTemplParams" colspan="2">template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memTemplItemLeft" align="right" valign="top">ResultContainer&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae8555060e43c2b8cdd8d91bb248b9a6d">map_f</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls callable <code>f(x)</code> for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned.  <a href="namespaceemlabcpp.html#ae8555060e43c2b8cdd8d91bb248b9a6d">More...</a><br /></td></tr>
<tr class="separator:ae8555060e43c2b8cdd8d91bb248b9a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1911a0fc83869772cacfc4d21772268f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </td></tr>
<tr class="memitem:a1911a0fc83869772cacfc4d21772268f"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1911a0fc83869772cacfc4d21772268f">map_f_to_a</a> (Container &amp;&amp;cont, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity()) <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>(!<a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; Container &gt;)</td></tr>
<tr class="memdesc:a1911a0fc83869772cacfc4d21772268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls callable <code>f(cont[i])</code> for i = 0...N and stores the result in array of an size N.  <a href="namespaceemlabcpp.html#a1911a0fc83869772cacfc4d21772268f">More...</a><br /></td></tr>
<tr class="separator:a1911a0fc83869772cacfc4d21772268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417dc63bcfd0f3fe1314388f1d2515d3"><td class="memTemplParams" colspan="2">template&lt;range_container Container, typename T , container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </td></tr>
<tr class="memitem:a417dc63bcfd0f3fe1314388f1d2515d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a417dc63bcfd0f3fe1314388f1d2515d3">joined</a> (Container &amp;&amp;cont, T const &amp;val, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity())</td></tr>
<tr class="memdesc:a417dc63bcfd0f3fe1314388f1d2515d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applies callable <code>f</code> to each item in container <code>cont</code> and contacts results with operator+, <code>val</code> is used as a separator between the items.  <a href="namespaceemlabcpp.html#a417dc63bcfd0f3fe1314388f1d2515d3">More...</a><br /></td></tr>
<tr class="separator:a417dc63bcfd0f3fe1314388f1d2515d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b28822529dd798c4e0f74f6d38f7fb"><td class="memTemplParams" colspan="2">template&lt;container Container, typename Iterator &gt; </td></tr>
<tr class="memitem:a54b28822529dd798c4e0f74f6d38f7fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a54b28822529dd798c4e0f74f6d38f7fb">copy</a> (Container &amp;&amp;cont, Iterator iter)</td></tr>
<tr class="separator:a54b28822529dd798c4e0f74f6d38f7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5214a69e44441c91729255e5934ce985"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename NullCallable &gt; </td></tr>
<tr class="memitem:a5214a69e44441c91729255e5934ce985"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5214a69e44441c91729255e5934ce985">for_each_index</a> (NullCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a5214a69e44441c91729255e5934ce985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N.  <a href="namespaceemlabcpp.html#a5214a69e44441c91729255e5934ce985">More...</a><br /></td></tr>
<tr class="separator:a5214a69e44441c91729255e5934ce985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23af197a97477d855276e1d81578cace"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename PredicateCallable &gt; </td></tr>
<tr class="memitem:a23af197a97477d855276e1d81578cace"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a23af197a97477d855276e1d81578cace">find_if_index</a> (PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a23af197a97477d855276e1d81578cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N until first call that returns true.  <a href="namespaceemlabcpp.html#a23af197a97477d855276e1d81578cace">More...</a><br /></td></tr>
<tr class="separator:a23af197a97477d855276e1d81578cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f12faf6930621f03dcddf5e18a16b1"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, typename PredicateCallable &gt; </td></tr>
<tr class="memitem:a35f12faf6930621f03dcddf5e18a16b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35f12faf6930621f03dcddf5e18a16b1">until_index</a> (PredicateCallable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="memdesc:a35f12faf6930621f03dcddf5e18a16b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes predicate <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true.  <a href="namespaceemlabcpp.html#a35f12faf6930621f03dcddf5e18a16b1">More...</a><br /></td></tr>
<tr class="separator:a35f12faf6930621f03dcddf5e18a16b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a35de9105fe961a808d8e0f3a2cb58bf2">requires</a> (!requires(Callable <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}) const expr auto <a class="el" href="namespaceemlabcpp.html#a22bdba517ae1cfa5e6b4f2e54e407bb1">select_index</a>(IndexType i</td></tr>
<tr class="memdesc:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function expectes bounded value as index input and callable.  <a href="namespaceemlabcpp.html#a35de9105fe961a808d8e0f3a2cb58bf2">More...</a><br /></td></tr>
<tr class="separator:a35de9105fe961a808d8e0f3a2cb58bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bdba517ae1cfa5e6b4f2e54e407bb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a22bdba517ae1cfa5e6b4f2e54e407bb1">select_index</a> (i, [&amp;<a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, &amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>]&lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();})</td></tr>
<tr class="separator:a22bdba517ae1cfa5e6b4f2e54e407bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memTemplParams" colspan="2">template&lt;bounded_derived IndexType, typename Callable &gt; </td></tr>
<tr class="memitem:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memTemplItemLeft" align="right" valign="top">requires&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8d77f50ca9dd31e43365e38debbd42fa">requires</a> (Callable <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="separator:a8d77f50ca9dd31e43365e38debbd42fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505109612442935cc682cf92a9d2296c"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a505109612442935cc682cf92a9d2296c">select_index</a> (IndexType i, Callable &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="separator:a505109612442935cc682cf92a9d2296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5266b3d998c70ddddcc15f7bba604b42"><td class="memTemplParams" colspan="2">template&lt;typename... Args, std::size_t N = sizeof...( Args )&gt; </td></tr>
<tr class="memitem:a5266b3d998c70ddddcc15f7bba604b42"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; std::byte, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5266b3d998c70ddddcc15f7bba604b42">bytes</a> (Args const &amp;... <a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>)</td></tr>
<tr class="memdesc:a5266b3d998c70ddddcc15f7bba604b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conveft the provided arguments into array of std::byte.  <a href="namespaceemlabcpp.html#a5266b3d998c70ddddcc15f7bba604b42">More...</a><br /></td></tr>
<tr class="separator:a5266b3d998c70ddddcc15f7bba604b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad798db07be925b58001fd00feb4f721d"><td class="memTemplParams" colspan="2">template&lt;typename Arr , typename... Arrs&gt; </td></tr>
<tr class="memitem:ad798db07be925b58001fd00feb4f721d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad798db07be925b58001fd00feb4f721d">merge_arrays</a> (Arr &amp;&amp;first, Arrs &amp;&amp;... arrs)</td></tr>
<tr class="memdesc:ad798db07be925b58001fd00feb4f721d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects multiple std::arrays on input, and merges all together into one std::array instance.  <a href="namespaceemlabcpp.html#ad798db07be925b58001fd00feb4f721d">More...</a><br /></td></tr>
<tr class="separator:ad798db07be925b58001fd00feb4f721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d26d2adcae9ef476f4a0b2136b9352d"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a7d26d2adcae9ef476f4a0b2136b9352d"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7d26d2adcae9ef476f4a0b2136b9352d">filled</a> (T const &amp;item)</td></tr>
<tr class="memdesc:a7d26d2adcae9ef476f4a0b2136b9352d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an array filled with value <code>x</code>  <a href="namespaceemlabcpp.html#a7d26d2adcae9ef476f4a0b2136b9352d">More...</a><br /></td></tr>
<tr class="separator:a7d26d2adcae9ef476f4a0b2136b9352d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </td></tr>
<tr class="memitem:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a51bc55ba3cb21b9294e89cdda68b1f98">convert_view</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:a51bc55ba3cb21b9294e89cdda68b1f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator &gt; </td></tr>
<tr class="memitem:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8a7d1590aa2cb61d0e710f02fea01474">convert_view_n</a> (Iterator begin, std::size_t n)</td></tr>
<tr class="separator:a8a7d1590aa2cb61d0e710f02fea01474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bdb9e4992c495c755d900b23435840"><td class="memTemplParams" colspan="2">template&lt;typename Enum &gt; </td></tr>
<tr class="memitem:a39bdb9e4992c495c755d900b23435840"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a39bdb9e4992c495c755d900b23435840">requires</a> (std::is_enum_v&lt; Enum &gt;) auto convert_enum(Enum val)</td></tr>
<tr class="memdesc:a39bdb9e4992c495c755d900b23435840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string-like name of the enum value <code>val</code>  <a href="namespaceemlabcpp.html#a39bdb9e4992c495c755d900b23435840">More...</a><br /></td></tr>
<tr class="separator:a39bdb9e4992c495c755d900b23435840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:afe935e56d6376df9f87d0d015a3baecc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afe935e56d6376df9f87d0d015a3baecc">enumerate</a> (Container &amp;&amp;cont)</td></tr>
<tr class="separator:afe935e56d6376df9f87d0d015a3baecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5310f80a7f1ae10cd74f8028193511c2"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5310f80a7f1ae10cd74f8028193511c2">encode_cobs</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte const * &gt; source, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; target)</td></tr>
<tr class="memdesc:a5310f80a7f1ae10cd74f8028193511c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer.  <a href="namespaceemlabcpp.html#a5310f80a7f1ae10cd74f8028193511c2">More...</a><br /></td></tr>
<tr class="separator:a5310f80a7f1ae10cd74f8028193511c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971147b99a5b38779174a4a02d0099b3"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a971147b99a5b38779174a4a02d0099b3">decode_cobs</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte const * &gt; source, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt; target)</td></tr>
<tr class="memdesc:a971147b99a5b38779174a4a02d0099b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer.  <a href="namespaceemlabcpp.html#a971147b99a5b38779174a4a02d0099b3">More...</a><br /></td></tr>
<tr class="separator:a971147b99a5b38779174a4a02d0099b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb69734e95cc40cd53e2f01531183d7"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a1eb69734e95cc40cd53e2f01531183d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt;, <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1eb69734e95cc40cd53e2f01531183d7">cobs_decode_view</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt; <a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data</a>)</td></tr>
<tr class="separator:a1eb69734e95cc40cd53e2f01531183d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afecb966a998ea6497e7b378bca2681c8"><td class="memTemplParams" colspan="2">template&lt;decomposable_0 T&gt; </td></tr>
<tr class="memitem:afecb966a998ea6497e7b378bca2681c8"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::tuple&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afecb966a998ea6497e7b378bca2681c8">decompose</a> (T &amp;&amp;)</td></tr>
<tr class="separator:afecb966a998ea6497e7b378bca2681c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5e72f5ad9fec2b8f70d4f8e0e5ec0d23">compose</a> (Tuple tpl)</td></tr>
<tr class="separator:a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab124463ea669779e32ea4428088a01c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab124463ea669779e32ea4428088a01c4">EMLABCPP_GENERATE_DECOMPOSE</a> (16, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) template&lt; typename T &gt; using decomposed_type</td></tr>
<tr class="separator:ab124463ea669779e32ea4428088a01c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f0a0ef952603bbd6448aca8b102dfc"><td class="memTemplParams" colspan="2">template&lt;auto MemberFunctionPtr&gt; </td></tr>
<tr class="memitem:aa6f0a0ef952603bbd6448aca8b102dfc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa6f0a0ef952603bbd6448aca8b102dfc">function_view</a> (<a class="el" href="structemlabcpp_1_1member__function.html">member_function</a>&lt; MemberFunctionPtr &gt; handle) -&gt; <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1function__view">function_view</a>&lt; typename <a class="el" href="structemlabcpp_1_1member__function.html">member_function</a>&lt; MemberFunctionPtr &gt;::signature &gt;</td></tr>
<tr class="separator:aa6f0a0ef952603bbd6448aca8b102dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb93db9f593c9eb758f2801f88f7d05b"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:acb93db9f593c9eb758f2801f88f7d05b"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acb93db9f593c9eb758f2801f88f7d05b">distance_of</a> (<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;l, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;p)</td></tr>
<tr class="separator:acb93db9f593c9eb758f2801f88f7d05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65497bc8d43a6c5dd1652df3be235c5"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ae65497bc8d43a6c5dd1652df3be235c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae65497bc8d43a6c5dd1652df3be235c5">distance_of</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;p, <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;<a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>)</td></tr>
<tr class="separator:ae65497bc8d43a6c5dd1652df3be235c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c12c6cbb44c2e1859d1d358f5669b69"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a0c12c6cbb44c2e1859d1d358f5669b69"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0c12c6cbb44c2e1859d1d358f5669b69">point_cast</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;v)</td></tr>
<tr class="separator:a0c12c6cbb44c2e1859d1d358f5669b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5b72176081094d23e7ba44b307bbcb"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:abf5b72176081094d23e7ba44b307bbcb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;p)</td></tr>
<tr class="separator:abf5b72176081094d23e7ba44b307bbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58474e3d150740d1c81193bf6004ac8c"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a58474e3d150740d1c81193bf6004ac8c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a58474e3d150740d1c81193bf6004ac8c">operator*</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; a, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:a58474e3d150740d1c81193bf6004ac8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of points multiplies each coordinate of A by coordinate of B on same dimension.  <a href="namespaceemlabcpp.html#a58474e3d150740d1c81193bf6004ac8c">More...</a><br /></td></tr>
<tr class="separator:a58474e3d150740d1c81193bf6004ac8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09a470ff3b24abe911e6d08ec0ea0c0"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac09a470ff3b24abe911e6d08ec0ea0c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac09a470ff3b24abe911e6d08ec0ea0c0">operator-</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; a, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:ac09a470ff3b24abe911e6d08ec0ea0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of subtraction of A from B, viz -= operator.  <a href="namespaceemlabcpp.html#ac09a470ff3b24abe911e6d08ec0ea0c0">More...</a><br /></td></tr>
<tr class="separator:ac09a470ff3b24abe911e6d08ec0ea0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a8fb58eec641f5a3825f8c684ff6d1"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a26a8fb58eec641f5a3825f8c684ff6d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a26a8fb58eec641f5a3825f8c684ff6d1">operator+</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; a, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:a26a8fb58eec641f5a3825f8c684ff6d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of addition a to b, viz += operator.  <a href="namespaceemlabcpp.html#a26a8fb58eec641f5a3825f8c684ff6d1">More...</a><br /></td></tr>
<tr class="separator:a26a8fb58eec641f5a3825f8c684ff6d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc2d56e5b666168195810e2c2fb85db"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aabc2d56e5b666168195810e2c2fb85db"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aabc2d56e5b666168195810e2c2fb85db">operator-</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; a, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:aabc2d56e5b666168195810e2c2fb85db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a result of subtraction a to b, viz += operator.  <a href="namespaceemlabcpp.html#aabc2d56e5b666168195810e2c2fb85db">More...</a><br /></td></tr>
<tr class="separator:aabc2d56e5b666168195810e2c2fb85db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2d79916f92a116f6478fb928bd346d"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aee2d79916f92a116f6478fb928bd346d"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aee2d79916f92a116f6478fb928bd346d">distance_of</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:aee2d79916f92a116f6478fb928bd346d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns euclidian distance of point A from point B.  <a href="namespaceemlabcpp.html#aee2d79916f92a116f6478fb928bd346d">More...</a><br /></td></tr>
<tr class="separator:aee2d79916f92a116f6478fb928bd346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855f415eda103a7b9807510a531e9fd"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a6855f415eda103a7b9807510a531e9fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6855f415eda103a7b9807510a531e9fd">point_angle</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="separator:a6855f415eda103a7b9807510a531e9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd2e186f6fcbc505b519cd701ca271a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aadd2e186f6fcbc505b519cd701ca271a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aadd2e186f6fcbc505b519cd701ca271a">lineary_interpolate_path</a> (std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; &gt; const &amp;ipath, float d_step)</td></tr>
<tr class="separator:aadd2e186f6fcbc505b519cd701ca271a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3ac578082bbaa2d40a6fcf52bbc70f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:acb3ac578082bbaa2d40a6fcf52bbc70f"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acb3ac578082bbaa2d40a6fcf52bbc70f">axis_projection_distance</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;axis_direction)</td></tr>
<tr class="memdesc:acb3ac578082bbaa2d40a6fcf52bbc70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to calculate distance of projection of point A.  <a href="namespaceemlabcpp.html#acb3ac578082bbaa2d40a6fcf52bbc70f">More...</a><br /></td></tr>
<tr class="separator:acb3ac578082bbaa2d40a6fcf52bbc70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">steps</a> (<a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a> dist, float dist_step, float angle_step)</td></tr>
<tr class="memdesc:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns steps necessary for linear interpolation of distance between poses 'dis', such that:  <a href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">More...</a><br /></td></tr>
<tr class="separator:a95b7c5f71b2d2128143bbd09bc6cb341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba96ee23c0c917523f3c8563b8bc748"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abba96ee23c0c917523f3c8563b8bc748">operator&lt;</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;y)</td></tr>
<tr class="separator:abba96ee23c0c917523f3c8563b8bc748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc23078b9a73f00019b97989e11ca8a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afdc23078b9a73f00019b97989e11ca8a">operator==</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;y)</td></tr>
<tr class="memdesc:afdc23078b9a73f00019b97989e11ca8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compares poses on their position and orientation  <a href="namespaceemlabcpp.html#afdc23078b9a73f00019b97989e11ca8a">More...</a><br /></td></tr>
<tr class="separator:afdc23078b9a73f00019b97989e11ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44a5c70f711a903c1f9bdff06220948"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae44a5c70f711a903c1f9bdff06220948">operator!=</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;y)</td></tr>
<tr class="memdesc:ae44a5c70f711a903c1f9bdff06220948"><td class="mdescLeft">&#160;</td><td class="mdescRight">negation of operator== between poses  <a href="namespaceemlabcpp.html#ae44a5c70f711a903c1f9bdff06220948">More...</a><br /></td></tr>
<tr class="separator:ae44a5c70f711a903c1f9bdff06220948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1e6e1d604ab0623e703f92b9f8d420"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7b1e6e1d604ab0623e703f92b9f8d420">distance_of</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;y)</td></tr>
<tr class="memdesc:a7b1e6e1d604ab0623e703f92b9f8d420"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns PoseDistance between provided poses  <a href="namespaceemlabcpp.html#a7b1e6e1d604ab0623e703f92b9f8d420">More...</a><br /></td></tr>
<tr class="separator:a7b1e6e1d604ab0623e703f92b9f8d420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc890d7b63d24b90427ec7efcadeebb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8bc890d7b63d24b90427ec7efcadeebb">lin_interp</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;from, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;goal, float factor)</td></tr>
<tr class="memdesc:a8bc890d7b63d24b90427ec7efcadeebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear interpolation between base se and goal pose, with factor 0 'base' is returned, with factor 1 'goal' is returned.  <a href="namespaceemlabcpp.html#a8bc890d7b63d24b90427ec7efcadeebb">More...</a><br /></td></tr>
<tr class="separator:a8bc890d7b63d24b90427ec7efcadeebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d079397f6eee1951635d6f718632a47"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0d079397f6eee1951635d6f718632a47">lineary_interpolate_path</a> (std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; const &amp;ipath, float d_step, float a_step)</td></tr>
<tr class="separator:a0d079397f6eee1951635d6f718632a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7324e7c913729faf1c4cf85b8e2f8252"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">transform</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;a, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="memdesc:a7324e7c913729faf1c4cf85b8e2f8252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point A is rotated based on 'transformation' orientation and than moved based on 'transformation' position.  <a href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">More...</a><br /></td></tr>
<tr class="separator:a7324e7c913729faf1c4cf85b8e2f8252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5488ffa871becfb4a72d72495c20cb90"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5488ffa871becfb4a72d72495c20cb90">transform</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;v, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="separator:a5488ffa871becfb4a72d72495c20cb90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7827b96d4e730d02704e7e77d6deeb4c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7827b96d4e730d02704e7e77d6deeb4c">transform</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="memdesc:a7827b96d4e730d02704e7e77d6deeb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose X is rotated based on 'transformation' orientation and than moved based on 'transformation' position.  <a href="namespaceemlabcpp.html#a7827b96d4e730d02704e7e77d6deeb4c">More...</a><br /></td></tr>
<tr class="separator:a7827b96d4e730d02704e7e77d6deeb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4e8ebb24e5ef876532d4b038ca322a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abf4e8ebb24e5ef876532d4b038ca322a"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abf4e8ebb24e5ef876532d4b038ca322a">transform</a> (<a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;mm, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="separator:abf4e8ebb24e5ef876532d4b038ca322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c68a5e49e40d77ea688170d077b6a3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa5c68a5e49e40d77ea688170d077b6a3">inverse</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x)</td></tr>
<tr class="separator:aa5c68a5e49e40d77ea688170d077b6a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a8dbe9b7a2ab048215d4c090f06b6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28a8dbe9b7a2ab048215d4c090f06b6e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a28a8dbe9b7a2ab048215d4c090f06b6e">inverse_transform</a> (T const &amp;item, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="separator:a28a8dbe9b7a2ab048215d4c090f06b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51b871c46d305f812f4bbc657e83fef"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac51b871c46d305f812f4bbc657e83fef">rotate</a> (<a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;x, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;quat)</td></tr>
<tr class="memdesc:ac51b871c46d305f812f4bbc657e83fef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pose X is rotated based on quaternion 'quad'.  <a href="namespaceemlabcpp.html#ac51b871c46d305f812f4bbc657e83fef">More...</a><br /></td></tr>
<tr class="separator:ac51b871c46d305f812f4bbc657e83fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a8c1a727af2aea597eae9a59a8836"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ada1a8c1a727af2aea597eae9a59a8836">inverse</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:ada1a8c1a727af2aea597eae9a59a8836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f578e487d804739e3f02e467df4455"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a03f578e487d804739e3f02e467df4455">operator-</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:a03f578e487d804739e3f02e467df4455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf7a47f1070c2934c537d138d405cf5"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s)</td></tr>
<tr class="separator:a1cf7a47f1070c2934c537d138d405cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e6b76b80a1aa107e0babd62f5f7af4"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad8e6b76b80a1aa107e0babd62f5f7af4">norm2_of</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:ad8e6b76b80a1aa107e0babd62f5f7af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1733dfd1ee4b7a05c2b14b5a003a975e"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1733dfd1ee4b7a05c2b14b5a003a975e">angle_shortest_path</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;m, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;n)</td></tr>
<tr class="separator:a1733dfd1ee4b7a05c2b14b5a003a975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f2fc42d6975a0e858e1a7fec61902c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6f2fc42d6975a0e858e1a7fec61902c4">slerp</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s, float <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>)</td></tr>
<tr class="separator:a6f2fc42d6975a0e858e1a7fec61902c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18552b09d9e56e372ff803166bfa4fa8"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a18552b09d9e56e372ff803166bfa4fa8">operator==</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s)</td></tr>
<tr class="separator:a18552b09d9e56e372ff803166bfa4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e0ecd7c170c87559b9de62a47df77a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a50e0ecd7c170c87559b9de62a47df77a">operator!=</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s)</td></tr>
<tr class="separator:a50e0ecd7c170c87559b9de62a47df77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6044bbf69503a7dfc2107e8928791c21"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6044bbf69503a7dfc2107e8928791c21">operator&lt;</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s)</td></tr>
<tr class="separator:a6044bbf69503a7dfc2107e8928791c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37dd3f09e5ee0c5f34d4890721eedab0"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37dd3f09e5ee0c5f34d4890721eedab0">operator*</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s)</td></tr>
<tr class="separator:a37dd3f09e5ee0c5f34d4890721eedab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34df7bcaa03713593d1de138ecf6381"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad34df7bcaa03713593d1de138ecf6381">operator*</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;x)</td></tr>
<tr class="separator:ad34df7bcaa03713593d1de138ecf6381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330b558b7ae6db318ed36fa2f3aec008"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a330b558b7ae6db318ed36fa2f3aec008">operator*</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;x, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:a330b558b7ae6db318ed36fa2f3aec008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6012e7482c7c10117d1bf94115b8a6bb"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6012e7482c7c10117d1bf94115b8a6bb">operator+</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;lh, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;rh)</td></tr>
<tr class="separator:a6012e7482c7c10117d1bf94115b8a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f705d338216b0192f28e2b34c97b3d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab5f705d338216b0192f28e2b34c97b3d">almost_equal</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;s, float eps=<a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>)</td></tr>
<tr class="separator:ab5f705d338216b0192f28e2b34c97b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502c46ab09d85973cfcaaf05be835ac"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af502c46ab09d85973cfcaaf05be835ac">shortest_arc_quat</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; x, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; y)</td></tr>
<tr class="separator:af502c46ab09d85973cfcaaf05be835ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca8ef1b6ac47e1cdf32fcde26d5cd52"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeca8ef1b6ac47e1cdf32fcde26d5cd52">rotate</a> (<a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;x, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:aeca8ef1b6ac47e1cdf32fcde26d5cd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86cb426b688da333795c5ceb721f03"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2b86cb426b688da333795c5ceb721f03">rotate</a> (<a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;x, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:a2b86cb426b688da333795c5ceb721f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb43931ad079507aa5c8ebf524035c4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aedb43931ad079507aa5c8ebf524035c4">rotate</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;v, <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;q)</td></tr>
<tr class="separator:aedb43931ad079507aa5c8ebf524035c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac294105427e19320821509a367462c36"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, std::size_t U&gt; </td></tr>
<tr class="memitem:ac294105427e19320821509a367462c36"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac294105427e19320821509a367462c36">center_of</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, U &gt; const &amp;s)</td></tr>
<tr class="separator:ac294105427e19320821509a367462c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d26ba6fb062781759f8b5f013fb82f"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a37d26ba6fb062781759f8b5f013fb82f"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a37d26ba6fb062781759f8b5f013fb82f">volume_of</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>)</td></tr>
<tr class="separator:a37d26ba6fb062781759f8b5f013fb82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3126eb05106e9a28a4556d31e6a961"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a9c3126eb05106e9a28a4556d31e6a961"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9c3126eb05106e9a28a4556d31e6a961">operator&lt;</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a9c3126eb05106e9a28a4556d31e6a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d39f24887788ae240b808e79d62de84"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a0d39f24887788ae240b808e79d62de84"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0d39f24887788ae240b808e79d62de84">operator&gt;</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a0d39f24887788ae240b808e79d62de84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00c6c3cb52ca970c9752454ce8fddf"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:a8d00c6c3cb52ca970c9752454ce8fddf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8d00c6c3cb52ca970c9752454ce8fddf">operator&lt;=</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a8d00c6c3cb52ca970c9752454ce8fddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac229488d4d6586cd9d9a325efdcb6627"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:ac229488d4d6586cd9d9a325efdcb6627"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac229488d4d6586cd9d9a325efdcb6627">operator&gt;=</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:ac229488d4d6586cd9d9a325efdcb6627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83f29891e0c7be2eee69b89588df758"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:ae83f29891e0c7be2eee69b89588df758"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae83f29891e0c7be2eee69b89588df758">operator==</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:ae83f29891e0c7be2eee69b89588df758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3614607d86949d19b640d9a33284429"><td class="memTemplParams" colspan="2">template&lt;typename Item , std::size_t N&gt; </td></tr>
<tr class="memitem:af3614607d86949d19b640d9a33284429"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af3614607d86949d19b640d9a33284429">operator!=</a> (<a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:af3614607d86949d19b640d9a33284429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59097c60aaf5eda7d31e4a2bc9161d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a59097c60aaf5eda7d31e4a2bc9161d8d">get_triangle_sphere_center</a> (<a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;tri)</td></tr>
<tr class="separator:a59097c60aaf5eda7d31e4a2bc9161d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07195d9b1972b37655b1c9a0b543d52b"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a07195d9b1972b37655b1c9a0b543d52b">normal_of</a> (<a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;tri)</td></tr>
<tr class="separator:a07195d9b1972b37655b1c9a0b543d52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7405050872ccfca2a64cb049e4def265"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7405050872ccfca2a64cb049e4def265">transform</a> (<a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;t, <a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;transformation)</td></tr>
<tr class="separator:a7405050872ccfca2a64cb049e4def265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bf2080b111dbe37490823f1faa48a6"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a21bf2080b111dbe37490823f1faa48a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a21bf2080b111dbe37490823f1faa48a6">scale</a> (<a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;t, <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;scales)</td></tr>
<tr class="separator:a21bf2080b111dbe37490823f1faa48a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8b6f63869b137c01f468f94fe66af2"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </td></tr>
<tr class="memitem:ade8b6f63869b137c01f468f94fe66af2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ade8b6f63869b137c01f468f94fe66af2">operator*</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, T s)</td></tr>
<tr class="memdesc:ade8b6f63869b137c01f468f94fe66af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#ade8b6f63869b137c01f468f94fe66af2">More...</a><br /></td></tr>
<tr class="separator:ade8b6f63869b137c01f468f94fe66af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc44ceacc244a528ddbe752ecd54b28"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T &gt; </td></tr>
<tr class="memitem:a1cc44ceacc244a528ddbe752ecd54b28"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1cc44ceacc244a528ddbe752ecd54b28">operator*</a> (T s, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a)</td></tr>
<tr class="memdesc:a1cc44ceacc244a528ddbe752ecd54b28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#a1cc44ceacc244a528ddbe752ecd54b28">More...</a><br /></td></tr>
<tr class="separator:a1cc44ceacc244a528ddbe752ecd54b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26988acd15fa707a1ab1d00f75617b6"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </td></tr>
<tr class="memitem:ad26988acd15fa707a1ab1d00f75617b6"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad26988acd15fa707a1ab1d00f75617b6">operator/</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, T s)</td></tr>
<tr class="memdesc:ad26988acd15fa707a1ab1d00f75617b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic.  <a href="namespaceemlabcpp.html#ad26988acd15fa707a1ab1d00f75617b6">More...</a><br /></td></tr>
<tr class="separator:ad26988acd15fa707a1ab1d00f75617b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b56a9133d031451181abceacdbed8a7"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a1b56a9133d031451181abceacdbed8a7"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1b56a9133d031451181abceacdbed8a7">dot</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:a1b56a9133d031451181abceacdbed8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the dot product between A and B.  <a href="namespaceemlabcpp.html#a1b56a9133d031451181abceacdbed8a7">More...</a><br /></td></tr>
<tr class="separator:a1b56a9133d031451181abceacdbed8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caad1b27b4b2959c43e9aa435558c35"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a3caad1b27b4b2959c43e9aa435558c35"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3caad1b27b4b2959c43e9aa435558c35">length2_of</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a)</td></tr>
<tr class="memdesc:a3caad1b27b4b2959c43e9aa435558c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared distance of A from [0,0,0], this is a squared length of vector represented by A.  <a href="namespaceemlabcpp.html#a3caad1b27b4b2959c43e9aa435558c35">More...</a><br /></td></tr>
<tr class="separator:a3caad1b27b4b2959c43e9aa435558c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8be9302783a0f5b41cc763d1029728"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a5c8be9302783a0f5b41cc763d1029728"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5c8be9302783a0f5b41cc763d1029728">length_of</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a)</td></tr>
<tr class="memdesc:a5c8be9302783a0f5b41cc763d1029728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns distance of A from [0,0,0], this is a length of vector represented by A.  <a href="namespaceemlabcpp.html#a5c8be9302783a0f5b41cc763d1029728">More...</a><br /></td></tr>
<tr class="separator:a5c8be9302783a0f5b41cc763d1029728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb0a9d462d8ff0ccbf431c08c7f6595"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a6eb0a9d462d8ff0ccbf431c08c7f6595"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6eb0a9d462d8ff0ccbf431c08c7f6595">normalized</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a)</td></tr>
<tr class="memdesc:a6eb0a9d462d8ff0ccbf431c08c7f6595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates normalized version of A, this means that length(A) equals to 1.  <a href="namespaceemlabcpp.html#a6eb0a9d462d8ff0ccbf431c08c7f6595">More...</a><br /></td></tr>
<tr class="separator:a6eb0a9d462d8ff0ccbf431c08c7f6595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636ba3f9919efa31f356bb6bca5e290d"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a636ba3f9919efa31f356bb6bca5e290d"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a636ba3f9919efa31f356bb6bca5e290d">abs</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a)</td></tr>
<tr class="memdesc:a636ba3f9919efa31f356bb6bca5e290d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates absolute version of A - removing signs on all dimensions.  <a href="namespaceemlabcpp.html#a636ba3f9919efa31f356bb6bca5e290d">More...</a><br /></td></tr>
<tr class="separator:a636ba3f9919efa31f356bb6bca5e290d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9cf42b0add3aa7eac2b215455f98ed"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:abe9cf42b0add3aa7eac2b215455f98ed"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="separator:abe9cf42b0add3aa7eac2b215455f98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a2f5b7b14c057c158d28c8e7538839"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:ac6a2f5b7b14c057c158d28c8e7538839"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac6a2f5b7b14c057c158d28c8e7538839">min</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="separator:ac6a2f5b7b14c057c158d28c8e7538839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f5ee359c0603a72727e357d9c99947"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a23f5ee359c0603a72727e357d9c99947"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a23f5ee359c0603a72727e357d9c99947">dimensional_max</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:a23f5ee359c0603a72727e357d9c99947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a C, where C[i] = max(A[i], B[i]) holds for 0 &lt;= i &lt; N.  <a href="namespaceemlabcpp.html#a23f5ee359c0603a72727e357d9c99947">More...</a><br /></td></tr>
<tr class="separator:a23f5ee359c0603a72727e357d9c99947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ff7aa782e3d7ec9c04000f324c0e9f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a52ff7aa782e3d7ec9c04000f324c0e9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a52ff7aa782e3d7ec9c04000f324c0e9f">dimensional_min</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="memdesc:a52ff7aa782e3d7ec9c04000f324c0e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a C, where C[i] = min(A[i], B[i]) holds for 0 &lt;= i &lt; N.  <a href="namespaceemlabcpp.html#a52ff7aa782e3d7ec9c04000f324c0e9f">More...</a><br /></td></tr>
<tr class="separator:a52ff7aa782e3d7ec9c04000f324c0e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358cff2d1682d9845caa4aee8d958365"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunction  = std::identity, typename Derived  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </td></tr>
<tr class="memitem:a358cff2d1682d9845caa4aee8d958365"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a358cff2d1682d9845caa4aee8d958365">dimensional_min_max_elem</a> (Container const &amp;cont, UnaryFunction &amp;&amp;<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>=std::identity{})</td></tr>
<tr class="separator:a358cff2d1682d9845caa4aee8d958365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebcdaef801eab209d5572706977fec8"><td class="memTemplParams" colspan="2">template&lt;typename Derived , std::size_t N&gt; </td></tr>
<tr class="memitem:a5ebcdaef801eab209d5572706977fec8"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5ebcdaef801eab209d5572706977fec8">lin_interp</a> (<a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;from, <a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;goal, float factor)</td></tr>
<tr class="separator:a5ebcdaef801eab209d5572706977fec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba061e073dffe44ebd226702b8a9256d"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:aba061e073dffe44ebd226702b8a9256d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aba061e073dffe44ebd226702b8a9256d">operator+</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; lh, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:aba061e073dffe44ebd226702b8a9256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd840c8670b877825d96bf91e62c76c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5cd840c8670b877825d96bf91e62c76c">cross_product</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;b)</td></tr>
<tr class="memdesc:a5cd840c8670b877825d96bf91e62c76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates cross product between points A and B.  <a href="namespaceemlabcpp.html#a5cd840c8670b877825d96bf91e62c76c">More...</a><br /></td></tr>
<tr class="separator:a5cd840c8670b877825d96bf91e62c76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ae9fabf0beb535e1dc1c08b3d0b7a6"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac8ae9fabf0beb535e1dc1c08b3d0b7a6">normal_of</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; const &amp;a)</td></tr>
<tr class="memdesc:ac8ae9fabf0beb535e1dc1c08b3d0b7a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a normal to a point A in two dimensions.  <a href="namespaceemlabcpp.html#ac8ae9fabf0beb535e1dc1c08b3d0b7a6">More...</a><br /></td></tr>
<tr class="separator:ac8ae9fabf0beb535e1dc1c08b3d0b7a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7f7c11dfd7ca203f3363abfe59318"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:abcf7f7c11dfd7ca203f3363abfe59318"><td class="memTemplItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abcf7f7c11dfd7ca203f3363abfe59318">vector_angle</a> (<a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;a, <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;b)</td></tr>
<tr class="separator:abcf7f7c11dfd7ca203f3363abfe59318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512f1fd6d6a6aa3d5094088865158e23"><td class="memTemplParams" colspan="2">template&lt;matrix_like LH, matrix_like RH&gt; </td></tr>
<tr class="memitem:a512f1fd6d6a6aa3d5094088865158e23"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a512f1fd6d6a6aa3d5094088865158e23">requires</a> (LH::rows==RH::rows &amp;&amp;LH::cols==RH::cols) const expr auto operator</td></tr>
<tr class="separator:a512f1fd6d6a6aa3d5094088865158e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621414bdb005465241465f455e742ca"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:a9621414bdb005465241465f455e742ca"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9621414bdb005465241465f455e742ca">requires</a> (M::rows==2 &amp;&amp;M::cols==2) const expr auto determinant(M const &amp;m)</td></tr>
<tr class="separator:a9621414bdb005465241465f455e742ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7b165281b38eb416a5f581aca02c45"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:a9d7b165281b38eb416a5f581aca02c45"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9d7b165281b38eb416a5f581aca02c45">requires</a> (M::rows &gt; 2 &amp;&amp;M::cols==M::rows) const expr auto determinant(M const &amp;m)</td></tr>
<tr class="separator:a9d7b165281b38eb416a5f581aca02c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9679354218890ed9c289c674a125378"><td class="memTemplParams" colspan="2">template&lt;matrix_like M&gt; </td></tr>
<tr class="memitem:ae9679354218890ed9c289c674a125378"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">requires</a> (M::rows==1 &amp;&amp;M::cols==1) const expr <a class="el" href="classemlabcpp_1_1matrix.html">matrix</a>&lt; M</td></tr>
<tr class="separator:ae9679354218890ed9c289c674a125378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6154c4150903826b9b84540c27036ad"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ae6154c4150903826b9b84540c27036ad"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae6154c4150903826b9b84540c27036ad">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;sb)</td></tr>
<tr class="separator:ae6154c4150903826b9b84540c27036ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplParams" colspan="2">template&lt;typename... Callables&gt; </td></tr>
<tr class="memitem:ab077da8cbabe4cc68820537ddc602b91"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab077da8cbabe4cc68820537ddc602b91">matcher</a> (Callables &amp;&amp;...) -&gt; <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td></tr>
<tr class="separator:ab077da8cbabe4cc68820537ddc602b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a57181a407fd6f29a50664f8ba4cb44cd">match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a57181a407fd6f29a50664f8ba4cb44cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplParams" colspan="2">template&lt;typename Variant , typename... Callables&gt; </td></tr>
<tr class="memitem:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a63a6aaa5fc338d3d342d90a14225fe82">apply_on_match</a> (Variant &amp;&amp;var, Callables &amp;&amp;... cals)</td></tr>
<tr class="separator:a63a6aaa5fc338d3d342d90a14225fe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f7d96e0c4be50762f3e1b7c53335f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Compare &gt; </td></tr>
<tr class="memitem:a90f7d96e0c4be50762f3e1b7c53335f6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp</a> (T const &amp;x, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;mm, Compare &amp;&amp;comp)</td></tr>
<tr class="separator:a90f7d96e0c4be50762f3e1b7c53335f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba67676f525e90205fbedd74cc885b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ba67676f525e90205fbedd74cc885b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr T const  &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8ba67676f525e90205fbedd74cc885b9">clamp</a> (T const &amp;x, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;mm)</td></tr>
<tr class="separator:a8ba67676f525e90205fbedd74cc885b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478ead96ff195d7de7ce62ed8b67a9ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a478ead96ff195d7de7ce62ed8b67a9ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a478ead96ff195d7de7ce62ed8b67a9ad">requires</a> (std::same_as&lt; Args, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; &gt; &amp;&amp;...) const expr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; intersection(<a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;head</td></tr>
<tr class="separator:a478ead96ff195d7de7ce62ed8b67a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76527f9e9f64c2786307e3cbc9153c73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a76527f9e9f64c2786307e3cbc9153c73">f</a> (<a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>)</td></tr>
<tr class="separator:a76527f9e9f64c2786307e3cbc9153c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69958489560ea5ebfccc956fbba6a0cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69958489560ea5ebfccc956fbba6a0cb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a69958489560ea5ebfccc956fbba6a0cb">expand</a> (<a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;mm, T const &amp;val)</td></tr>
<tr class="separator:a69958489560ea5ebfccc956fbba6a0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9618d7aa05121ef5c8552c4ce580953e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9618d7aa05121ef5c8552c4ce580953e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9618d7aa05121ef5c8552c4ce580953e">contains</a> (<a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;mm, T const &amp;val)</td></tr>
<tr class="separator:a9618d7aa05121ef5c8552c4ce580953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a384e4bb5a921ff231358ff63aeecbe77"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">operator*</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a384e4bb5a921ff231358ff63aeecbe77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together.  <a href="namespaceemlabcpp.html#a384e4bb5a921ff231358ff63aeecbe77">More...</a><br /></td></tr>
<tr class="separator:a384e4bb5a921ff231358ff63aeecbe77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplParams" colspan="2">template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </td></tr>
<tr class="memitem:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">operator/</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt; lh, <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt; rh)</td></tr>
<tr class="memdesc:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted.  <a href="namespaceemlabcpp.html#a1fdcd2bf6efc13dd21e3298c777d4982">More...</a><br /></td></tr>
<tr class="separator:a1fdcd2bf6efc13dd21e3298c777d4982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplParams" colspan="2">template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a5519896c5f0324265089711b6a020642"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a5519896c5f0324265089711b6a020642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square root of physical quantity is square root of it's value and the exponents are divided in half.  <a href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">More...</a><br /></td></tr>
<tr class="separator:a5519896c5f0324265089711b6a020642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplParams" colspan="2">template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </td></tr>
<tr class="memitem:a9b9eb800885b61e8071ef11e69debdf6"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow</a> (<a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt; val)</td></tr>
<tr class="memdesc:a9b9eb800885b61e8071ef11e69debdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power of physical quantity is power of root of it's value and the exponents are multiplied by the value.  <a href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">More...</a><br /></td></tr>
<tr class="separator:a9b9eb800885b61e8071ef11e69debdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc080f9334a6fec6101a6d803f7cb28"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:aadc080f9334a6fec6101a6d803f7cb28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aadc080f9334a6fec6101a6d803f7cb28">update_limits</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt; lim)</td></tr>
<tr class="separator:aadc080f9334a6fec6101a6d803f7cb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac578d4bcbce0973184093fa8cce2da33"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:ac578d4bcbce0973184093fa8cce2da33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac578d4bcbce0973184093fa8cce2da33">update_output</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, float output)</td></tr>
<tr class="separator:ac578d4bcbce0973184093fa8cce2da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7bb8b8ced9bb2a501cc61ced29e7801d">update</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, TimeType now, float measured, float desired)</td></tr>
<tr class="memdesc:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this reularly, the meaning of time value 'now' is up to you, just be consistent.  <a href="namespaceemlabcpp.html#a7bb8b8ced9bb2a501cc61ced29e7801d">More...</a><br /></td></tr>
<tr class="separator:a7bb8b8ced9bb2a501cc61ced29e7801d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802d2ec172423fb3984b1e88336f6233"><td class="memTemplParams" colspan="2">template&lt;typename TimeType &gt; </td></tr>
<tr class="memitem:a802d2ec172423fb3984b1e88336f6233"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a802d2ec172423fb3984b1e88336f6233">reset</a> (<a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;<a class="el" href="structemlabcpp_1_1pid.html">pid</a>, TimeType now, float last_measured)</td></tr>
<tr class="separator:a802d2ec172423fb3984b1e88336f6233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa769755c5f91ef62dc9d15f40311e640"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:aa769755c5f91ef62dc9d15f40311e640"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa769755c5f91ef62dc9d15f40311e640">operator+</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const rhs)</td></tr>
<tr class="memdesc:aa769755c5f91ef62dc9d15f40311e640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#aa769755c5f91ef62dc9d15f40311e640">More...</a><br /></td></tr>
<tr class="separator:aa769755c5f91ef62dc9d15f40311e640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89a86af41d0afc8c294f691f03dba3"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a1c89a86af41d0afc8c294f691f03dba3"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1c89a86af41d0afc8c294f691f03dba3">operator-</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; lhs, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const rhs)</td></tr>
<tr class="memdesc:a1c89a86af41d0afc8c294f691f03dba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of quantities with same Derived and value_type.  <a href="namespaceemlabcpp.html#a1c89a86af41d0afc8c294f691f03dba3">More...</a><br /></td></tr>
<tr class="separator:a1c89a86af41d0afc8c294f691f03dba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a99b9695c313b1a54ab1fdc47416b9"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a81a99b9695c313b1a54ab1fdc47416b9"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a81a99b9695c313b1a54ab1fdc47416b9">operator-</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const val)</td></tr>
<tr class="memdesc:a81a99b9695c313b1a54ab1fdc47416b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides negation of the quantity.  <a href="namespaceemlabcpp.html#a81a99b9695c313b1a54ab1fdc47416b9">More...</a><br /></td></tr>
<tr class="separator:a81a99b9695c313b1a54ab1fdc47416b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044797e0296bafbfc9cb5ec86bfdb0e4"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </td></tr>
<tr class="memitem:a044797e0296bafbfc9cb5ec86bfdb0e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a044797e0296bafbfc9cb5ec86bfdb0e4">operator&lt;</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const lhs, RhValueType const rhs)</td></tr>
<tr class="memdesc:a044797e0296bafbfc9cb5ec86bfdb0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides abillity to compare quantity with non-quantity arithmetic value.  <a href="namespaceemlabcpp.html#a044797e0296bafbfc9cb5ec86bfdb0e4">More...</a><br /></td></tr>
<tr class="separator:a044797e0296bafbfc9cb5ec86bfdb0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81633fa08052523cd4fb5f315a286cce"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </td></tr>
<tr class="memitem:a81633fa08052523cd4fb5f315a286cce"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a81633fa08052523cd4fb5f315a286cce">operator&lt;</a> (LhValueType const lhs, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const rhs)</td></tr>
<tr class="memdesc:a81633fa08052523cd4fb5f315a286cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides abillity to compare quantity with non-quantity arithmetic value.  <a href="namespaceemlabcpp.html#a81633fa08052523cd4fb5f315a286cce">More...</a><br /></td></tr>
<tr class="separator:a81633fa08052523cd4fb5f315a286cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113ae6d930d0d7b6b4cea3e105ef3c89"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a113ae6d930d0d7b6b4cea3e105ef3c89"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a113ae6d930d0d7b6b4cea3e105ef3c89">operator*</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto const val)</td></tr>
<tr class="memdesc:a113ae6d930d0d7b6b4cea3e105ef3c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a113ae6d930d0d7b6b4cea3e105ef3c89">More...</a><br /></td></tr>
<tr class="separator:a113ae6d930d0d7b6b4cea3e105ef3c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992eaf6dceaf1c7d3c11238f698ff88c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a992eaf6dceaf1c7d3c11238f698ff88c"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a992eaf6dceaf1c7d3c11238f698ff88c">operator/</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; q, <a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto const val)</td></tr>
<tr class="memdesc:a992eaf6dceaf1c7d3c11238f698ff88c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of quantity by it's value_type.  <a href="namespaceemlabcpp.html#a992eaf6dceaf1c7d3c11238f698ff88c">More...</a><br /></td></tr>
<tr class="separator:a992eaf6dceaf1c7d3c11238f698ff88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ffa44557c5251237a919d0843f13cc"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a50ffa44557c5251237a919d0843f13cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a50ffa44557c5251237a919d0843f13cc">abs</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const q)</td></tr>
<tr class="memdesc:a50ffa44557c5251237a919d0843f13cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with absolute value of internal value.  <a href="namespaceemlabcpp.html#a50ffa44557c5251237a919d0843f13cc">More...</a><br /></td></tr>
<tr class="separator:a50ffa44557c5251237a919d0843f13cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89767bdacebf048b6e8cc6a17b9663a0"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a89767bdacebf048b6e8cc6a17b9663a0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a89767bdacebf048b6e8cc6a17b9663a0">cos</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const u)</td></tr>
<tr class="memdesc:a89767bdacebf048b6e8cc6a17b9663a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns cosinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#a89767bdacebf048b6e8cc6a17b9663a0">More...</a><br /></td></tr>
<tr class="separator:a89767bdacebf048b6e8cc6a17b9663a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5106ef8ad66345637cf8b13dd1fda9ec"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a5106ef8ad66345637cf8b13dd1fda9ec"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5106ef8ad66345637cf8b13dd1fda9ec">sin</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const u)</td></tr>
<tr class="memdesc:a5106ef8ad66345637cf8b13dd1fda9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns sinus of the quantity as scalar.  <a href="namespaceemlabcpp.html#a5106ef8ad66345637cf8b13dd1fda9ec">More...</a><br /></td></tr>
<tr class="separator:a5106ef8ad66345637cf8b13dd1fda9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eab1ea813bee66236fa93054eb0fae5"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a5eab1ea813bee66236fa93054eb0fae5"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5eab1ea813bee66236fa93054eb0fae5">max</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const lh, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const rh)</td></tr>
<tr class="memdesc:a5eab1ea813bee66236fa93054eb0fae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with maximum value of one of the quantities.  <a href="namespaceemlabcpp.html#a5eab1ea813bee66236fa93054eb0fae5">More...</a><br /></td></tr>
<tr class="separator:a5eab1ea813bee66236fa93054eb0fae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6919f10a6a4596b7b33d935ef44c8b1c"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a6919f10a6a4596b7b33d935ef44c8b1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6919f10a6a4596b7b33d935ef44c8b1c">min</a> (<a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const lh, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const rh)</td></tr>
<tr class="memdesc:a6919f10a6a4596b7b33d935ef44c8b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quantity with minimum value of one of the quantities.  <a href="namespaceemlabcpp.html#a6919f10a6a4596b7b33d935ef44c8b1c">More...</a><br /></td></tr>
<tr class="separator:a6919f10a6a4596b7b33d935ef44c8b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389a5cc86ed797a145ffdeccf2782d88"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a389a5cc86ed797a145ffdeccf2782d88"><td class="memTemplItemLeft" align="right" valign="top">constexpr Derived&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a389a5cc86ed797a145ffdeccf2782d88">operator*</a> (ValueType const val, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const q)</td></tr>
<tr class="memdesc:a389a5cc86ed797a145ffdeccf2782d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a389a5cc86ed797a145ffdeccf2782d88">More...</a><br /></td></tr>
<tr class="separator:a389a5cc86ed797a145ffdeccf2782d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1917205f8db3c6bf0d76651f4a20ea7f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ValueType &gt; </td></tr>
<tr class="memitem:a1917205f8db3c6bf0d76651f4a20ea7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1917205f8db3c6bf0d76651f4a20ea7f">operator/</a> (ValueType const val, <a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const q)</td></tr>
<tr class="memdesc:a1917205f8db3c6bf0d76651f4a20ea7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division of value_type by quantity returns quantity.  <a href="namespaceemlabcpp.html#a1917205f8db3c6bf0d76651f4a20ea7f">More...</a><br /></td></tr>
<tr class="separator:a1917205f8db3c6bf0d76651f4a20ea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range</a> (Numeric from, Numeric to)</td></tr>
<tr class="memdesc:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [from, to)  <a href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">More...</a><br /></td></tr>
<tr class="separator:acf5a156c767ed17a892cc7e9b5acd2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace588590ccd59087b704005a3c04caae"><td class="memTemplParams" colspan="2">template&lt;typename Numeric &gt; </td></tr>
<tr class="memitem:ace588590ccd59087b704005a3c04caae"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ace588590ccd59087b704005a3c04caae">range</a> (Numeric to)</td></tr>
<tr class="memdesc:ace588590ccd59087b704005a3c04caae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds numeric view over interval [0, to)  <a href="namespaceemlabcpp.html#ace588590ccd59087b704005a3c04caae">More...</a><br /></td></tr>
<tr class="separator:ace588590ccd59087b704005a3c04caae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3006d6f69314abae91dc0740a404ddf"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ad3006d6f69314abae91dc0740a404ddf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad3006d6f69314abae91dc0740a404ddf">operator&lt;=&gt;</a> (<a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:ad3006d6f69314abae91dc0740a404ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f4b2a0c37593a9fe9fa24e82055731"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a45f4b2a0c37593a9fe9fa24e82055731"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a45f4b2a0c37593a9fe9fa24e82055731">operator==</a> (<a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a45f4b2a0c37593a9fe9fa24e82055731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6181af592879c12a867b98e75a8fafef"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a6181af592879c12a867b98e75a8fafef"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6181af592879c12a867b98e75a8fafef">operator!=</a> (<a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a6181af592879c12a867b98e75a8fafef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335b4e955623092b8021cbbb539eaeda"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a335b4e955623092b8021cbbb539eaeda"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a335b4e955623092b8021cbbb539eaeda">requires</a> (<a class="el" href="namespaceemlabcpp.html#a3d6bbe05fdc4482798a8777fd89bd79c">trivial_for_static_storage</a>&lt; T &gt;) struct <a class="el" href="structemlabcpp_1_1static__storage.html">static_storage</a>&lt; T</td></tr>
<tr class="separator:a335b4e955623092b8021cbbb539eaeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d3558f494b4daf086216cedf167ba7"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#a5dc3e436ef66e826d36130478f13fcc2">pointer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data</a> () noexcept</td></tr>
<tr class="memdesc:a22d3558f494b4daf086216cedf167ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to first item of the storage.  <a href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">More...</a><br /></td></tr>
<tr class="separator:a22d3558f494b4daf086216cedf167ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a005d416169624e48fd25482bb644b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa6a005d416169624e48fd25482bb644b"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa6a005d416169624e48fd25482bb644b">emplace_item</a> (<a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const i, Args &amp;&amp;... <a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>) noexcept(std::is_nothrow_constructible_v&lt; T, Args... &gt;)</td></tr>
<tr class="memdesc:aa6a005d416169624e48fd25482bb644b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an item at position i with arguments args...  <a href="namespaceemlabcpp.html#aa6a005d416169624e48fd25482bb644b">More...</a><br /></td></tr>
<tr class="separator:aa6a005d416169624e48fd25482bb644b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02c8301ef4db0c17e59d9e6b100420a"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ab02c8301ef4db0c17e59d9e6b100420a">delete_item</a> (<a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const i) noexcept(std::is_nothrow_destructible_v&lt; T &gt;)</td></tr>
<tr class="memdesc:ab02c8301ef4db0c17e59d9e6b100420a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructs an item at position i.  <a href="namespaceemlabcpp.html#ab02c8301ef4db0c17e59d9e6b100420a">More...</a><br /></td></tr>
<tr class="separator:ab02c8301ef4db0c17e59d9e6b100420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e01294f96a5357c8e80f5c27d081b3"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#a32d3de1ecae7eb79f5f6073bcb407b70">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a38e01294f96a5357c8e80f5c27d081b3">operator[]</a> (<a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const i) noexcept</td></tr>
<tr class="memdesc:a38e01294f96a5357c8e80f5c27d081b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a reference to item at position i.  <a href="namespaceemlabcpp.html#a38e01294f96a5357c8e80f5c27d081b3">More...</a><br /></td></tr>
<tr class="separator:a38e01294f96a5357c8e80f5c27d081b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6977046b5b7b9ce51390b724488d378"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af6977046b5b7b9ce51390b724488d378"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af6977046b5b7b9ce51390b724488d378">operator&lt;=&gt;</a> (<a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:af6977046b5b7b9ce51390b724488d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3061f1658ea319c507053d8c7eb785f"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:af3061f1658ea319c507053d8c7eb785f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af3061f1658ea319c507053d8c7eb785f">operator==</a> (<a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:af3061f1658ea319c507053d8c7eb785f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddd63976678b7a53c3076c5006a15f5"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7ddd63976678b7a53c3076c5006a15f5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7ddd63976678b7a53c3076c5006a15f5">operator!=</a> (<a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh)</td></tr>
<tr class="separator:a7ddd63976678b7a53c3076c5006a15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736be2315b7c53a88f64e165cbeb3fab"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a736be2315b7c53a88f64e165cbeb3fab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a736be2315b7c53a88f64e165cbeb3fab">swap</a> (<a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;rh) noexcept</td></tr>
<tr class="separator:a736be2315b7c53a88f64e165cbeb3fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5b62f09ff5468bc513cac30ace3d6c58">pretty_type_name</a> ()</td></tr>
<tr class="separator:a5b62f09ff5468bc513cac30ace3d6c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#acd74c7df9ccef5ce376d2c3fe2ef8908">requires</a> (sizeof(uint8_t)==<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;</td></tr>
<tr class="separator:acd74c7df9ccef5ce376d2c3fe2ef8908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3dcd56ce6fdffb4ebcf8a4c079335d8e">requires</a> (sizeof(uint16_t)==<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;</td></tr>
<tr class="separator:a3dcd56ce6fdffb4ebcf8a4c079335d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:ac39ed97224e397106e08c6e04012e62a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac39ed97224e397106e08c6e04012e62a">requires</a> (sizeof(uint32_t)==<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;</td></tr>
<tr class="separator:ac39ed97224e397106e08c6e04012e62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2acb59e904f4530e0e8d42e98f67bcaa">requires</a> (sizeof(uint64_t)==<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>) struct <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;</td></tr>
<tr class="separator:a2acb59e904f4530e0e8d42e98f67bcaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2649988155d01327137383a7fb2c90"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:aeb2649988155d01327137383a7fb2c90"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeb2649988155d01327137383a7fb2c90">operator==</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; const &amp;rh)</td></tr>
<tr class="separator:aeb2649988155d01327137383a7fb2c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3573e4ac276034b44026405adacb12a4"><td class="memTemplParams" colspan="2">template&lt;typename IteratorLh , typename IteratorRh &gt; </td></tr>
<tr class="memitem:a3573e4ac276034b44026405adacb12a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3573e4ac276034b44026405adacb12a4">operator!=</a> (<a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; const &amp;rh)</td></tr>
<tr class="separator:a3573e4ac276034b44026405adacb12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:a4b726ddab4f550f3e186f177243cb09b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view</a> (Container &amp;cont) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td></tr>
<tr class="memdesc:a4b726ddab4f550f3e186f177243cb09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The container deduction guide uses iterator_of_t.  <a href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">More...</a><br /></td></tr>
<tr class="separator:a4b726ddab4f550f3e186f177243cb09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622f11a522f1ded8232d2e13e7f41337"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a622f11a522f1ded8232d2e13e7f41337"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a622f11a522f1ded8232d2e13e7f41337">view_n</a> (Iter begin, std::size_t const n)</td></tr>
<tr class="memdesc:a622f11a522f1ded8232d2e13e7f41337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range!  <a href="namespaceemlabcpp.html#a622f11a522f1ded8232d2e13e7f41337">More...</a><br /></td></tr>
<tr class="separator:a622f11a522f1ded8232d2e13e7f41337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcf3cf10bd4814024f7177751b63c26"><td class="memTemplParams" colspan="2">template&lt;data_container Container&gt; </td></tr>
<tr class="memitem:a7dcf3cf10bd4814024f7177751b63c26"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7dcf3cf10bd4814024f7177751b63c26">data_view</a> (Container &amp;cont)</td></tr>
<tr class="separator:a7dcf3cf10bd4814024f7177751b63c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323c6de62f296a43d492b2468514f8e8"><td class="memTemplParams" colspan="2">template&lt;range_container Container&gt; </td></tr>
<tr class="memitem:a323c6de62f296a43d492b2468514f8e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a323c6de62f296a43d492b2468514f8e8">trim_view</a> (Container &amp;cont, float const r)</td></tr>
<tr class="memdesc:a323c6de62f296a43d492b2468514f8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items.  <a href="namespaceemlabcpp.html#a323c6de62f296a43d492b2468514f8e8">More...</a><br /></td></tr>
<tr class="separator:a323c6de62f296a43d492b2468514f8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">reversed</a> (<a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;<a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>) -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype(std::rbegin(<a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>)) &gt;</td></tr>
<tr class="memdesc:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns view to the Container in reverse order.  <a href="namespaceemlabcpp.html#a2fe2d2bf491db344cf04e4c2b9d799b8">More...</a><br /></td></tr>
<tr class="separator:a2fe2d2bf491db344cf04e4c2b9d799b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06cdf4e6872ac961315f173c9d21aa5"><td class="memTemplParams" colspan="2">template&lt;typename Iterator , typename EndIterator &gt; </td></tr>
<tr class="memitem:af06cdf4e6872ac961315f173c9d21aa5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af06cdf4e6872ac961315f173c9d21aa5">string_serialize_view</a> (auto &amp;&amp;w, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator, EndIterator &gt; const &amp;output)</td></tr>
<tr class="separator:af06cdf4e6872ac961315f173c9d21aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5526fd1c86103b5f5be71eb8083d84ea"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a5526fd1c86103b5f5be71eb8083d84ea"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5526fd1c86103b5f5be71eb8083d84ea">visit_index</a> (Visitor &amp;&amp;vis, Variant const &amp;var)</td></tr>
<tr class="separator:a5526fd1c86103b5f5be71eb8083d84ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="memdesc:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reimplementation of <code>std::visit</code>.  <a href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">More...</a><br /></td></tr>
<tr class="separator:a6e4b7b6dd8a3a27f7f7bcea52f265b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplParams" colspan="2">template&lt;typename Visitor , typename Variant &gt; </td></tr>
<tr class="memitem:a75cf44a6df8173ea7a46979f57546332"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit</a> (Visitor &amp;&amp;vis, Variant &amp;&amp;var)</td></tr>
<tr class="memdesc:a75cf44a6df8173ea7a46979f57546332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines <code>visit</code> and <code>std::apply</code> into one step - provided variant is expanded with <code>visit</code> and <code>apply</code> is called on the present alternative, items from <code>apply</code> are passed to calle to visitor <code>vis</code>.  <a href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">More...</a><br /></td></tr>
<tr class="separator:a75cf44a6df8173ea7a46979f57546332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a4a90457babf1c49444a526a98007a751"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a4a90457babf1c49444a526a98007a751">operator+</a> (<a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; lh, std::ptrdiff_t m)</td></tr>
<tr class="separator:a4a90457babf1c49444a526a98007a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae6b9af9632567eb99841585b4f897"><td class="memTemplParams" colspan="2">template&lt;typename... Iterators&gt; </td></tr>
<tr class="memitem:a00ae6b9af9632567eb99841585b4f897"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a00ae6b9af9632567eb99841585b4f897">operator!=</a> (<a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; const &amp;lh, <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; const &amp;rh)</td></tr>
<tr class="separator:a00ae6b9af9632567eb99841585b4f897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplParams" colspan="2">template&lt;range_container... Ts&gt; </td></tr>
<tr class="memitem:a41ab261a0f296f3c9862e59e12339885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip</a> (Ts &amp;&amp;... cont)</td></tr>
<tr class="memdesc:a41ab261a0f296f3c9862e59e12339885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view of zip iterators for specified containers.  <a href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">More...</a><br /></td></tr>
<tr class="separator:a41ab261a0f296f3c9862e59e12339885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplParams" colspan="2">template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </td></tr>
<tr class="memitem:aa8b8f5742901528282a9da6b8317e7b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl</a> (TuplesTuple &amp;&amp;tpls, std::index_sequence&lt; ItemIndexes... &gt;, std::index_sequence&lt; TupleIndexes... &gt;)</td></tr>
<tr class="separator:aa8b8f5742901528282a9da6b8317e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d4ae07c2d875b52377456faf19fe92"><td class="memTemplParams" colspan="2">template&lt;gettable_container Tuple, gettable_container... Tuples&gt; </td></tr>
<tr class="memitem:a81d4ae07c2d875b52377456faf19fe92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a81d4ae07c2d875b52377456faf19fe92">zip</a> (Tuple &amp;&amp;frst, Tuples &amp;&amp;... tpls)</td></tr>
<tr class="memdesc:a81d4ae07c2d875b52377456faf19fe92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips a set of gettable containers of same size into a tuples.  <a href="namespaceemlabcpp.html#a81d4ae07c2d875b52377456faf19fe92">More...</a><br /></td></tr>
<tr class="separator:a81d4ae07c2d875b52377456faf19fe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a20db02f115d34db629106a39c5194e18"><td class="memItemLeft" align="right" valign="top">constexpr float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a> = 1.19e-07<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a></td></tr>
<tr class="separator:a20db02f115d34db629106a39c5194e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae863a37ceeaded64e65fc9ac024f70d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a></td></tr>
<tr class="separator:ae863a37ceeaded64e65fc9ac024f70d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3571963bbe0982f9987b78b111c626"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a> {}</td></tr>
<tr class="separator:a9f3571963bbe0982f9987b78b111c626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a7b5a68de4881301e46697c48654d8477"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">bounded_constant</a> = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;{}</td></tr>
<tr class="memdesc:a7b5a68de4881301e46697c48654d8477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type alias for bounded index constants.  <a href="namespaceemlabcpp.html#a7b5a68de4881301e46697c48654d8477">More...</a><br /></td></tr>
<tr class="separator:a7b5a68de4881301e46697c48654d8477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">bounded_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a136e8541fc31cc1b24989ded96168d29">detail::bounded_derived_test</a>( val ); }</td></tr>
<tr class="memdesc:add79493bcf07bd4c54afffe3a0f3ee00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept that matchestype deriving from bounded.  <a href="namespaceemlabcpp.html#add79493bcf07bd4c54afffe3a0f3ee00">More...</a><br /></td></tr>
<tr class="separator:add79493bcf07bd4c54afffe3a0f3ee00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba98b073e1c4277207d152957581b84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ba98b073e1c4277207d152957581b84"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1ba98b073e1c4277207d152957581b84">additive_operators</a></td></tr>
<tr class="separator:a1ba98b073e1c4277207d152957581b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de77964b77f4e30ef2e570442171e8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5de77964b77f4e30ef2e570442171e8c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5de77964b77f4e30ef2e570442171e8c">multiplicative_operators</a></td></tr>
<tr class="separator:a5de77964b77f4e30ef2e570442171e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94924279b38cf1803ee0f01cb4889b24"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a> = <a class="el" href="namespaceemlabcpp.html#a1ba98b073e1c4277207d152957581b84">additive_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#a5de77964b77f4e30ef2e570442171e8c">multiplicative_operators</a>&lt; T &gt;</td></tr>
<tr class="separator:a94924279b38cf1803ee0f01cb4889b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a></td></tr>
<tr class="separator:aa70c87fb6240fb7ebbfbb27d7b25b999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5494e6f6f24a2fd7e7ccfaecb31944b3">arithmetic_like</a> = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td></tr>
<tr class="separator:a5494e6f6f24a2fd7e7ccfaecb31944b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td></tr>
<tr class="separator:a61e7321a7721894fde42b2da9bf2cbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a></td></tr>
<tr class="separator:adb54eee14fc87e50de7f6ed35ad1aba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a></td></tr>
<tr class="memdesc:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible  <a href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">More...</a><br /></td></tr>
<tr class="separator:a904e4439ee5b6a29ec1c9a5a6d404c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d100afeb63e0735bf1abe40e8f1dda3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d100afeb63e0735bf1abe40e8f1dda3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a6d100afeb63e0735bf1abe40e8f1dda3">data_container</a></td></tr>
<tr class="separator:a6d100afeb63e0735bf1abe40e8f1dda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a> = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#a6d100afeb63e0735bf1abe40e8f1dda3">data_container</a>&lt; T &gt;</td></tr>
<tr class="separator:ac6a5e3253aa7ea8bcd6574b3274c74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad5b78b4d7a2e426170153951069c76cf"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a></td></tr>
<tr class="separator:ad5b78b4d7a2e426170153951069c76cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f5be4da9ac6f367034af1f5028827"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ValueType &gt; </td></tr>
<tr class="memitem:ae70f5be4da9ac6f367034af1f5028827"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae70f5be4da9ac6f367034af1f5028827">range_container_with</a></td></tr>
<tr class="separator:ae70f5be4da9ac6f367034af1f5028827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04004185c5cfd085f40f3ab99321b5c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Iterator &gt; </td></tr>
<tr class="memitem:ac04004185c5cfd085f40f3ab99321b5c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac04004185c5cfd085f40f3ab99321b5c">range_container_with_iter</a></td></tr>
<tr class="separator:ac04004185c5cfd085f40f3ab99321b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ebf6dfb3da372e9238ce6f14be53edd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ValueType &gt; </td></tr>
<tr class="memitem:a5ebf6dfb3da372e9238ce6f14be53edd"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5ebf6dfb3da372e9238ce6f14be53edd">data_container_with</a></td></tr>
<tr class="separator:a5ebf6dfb3da372e9238ce6f14be53edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec222a8d7edb4ed19a7049e9ad809d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DataIterator &gt; </td></tr>
<tr class="memitem:a3ec222a8d7edb4ed19a7049e9ad809d0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3ec222a8d7edb4ed19a7049e9ad809d0">data_container_with_iter</a></td></tr>
<tr class="separator:a3ec222a8d7edb4ed19a7049e9ad809d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a></td></tr>
<tr class="separator:a8114b1d4bc758992dd14a1d64bd454c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplParams" colspan="2">template&lt;typename UnaryCallable , typename Container &gt; </td></tr>
<tr class="memitem:abeb742c691973ef2d34b0ace4d8eef15"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#abeb742c691973ef2d34b0ace4d8eef15">container_invocable</a></td></tr>
<tr class="separator:abeb742c691973ef2d34b0ace4d8eef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplParams" colspan="2">template&lt;typename UnaryCallable , typename ReturnValue , typename... Args&gt; </td></tr>
<tr class="memitem:a5219e24bd076b3c65f56c69b9025dd69"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5219e24bd076b3c65f56c69b9025dd69">invocable_returning</a></td></tr>
<tr class="separator:a5219e24bd076b3c65f56c69b9025dd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27325f314502897567307b29b2b03776"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a27325f314502897567307b29b2b03776">ostreamlike</a></td></tr>
<tr class="separator:a27325f314502897567307b29b2b03776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa360bfc94fbbd8ed260477cbc7016b27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa360bfc94fbbd8ed260477cbc7016b27"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa360bfc94fbbd8ed260477cbc7016b27">ostreamable</a></td></tr>
<tr class="separator:aa360bfc94fbbd8ed260477cbc7016b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Variant &gt; </td></tr>
<tr class="memitem:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5a66cad0d4226d39ffd692e16bcfc076">alternative_of</a></td></tr>
<tr class="memdesc:a5a66cad0d4226d39ffd692e16bcfc076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thanks for the solution goes to PJBoy@libera.  <a href="namespaceemlabcpp.html#a5a66cad0d4226d39ffd692e16bcfc076">More...</a><br /></td></tr>
<tr class="separator:a5a66cad0d4226d39ffd692e16bcfc076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3895ca2fd367021e74c1915f724c0242"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a3895ca2fd367021e74c1915f724c0242"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3895ca2fd367021e74c1915f724c0242">element_of</a></td></tr>
<tr class="separator:a3895ca2fd367021e74c1915f724c0242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#af124e29aa89adc5fce430ee7fdda3cc4">with_value_type</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> { typename T::value_type; }</td></tr>
<tr class="separator:af124e29aa89adc5fce430ee7fdda3cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8fd33adfcfe872f4402d4b61b41113"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Signature &gt; </td></tr>
<tr class="memitem:afc8fd33adfcfe872f4402d4b61b41113"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#afc8fd33adfcfe872f4402d4b61b41113">with_signature</a> = std::same_as&lt; typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a>&lt; T &gt;::signature, Signature &gt;</td></tr>
<tr class="separator:afc8fd33adfcfe872f4402d4b61b41113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f6b4dc0a35260a281aa436f5401cce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24f6b4dc0a35260a281aa436f5401cce"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a24f6b4dc0a35260a281aa436f5401cce">with_push_back</a></td></tr>
<tr class="separator:a24f6b4dc0a35260a281aa436f5401cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e65fd6d417642b969b05ca5af4a6d8a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a5e65fd6d417642b969b05ca5af4a6d8a"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5e65fd6d417642b969b05ca5af4a6d8a">some</a> = std::same_as&lt; std::remove_cv_t&lt; T &gt;, U &gt;</td></tr>
<tr class="separator:a5e65fd6d417642b969b05ca5af4a6d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a></td></tr>
<tr class="separator:a771ceb5d56ed0208c7974b576c6dadc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6adfccd266cb01c6cfd376ea222c110"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad6adfccd266cb01c6cfd376ea222c110"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ad6adfccd266cb01c6cfd376ea222c110">decomposable_0</a> = <a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a>&lt; T &gt; &amp;&amp; ( <a class="el" href="namespaceemlabcpp_1_1detail.html#a10e61621464f2e4cc1316387d1b70b19">detail::decompose_count</a>&lt; T &gt;() == 0 )</td></tr>
<tr class="separator:ad6adfccd266cb01c6cfd376ea222c110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7fdeaa7689b2455a087e965cbc7b3d"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5b7fdeaa7689b2455a087e965cbc7b3d">neutral_quat</a> { 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 1.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> }</td></tr>
<tr class="separator:a5b7fdeaa7689b2455a087e965cbc7b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183135aadf6bd4c3bd69d06b05b50407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a183135aadf6bd4c3bd69d06b05b50407"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a183135aadf6bd4c3bd69d06b05b50407">vec_point_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#ad070e5f134da4c8624be6ca42a870066">detail::vec_point_derived_test</a>( val ); }</td></tr>
<tr class="separator:a183135aadf6bd4c3bd69d06b05b50407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3933e60ced207f516b389cc37ab278de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3933e60ced207f516b389cc37ab278de">x_axis</a> { 1, 0, 0 }</td></tr>
<tr class="memdesc:a3933e60ced207f516b389cc37ab278de"><td class="mdescLeft">&#160;</td><td class="mdescRight">instances of constants in the code for X/Y/Z axis  <a href="namespaceemlabcpp.html#a3933e60ced207f516b389cc37ab278de">More...</a><br /></td></tr>
<tr class="separator:a3933e60ced207f516b389cc37ab278de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf41298fd59d19888d3fee5cea2fe4d8"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aaf41298fd59d19888d3fee5cea2fe4d8">y_axis</a> { 0, 1, 0 }</td></tr>
<tr class="separator:aaf41298fd59d19888d3fee5cea2fe4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9562476a49ff3f90e84d658dd3bafbb9"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a9562476a49ff3f90e84d658dd3bafbb9">z_axis</a> { 0, 0, 1 }</td></tr>
<tr class="separator:a9562476a49ff3f90e84d658dd3bafbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71244dcc912784b08768c6ae041c37bc"><td class="memTemplParams" colspan="2">template&lt;typename M &gt; </td></tr>
<tr class="memitem:a71244dcc912784b08768c6ae041c37bc"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a71244dcc912784b08768c6ae041c37bc">matrix_like</a></td></tr>
<tr class="separator:a71244dcc912784b08768c6ae041c37bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8278be24d125a68a1d021a5a6744e794"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8278be24d125a68a1d021a5a6744e794"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8278be24d125a68a1d021a5a6744e794">is_string_buffer_v</a> = <a class="el" href="structemlabcpp_1_1bits_1_1is__string__buffer.html">bits::is_string_buffer</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a8278be24d125a68a1d021a5a6744e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0831a15e8671ef24b4c603958370ab09"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0831a15e8671ef24b4c603958370ab09"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a0831a15e8671ef24b4c603958370ab09">nothrow_dereference</a></td></tr>
<tr class="separator:a0831a15e8671ef24b4c603958370ab09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf0a89b5a964961b194ce7d5e97a1e3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aeaf0a89b5a964961b194ce7d5e97a1e3"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aeaf0a89b5a964961b194ce7d5e97a1e3">nothrow_add_assign</a></td></tr>
<tr class="separator:aeaf0a89b5a964961b194ce7d5e97a1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775a31358529928338b5586452f6050f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a775a31358529928338b5586452f6050f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a775a31358529928338b5586452f6050f">nothrow_sub_assign</a></td></tr>
<tr class="separator:a775a31358529928338b5586452f6050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93c323b76c99b1a173d6233b5023006"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa93c323b76c99b1a173d6233b5023006"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa93c323b76c99b1a173d6233b5023006">nothrow_threeway_compare</a></td></tr>
<tr class="separator:aa93c323b76c99b1a173d6233b5023006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69ec76f710bc498a013e2fa20298970d"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a69ec76f710bc498a013e2fa20298970d"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a69ec76f710bc498a013e2fa20298970d">nothrow_equality_compare</a></td></tr>
<tr class="separator:a69ec76f710bc498a013e2fa20298970d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba46126744139719b93ebacd0adcbf2"><td class="memItemLeft" align="right" valign="top">Args const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a></td></tr>
<tr class="separator:a5ba46126744139719b93ebacd0adcbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">pi</a> = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> }</td></tr>
<tr class="memdesc:a7cac9e89744ae1ec8ad817df33d291f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constants of units that are relevant for us.  <a href="namespaceemlabcpp.html#a7cac9e89744ae1ec8ad817df33d291f1">More...</a><br /></td></tr>
<tr class="separator:a7cac9e89744ae1ec8ad817df33d291f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a869ab03f1bd49e1adc49de513ad86ba4">quantity_derived</a> = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8d15c50b2bbbeeaa8bdc5d694b52730c">detail::quantity_derived_test</a>( val ); }</td></tr>
<tr class="memdesc:a869ab03f1bd49e1adc49de513ad86ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concept satisfies any type <code>T</code> that inherits from any form of <code>quantity&lt;U&gt;</code>.  <a href="namespaceemlabcpp.html#a869ab03f1bd49e1adc49de513ad86ba4">More...</a><br /></td></tr>
<tr class="separator:a869ab03f1bd49e1adc49de513ad86ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6bbe05fdc4482798a8777fd89bd79c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d6bbe05fdc4482798a8777fd89bd79c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a3d6bbe05fdc4482798a8777fd89bd79c">trivial_for_static_storage</a></td></tr>
<tr class="separator:a3d6bbe05fdc4482798a8777fd89bd79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd95e49f36531f3571bdf192561e42c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></td></tr>
<tr class="separator:aefd95e49f36531f3571bdf192561e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff43a196db9cecc357e6f4452638b32f"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aff43a196db9cecc357e6f4452638b32f">is_view_v</a> = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aff43a196db9cecc357e6f4452638b32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ae5e4923a149af384640fe5d3759dcc9a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ae5e4923a149af384640fe5d3759dcc9a">are_same_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td></tr>
<tr class="separator:ae5e4923a149af384640fe5d3759dcc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Us&gt; </td></tr>
<tr class="memitem:a8574533cb7c969125a6fde8f5063eff2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a8574533cb7c969125a6fde8f5063eff2">tuple_has_type_v</a> = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td></tr>
<tr class="separator:a8574533cb7c969125a6fde8f5063eff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a633f5fea14133c23b25a75cd57a8805d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a633f5fea14133c23b25a75cd57a8805d">is_std_tuple_v</a> = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a633f5fea14133c23b25a75cd57a8805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d463be90e36b5d5be447e407fca17bf"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a1d463be90e36b5d5be447e407fca17bf">is_std_array_v</a> = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td></tr>
<tr class="separator:a1d463be90e36b5d5be447e407fca17bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#aa5277a3e558d32758ca0e4770ed5e1eb">is_std_vector_v</a> = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td></tr>
<tr class="separator:aa5277a3e558d32758ca0e4770ed5e1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">static_size_v</a> = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td></tr>
<tr class="memdesc:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marked deprecated on 19.4.2021.  <a href="namespaceemlabcpp.html#a2e849ebc932caa63f7e1e6c67d0c2f7b">More...</a><br /></td></tr>
<tr class="separator:a2e849ebc932caa63f7e1e6c67d0c2f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaca063c7275419f3999bd854c88de3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#adaca063c7275419f3999bd854c88de3d">has_static_size_v</a> = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td></tr>
<tr class="separator:adaca063c7275419f3999bd854c88de3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1cdce6706f4b40d478521925ca85f8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a></td></tr>
<tr class="separator:ac1cdce6706f4b40d478521925ca85f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>MIT License. </p>
<p>Copyright (c) 2025 Jan Veverak Koniarik</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. </p>
</div><hr/><h2 class="groupheader">Class Documentation</h2>
<a name="structemlabcpp_1_1__member__function__traits" id="structemlabcpp_1_1__member__function__traits"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1__member__function__traits">&#9670;&nbsp;</a></span>emlabcpp::_member_function_traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::_member_function_traits</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename MemberFunctionPtr&gt;<br />
struct emlabcpp::_member_function_traits&lt; MemberFunctionPtr &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4" id="structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1__member__function__traits_3_01ReturnType_07Object_1_1_5_08_07ArgTypes_8_8_8_08_01_4">&#9670;&nbsp;</a></span>emlabcpp::_member_function_traits&lt; ReturnType(Object::*)(ArgTypes...) &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::_member_function_traits&lt; ReturnType(Object::*)(ArgTypes...) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnType, typename Object, typename... ArgTypes&gt;<br />
struct emlabcpp::_member_function_traits&lt; ReturnType(Object::*)(ArgTypes...) &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a6e482b847e96493d356eee127cf44ca9"></a>typedef Object</td>
<td class="fieldname">
object</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a402d9634d4bf5d249fc890b59415d7b3"></a></td>
<td class="fieldname">
signature</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="classemlabcpp_1_1function__view" id="classemlabcpp_1_1function__view"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classemlabcpp_1_1function__view">&#9670;&nbsp;</a></span>emlabcpp::function_view</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class emlabcpp::function_view</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Signature&gt;<br />
class emlabcpp::function_view&lt; Signature &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1pose__distance" id="structemlabcpp_1_1pose__distance"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pose__distance">&#9670;&nbsp;</a></span>emlabcpp::pose_distance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pose_distance</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>distance between two poses in space, represented as 'space distance' and 'angular distance' </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a86cfd1cc45e85428b1d42ea979b19b7e"></a>float</td>
<td class="fieldname">
angle_dist</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a746c782172b5cd06a357056a324f437b"></a>float</td>
<td class="fieldname">
dist</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1generic__iterator" id="structemlabcpp_1_1generic__iterator"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1generic__iterator">&#9670;&nbsp;</a></span>emlabcpp::generic_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::generic_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Derived&gt;<br />
struct emlabcpp::generic_iterator&lt; Derived &gt;</h3>

<p><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1generic__iterator" title="generic_iterator simplifies custom iterator implementation using CRTP.">generic_iterator</a> simplifies custom iterator implementation using CRTP. </p>
<p>Users inherit from <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1generic__iterator" title="generic_iterator simplifies custom iterator implementation using CRTP.">generic_iterator</a> and pass their class as the Derived template argument. It relies on std::iterator_traits&lt;Derived&gt; for type definitions and provides additional methods based on those implemented in the Derived class. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1pid__coefficients" id="structemlabcpp_1_1pid__coefficients"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pid__coefficients">&#9670;&nbsp;</a></span>emlabcpp::pid_coefficients</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pid_coefficients</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"></div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a655b9d57207a6513eefd69f5099fdae2"></a>float</td>
<td class="fieldname">
d</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a99ba17ee27bed7c782d9364b7b614eae"></a>float</td>
<td class="fieldname">
i</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="ac0b0048d94d97cc9884974fe74898b69"></a>float</td>
<td class="fieldname">
p</td>
<td class="fielddoc">
coeficients </td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1pid__config" id="structemlabcpp_1_1pid__config"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1pid__config">&#9670;&nbsp;</a></span>emlabcpp::pid_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::pid_config</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Structure to configure the pid regulator. </p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for emlabcpp::pid_config:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="structemlabcpp_1_1pid__config__coll__graph.svg" width="398" height="218"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a096dcb0c9bf6af343c832bebada97419"></a><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pid__coefficients">pid_coefficients</a></td>
<td class="fieldname">
coefficients</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a22314e3c7c4363b32d39914c8c473c3c"></a><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt;</td>
<td class="fieldname">
limits</td>
<td class="fielddoc">
limits the output of the pid regulator and internal anti-windup mechanism </td></tr>
</table>

</div>
</div>
<a name="classemlabcpp_1_1static__function__base" id="classemlabcpp_1_1static__function__base"></a>
<h2 class="memtitle"><span class="permalink"><a href="#classemlabcpp_1_1static__function__base">&#9670;&nbsp;</a></span>emlabcpp::static_function_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class emlabcpp::static_function_base</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename CallableType, std::size_t Capacity, std::size_t Align&gt;<br />
class emlabcpp::static_function_base&lt; CallableType, Capacity, Align &gt;</h3>

</div>
</div>
</div>
<a name="structemlabcpp_1_1iterator__of" id="structemlabcpp_1_1iterator__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1iterator__of">&#9670;&nbsp;</a></span>emlabcpp::iterator_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::iterator_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container&gt;<br />
struct emlabcpp::iterator_of&lt; Container &gt;</h3>

<hr  />
<p> <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a> is structure where <a class="el" href="namespaceemlabcpp.html#abb6468ad7836780268a9d6ed31b017bc">iterator_of&lt;Container&gt;::type</a> returns type of iterator that is returned by cont.begin(); </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="abb6468ad7836780268a9d6ed31b017bc"></a>typedef decltype(begin(declval&lt; add_lvalue_reference_t&lt; Container &gt; &gt;()))</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1data__iterator__of" id="structemlabcpp_1_1data__iterator__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1data__iterator__of">&#9670;&nbsp;</a></span>emlabcpp::data_iterator_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::data_iterator_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container&gt;<br />
struct emlabcpp::data_iterator_of&lt; Container &gt;</h3>

<hr  />
<p> <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1data__iterator__of">data_iterator_of</a> is structure where <a class="el" href="namespaceemlabcpp.html#aab22100d2e622b09fff3d5d67d72fe48">data_iterator_of&lt;Container&gt;::type</a> returns type of pointer that is returned by <a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7" title="Returns pointer to first item of the storage.">cont.data()</a>; </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aab22100d2e622b09fff3d5d67d72fe48"></a>typedef decltype(<a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data</a>(declval&lt; add_lvalue_reference_t&lt; Container &gt; &gt;()))</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1are__same" id="structemlabcpp_1_1are__same"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1are__same">&#9670;&nbsp;</a></span>emlabcpp::are_same</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::are_same</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename...&gt;<br />
struct emlabcpp::are_same&lt;... &gt;</h3>

<hr  />
<p> are_same&lt;Ts..&gt;::value is true if all Ts... are equal types. </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1tuple__has__type" id="structemlabcpp_1_1tuple__has__type"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1tuple__has__type">&#9670;&nbsp;</a></span>emlabcpp::tuple_has_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::tuple_has_type</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Tuple&gt;<br />
struct emlabcpp::tuple_has_type&lt; T, Tuple &gt;</h3>

<hr  />
<p> tuple_has_type&lt;T, Tuple&gt;::value is true if Tuple s std::tuple and contains type T </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1signature__of" id="structemlabcpp_1_1signature__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1signature__of">&#9670;&nbsp;</a></span>emlabcpp::signature_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::signature_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Signature&gt;<br />
struct emlabcpp::signature_of&lt; Signature &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4" id="structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1signature__of_3_01ReturnType_07Args_8_8_8_08_01_4">&#9670;&nbsp;</a></span>emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename ReturnType, typename... Args&gt;<br />
struct emlabcpp::signature_of&lt; ReturnType(Args...) &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a1d6031bb6774f9e0fdd9127e753b4429"></a></td>
<td class="fieldname">
args_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="aaf6b1e41353c5010a20ce6ae5543a98d"></a>typedef ReturnType</td>
<td class="fieldname">
return_type</td>
<td class="fielddoc">
</td></tr>
<tr><td class="fieldtype">
<a id="a04896856a5012f04869873b5f6431cf8"></a></td>
<td class="fieldname">
signature</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1mapped" id="structemlabcpp_1_1mapped"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1mapped">&#9670;&nbsp;</a></span>emlabcpp::mapped</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::mapped</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename Container, typename UnaryCallable&gt;<br />
struct emlabcpp::mapped&lt; Container, UnaryCallable &gt;</h3>

<hr  />
<p> mapped&lt;T,F&gt;::type is type returned by instance of F::operator() when applied on items from instance of T. It can differentiate between tuples or containers </p>
</div>
</div>
</div>
<a name="structemlabcpp_1_1select__utype" id="structemlabcpp_1_1select__utype"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1select__utype">&#9670;&nbsp;</a></span>emlabcpp::select_utype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::select_utype</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;std::size_t&gt;<br />
struct emlabcpp::select_utype&lt; size_t &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1type__map" id="structemlabcpp_1_1type__map"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__map">&#9670;&nbsp;</a></span>emlabcpp::type_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename, template&lt; typename &gt; class&gt;<br />
struct emlabcpp::type_map&lt; typename, class &gt;</h3>

<hr  />
 </div>
</div>
</div>
<a name="structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4" id="structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__map_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_00_01Fun_01_4">&#9670;&nbsp;</a></span>emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename... Ts, template&lt; typename &gt; class Fun&gt;<br />
struct emlabcpp::type_map&lt; std::tuple&lt; Ts... &gt;, Fun &gt;</h3>

</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="a7e53b3be429836ebe9e7cdecc239f7d8"></a></td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1type__tag" id="structemlabcpp_1_1type__tag"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1type__tag">&#9670;&nbsp;</a></span>emlabcpp::type_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::type_tag</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct emlabcpp::type_tag&lt; T &gt;</h3>

<hr  />
 </div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="aa956ddce4f2384a729e45e5b6a83c212"></a>typedef T</td>
<td class="fieldname">
type</td>
<td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<a name="structemlabcpp_1_1index__of" id="structemlabcpp_1_1index__of"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structemlabcpp_1_1index__of">&#9670;&nbsp;</a></span>emlabcpp::index_of</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct emlabcpp::index_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><h3>template&lt;typename T, typename Variant&gt;<br />
struct emlabcpp::index_of&lt; T, Variant &gt;</h3>

<hr  />
 </div>
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a9f7b213031fa424abf6cc3d1d04ac1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7b213031fa424abf6cc3d1d04ac1ca">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a9f7b213031fa424abf6cc3d1d04ac1ca">emlabcpp::acceleration</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a034dcea22b6c4c252c6127ffd7078a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034dcea22b6c4c252c6127ffd7078a7d">&#9670;&nbsp;</a></span>amount_of_substance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a034dcea22b6c4c252c6127ffd7078a7d">emlabcpp::amount_of_substance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 1, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa050c988b29285083320111dc7b90ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa050c988b29285083320111dc7b90ca">&#9670;&nbsp;</a></span>angle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">emlabcpp::angle</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0893503dba0b6cfd0ebd72ceb358f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0893503dba0b6cfd0ebd72ceb358f20">&#9670;&nbsp;</a></span>angular_velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af0893503dba0b6cfd0ebd72ceb358f20">emlabcpp::angular_velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 1, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4eca5b22a706c436b22c929c45b773ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca5b22a706c436b22c929c45b773ef">&#9670;&nbsp;</a></span>area</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a4eca5b22a706c436b22c929c45b773ef">emlabcpp::area</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afde778df7140459ee3df4cf32bf7566e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde778df7140459ee3df4cf32bf7566e">&#9670;&nbsp;</a></span>byte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afde778df7140459ee3df4cf32bf7566e">emlabcpp::byte</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 1 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c089201bec45628e321b5afa38d169b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c089201bec45628e321b5afa38d169b">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a2c089201bec45628e321b5afa38d169b">emlabcpp::const_pointer</a> = typedef T const*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb1ec622052848f0ddd32df8936a27a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1ec622052848f0ddd32df8936a27a8">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abb1ec622052848f0ddd32df8936a27a8">emlabcpp::const_reference</a> = typedef T const&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2eceaa8b0d9ceb67162be01c8a803f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2eceaa8b0d9ceb67162be01c8a803f7">&#9670;&nbsp;</a></span>current</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae2eceaa8b0d9ceb67162be01c8a803f7">emlabcpp::current</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11d2d1e467ceff8661e40aa2f34b24ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d2d1e467ceff8661e40aa2f34b24ae">&#9670;&nbsp;</a></span>data_iterator_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a11d2d1e467ceff8661e40aa2f34b24ae">emlabcpp::data_iterator_of_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1data__iterator__of">data_iterator_of</a>&lt; Container &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11ac05592b4c728910966af0c89b13a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ac05592b4c728910966af0c89b13a8">&#9670;&nbsp;</a></span>distance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a11ac05592b4c728910966af0c89b13a8">emlabcpp::distance</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabf27b9093d0831dd17c88bcce4f9330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf27b9093d0831dd17c88bcce4f9330">&#9670;&nbsp;</a></span>force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#aabf27b9093d0831dd17c88bcce4f9330">emlabcpp::force</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 1, -2, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d67880c6a526098821b950d000c2d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d67880c6a526098821b950d000c2d79">&#9670;&nbsp;</a></span>frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a0d67880c6a526098821b950d000c2d79">emlabcpp::frequency</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf1bd5361b527ba0c0f4c0cbb50657ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf1bd5361b527ba0c0f4c0cbb50657ec">&#9670;&nbsp;</a></span>index_of_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#adf1bd5361b527ba0c0f4c0cbb50657ec">emlabcpp::index_of_v</a> = typedef <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1index__of">index_of</a>&lt; T, Variant &gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98ab53b012e339a9621604b203df856e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ab53b012e339a9621604b203df856e">&#9670;&nbsp;</a></span>iterator_of_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">emlabcpp::iterator_of_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1iterator__of">iterator_of</a>&lt; Container &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a458a21111b267fd6b9727f821974f859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458a21111b267fd6b9727f821974f859">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">emlabcpp::length</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a068a535d76f319e21113bceb0fdb8fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068a535d76f319e21113bceb0fdb8fbe">&#9670;&nbsp;</a></span>line</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">emlabcpp::line</a> = typedef std::array&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, 2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c5e1be68f8469a0ef8388b17b94406e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5e1be68f8469a0ef8388b17b94406e">&#9670;&nbsp;</a></span>luminous_intensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5c5e1be68f8469a0ef8388b17b94406e">emlabcpp::luminous_intensity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 1, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf111745a0eec5119748333b9640afca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf111745a0eec5119748333b9640afca">&#9670;&nbsp;</a></span>mapped_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryCallable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abf111745a0eec5119748333b9640afca">emlabcpp::mapped_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1mapped">mapped</a>&lt; Container, <a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620d7b1d1801843cd1a7356bcc341e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620d7b1d1801843cd1a7356bcc341e3e">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a620d7b1d1801843cd1a7356bcc341e3e">emlabcpp::mass</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 1, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5dc3e436ef66e826d36130478f13fcc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc3e436ef66e826d36130478f13fcc2">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5dc3e436ef66e826d36130478f13fcc2">emlabcpp::pointer</a> = typedef T*</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abbf48f5a991078e6acfe3db1e7762675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf48f5a991078e6acfe3db1e7762675">&#9670;&nbsp;</a></span>power</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#abbf48f5a991078e6acfe3db1e7762675">emlabcpp::power</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af96516bd702e891771257f4dc279a2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96516bd702e891771257f4dc279a2f2">&#9670;&nbsp;</a></span>radius</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af96516bd702e891771257f4dc279a2f2">emlabcpp::radius</a> = typedef <a class="el" href="namespaceemlabcpp.html#a458a21111b267fd6b9727f821974f859">length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32d3de1ecae7eb79f5f6073bcb407b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d3de1ecae7eb79f5f6073bcb407b70">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a32d3de1ecae7eb79f5f6073bcb407b70">emlabcpp::reference</a> = typedef T&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae48e239b7c22e51004fc26dd043d32b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae48e239b7c22e51004fc26dd043d32b9">&#9670;&nbsp;</a></span>resistance</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ae48e239b7c22e51004fc26dd043d32b9">emlabcpp::resistance</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -2, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac223240cfaa32fcb48f0daa06c78a9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac223240cfaa32fcb48f0daa06c78a9e2">&#9670;&nbsp;</a></span>select_utype_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#ac223240cfaa32fcb48f0daa06c78a9e2">emlabcpp::select_utype_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1select__utype">select_utype</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f96077b9c4ba6a57d7dc290fb7670c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f96077b9c4ba6a57d7dc290fb7670c5">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">emlabcpp::size_type</a> = typedef std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a803520b1d525d0030e528bc67b402b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a803520b1d525d0030e528bc67b402b53">&#9670;&nbsp;</a></span>static_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , std::size_t Capacity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a803520b1d525d0030e528bc67b402b53">emlabcpp::static_function</a> = typedef <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1static__function__base">static_function_base</a>&lt; Signature, Capacity, alignof( void* ) &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a845bc83f874f1d97f649fbe0137c913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845bc83f874f1d97f649fbe0137c913c">&#9670;&nbsp;</a></span>temp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a845bc83f874f1d97f649fbe0137c913c">emlabcpp::temp</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 1, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35fa23942849e26dc612a6608eb2ec02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fa23942849e26dc612a6608eb2ec02">&#9670;&nbsp;</a></span>timeq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a35fa23942849e26dc612a6608eb2ec02">emlabcpp::timeq</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af17d6009cc0a80e2faa67f36d49a1e64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17d6009cc0a80e2faa67f36d49a1e64">&#9670;&nbsp;</a></span>triangle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">emlabcpp::triangle</a> = typedef <a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, 2 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbd4de918223b1144d32fcef8a9dfe2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd4de918223b1144d32fcef8a9dfe2a">&#9670;&nbsp;</a></span>type_map_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , template&lt; typename &gt; class Fun&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#afbd4de918223b1144d32fcef8a9dfe2a">emlabcpp::type_map_t</a> = typedef typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1type__map">type_map</a>&lt; T, Fun &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a151948c6a8488f45e3d7834f876be469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151948c6a8488f45e3d7834f876be469">&#9670;&nbsp;</a></span>unitless</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a151948c6a8488f45e3d7834f876be469">emlabcpp::unitless</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 0, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type alieases of physical quantity for used quantities. </p>

</div>
</div>
<a id="a62a79f4f6d31559fec9c62f27ecb5af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a79f4f6d31559fec9c62f27ecb5af1">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a62a79f4f6d31559fec9c62f27ecb5af1">emlabcpp::value_type</a> = typedef T</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1133bfe4782c135fcdb04c3de43fc0a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1133bfe4782c135fcdb04c3de43fc0a1">&#9670;&nbsp;</a></span>velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1133bfe4782c135fcdb04c3de43fc0a1">emlabcpp::velocity</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 1, 0, -1, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c9a554fd1715665000628242b77a474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9a554fd1715665000628242b77a474">&#9670;&nbsp;</a></span>voltage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a1c9a554fd1715665000628242b77a474">emlabcpp::voltage</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 2, 1, -3, -1, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f05bc39f7d9b7332f437d5a7b19156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f05bc39f7d9b7332f437d5a7b19156c">&#9670;&nbsp;</a></span>volume</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceemlabcpp.html#a5f05bc39f7d9b7332f437d5a7b19156c">emlabcpp::volume</a> = typedef <a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; 3, 0, 0, 0, 0, 0, 0, 0, 0 &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aa815694613f8d89e804ac10b1395eeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa815694613f8d89e804ac10b1395eeca">&#9670;&nbsp;</a></span>contiguous_container_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#aa815694613f8d89e804ac10b1395eeca">emlabcpp::contiguous_container_type</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa815694613f8d89e804ac10b1395eecaacb4fb1757fb37c43cded35d3eb857c43"></a>ARRAY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa815694613f8d89e804ac10b1395eecaa8eee8e217391199668cbac89472ace53"></a>OBJECT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a453799fa0ff8d942480b0bcc3dbf7f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453799fa0ff8d942480b0bcc3dbf7f10">&#9670;&nbsp;</a></span>contiguous_request_adapter_errors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a453799fa0ff8d942480b0bcc3dbf7f10">emlabcpp::contiguous_request_adapter_errors</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a7e94d60ca52c8bf6da26a0a479f08d21"></a>MISSING_NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a9bf67e4befa0dcd99caa7f01f2c9b714"></a>WRONG_TYPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10a3396545d99c2f2d78dd20411b4a66ad2"></a>CHILD_MISSING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a453799fa0ff8d942480b0bcc3dbf7f10aba7de5bc6888294e5884b024a4c894f1"></a>FULL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a98cc8be30884776ff941bb6ae93946fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cc8be30884776ff941bb6ae93946fd">&#9670;&nbsp;</a></span>contiguous_tree_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a98cc8be30884776ff941bb6ae93946fd">emlabcpp::contiguous_tree_type</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fdaecc2e9c313faddb07e7da223c1dc5c3f"></a>VALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fda8eee8e217391199668cbac89472ace53"></a>OBJECT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a98cc8be30884776ff941bb6ae93946fdacb4fb1757fb37c43cded35d3eb857c43"></a>ARRAY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a57a6537b772f3e6e4772dfdf8af3774f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a6537b772f3e6e4772dfdf8af3774f">&#9670;&nbsp;</a></span>outcome_e</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#a57a6537b772f3e6e4772dfdf8af3774f">emlabcpp::outcome_e</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a57a6537b772f3e6e4772dfdf8af3774fad0749aaba8b833466dfcbb0428e4f89c"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57a6537b772f3e6e4772dfdf8af3774fa36fc6065a3e970bc3e6b2e59da52bf2a"></a>FAILURE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a57a6537b772f3e6e4772dfdf8af3774fabb1ca97ec761fc37101737ba0aa2e7c5"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad6bb11365d380040c5e151a237655d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bb11365d380040c5e151a237655d4a">&#9670;&nbsp;</a></span>result_e</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceemlabcpp.html#ad6bb11365d380040c5e151a237655d4a">emlabcpp::result_e</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad6bb11365d380040c5e151a237655d4aad0749aaba8b833466dfcbb0428e4f89c"></a>SUCCESS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad6bb11365d380040c5e151a237655d4aabb1ca97ec761fc37101737ba0aa2e7c5"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a50ffa44557c5251237a919d0843f13cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ffa44557c5251237a919d0843f13cc">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with absolute value of internal value. </p>

</div>
</div>
<a id="a636ba3f9919efa31f356bb6bca5e290d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a636ba3f9919efa31f356bb6bca5e290d">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::abs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates absolute version of A - removing signs on all dimensions. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a246f1fc9cb6dd2ad9332499ff4574d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246f1fc9cb6dd2ad9332499ff4574d81">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T , typename BinaryCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::accumulate </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(init,x)' to each element of container 'x' and actual value of 'init' in iteration, returns a result of last application. </p>
<p>NOLINT(bugprone-use-after-move)</p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a565474a8d7bb938dd256fdb548c6f6ff">init()</a>.</p>

</div>
</div>
<a id="a39882ff8249fe71fbd0a6a3658c692bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39882ff8249fe71fbd0a6a3658c692bb">&#9670;&nbsp;</a></span>all_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::all_of </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns true for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a59476e1a770a7c69e3ec745f031f50c5">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="ab5f705d338216b0192f28e2b34c97b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f705d338216b0192f28e2b34c97b3d">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a39882ff8249fe71fbd0a6a3658c692bb">all_of()</a>, and <a class="el" href="namespaceemlabcpp.html#ae464f57c8582b655e0852bae30a0b8ca">almost_equal()</a>.</p>

</div>
</div>
<a id="ae464f57c8582b655e0852bae30a0b8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae464f57c8582b655e0852bae30a0b8ca">&#9670;&nbsp;</a></span>almost_equal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::almost_equal </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Two items 'lh' and 'rh' are almost equal if their difference is smaller than value 'eps'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a636ba3f9919efa31f356bb6bca5e290d">abs()</a>.</p>

</div>
</div>
<a id="a1733dfd1ee4b7a05c2b14b5a003a975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1733dfd1ee4b7a05c2b14b5a003a975e">&#9670;&nbsp;</a></span>angle_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::angle_shortest_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, <a class="el" href="namespaceemlabcpp.html#ad8e6b76b80a1aa107e0babd62f5f7af4">norm2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="a59476e1a770a7c69e3ec745f031f50c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59476e1a770a7c69e3ec745f031f50c5">&#9670;&nbsp;</a></span>any_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::any_of </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns true for at least one item <code>x</code> in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a63a6aaa5fc338d3d342d90a14225fe82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a6aaa5fc338d3d342d90a14225fe82">&#9670;&nbsp;</a></span>apply_on_match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a75cf44a6df8173ea7a46979f57546332">apply_on_visit()</a>.</p>

</div>
</div>
<a id="a75cf44a6df8173ea7a46979f57546332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cf44a6df8173ea7a46979f57546332">&#9670;&nbsp;</a></span>apply_on_visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::apply_on_visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combines <code>visit</code> and <code>std::apply</code> into one step - provided variant is expanded with <code>visit</code> and <code>apply</code> is called on the present alternative, items from <code>apply</code> are passed to calle to visitor <code>vis</code>. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="a51a3dac72157f60685dedced4c681643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a3dac72157f60685dedced4c681643">&#9670;&nbsp;</a></span>avg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::avg </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(x)' to each element of container 'cont' and returns the average value of each call. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aff8d314e21017873e9895791defe0635">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="acb3ac578082bbaa2d40a6fcf52bbc70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3ac578082bbaa2d40a6fcf52bbc70f">&#9670;&nbsp;</a></span>axis_projection_distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::axis_projection_distance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>axis_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to calculate distance of projection of point A. </p>
<p>That point is projected on axis defined only by it's direction - 'axis_direction'. The distance of that projection from the [0,0,0] coordinate is returned. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a5266b3d998c70ddddcc15f7bba604b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5266b3d998c70ddddcc15f7bba604b42">&#9670;&nbsp;</a></span>bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args, std::size_t N = sizeof...( Args )&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; std::byte, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::bytes </td>
          <td>(</td>
          <td class="paramtype">Args const &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Conveft the provided arguments into array of std::byte. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>.</p>

</div>
</div>
<a id="a3a3ff32c2bf0005fcdbab5763193f239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3ff32c2bf0005fcdbab5763193f239">&#9670;&nbsp;</a></span>ceil_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::ceil_to </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>takes an value <code>val</code> and rounds it up to nearest multiply of <code>base</code> </p>

</div>
</div>
<a id="ac294105427e19320821509a367462c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac294105427e19320821509a367462c36">&#9670;&nbsp;</a></span>center_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, std::size_t U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::center_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, U &gt; const &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a51a3dac72157f60685dedced4c681643">avg()</a>, <a class="el" href="namespaceemlabcpp.html#a0c12c6cbb44c2e1859d1d358f5669b69">point_cast()</a>, <a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a8ba67676f525e90205fbedd74cc885b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba67676f525e90205fbedd74cc885b9">&#9670;&nbsp;</a></span>clamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; emlabcpp::clamp </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp()</a>.</p>

</div>
</div>
<a id="a90f7d96e0c4be50762f3e1b7c53335f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f7d96e0c4be50762f3e1b7c53335f6">&#9670;&nbsp;</a></span>clamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T const&amp; emlabcpp::clamp </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare &amp;&amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1min__max.html#a90498ad87fa97accc4466641e268ff51">emlabcpp::min_max&lt; T &gt;::max()</a>, and <a class="el" href="structemlabcpp_1_1min__max.html#a9019878a5c7b00b869912bf4903f4909">emlabcpp::min_max&lt; T &gt;::min()</a>.</p>

</div>
</div>
<a id="a1eb69734e95cc40cd53e2f01531183d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb69734e95cc40cd53e2f01531183d7">&#9670;&nbsp;</a></span>cobs_decode_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt;, <a class="el" href="classemlabcpp_1_1decode__cobs__iter.html">decode_cobs_iter</a>&lt; Iter &gt; &gt; emlabcpp::cobs_decode_view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data()</a>, and <a class="el" href="namespaceemlabcpp.html#ac599d73fbac6433f70ba199e29e247e0">find()</a>.</p>

</div>
</div>
<a id="a5e72f5ad9fec2b8f70d4f8e0e5ec0d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e72f5ad9fec2b8f70d4f8e0e5ec0d23">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::compose </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>tpl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>.</p>

</div>
</div>
<a id="aff8d314e21017873e9895791defe0635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d314e21017873e9895791defe0635">&#9670;&nbsp;</a></span>cont_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::cont_size </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the container, regardless of what it is. </p>

</div>
</div>
<a id="ac77a0075c379e93afef4961e57bf88c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac77a0075c379e93afef4961e57bf88c1">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::contains </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if container <code>cont</code> contains at least one occurence of <code>item</code>, returns true/false. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aff8d314e21017873e9895791defe0635">cont_size()</a>, and <a class="el" href="namespaceemlabcpp.html#ac599d73fbac6433f70ba199e29e247e0">find()</a>.</p>

</div>
</div>
<a id="a9618d7aa05121ef5c8552c4ce580953e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9618d7aa05121ef5c8552c4ce580953e">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1min__max.html#a90498ad87fa97accc4466641e268ff51">emlabcpp::min_max&lt; T &gt;::max()</a>, and <a class="el" href="structemlabcpp_1_1min__max.html#a9019878a5c7b00b869912bf4903f4909">emlabcpp::min_max&lt; T &gt;::min()</a>.</p>

</div>
</div>
<a id="a51bc55ba3cb21b9294e89cdda68b1f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bc55ba3cb21b9294e89cdda68b1f98">&#9670;&nbsp;</a></span>convert_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Container , typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a7d1590aa2cb61d0e710f02fea01474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7d1590aa2cb61d0e710f02fea01474">&#9670;&nbsp;</a></span>convert_view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1convert__iterator.html">iterators::convert_iterator</a>&lt; T, Iterator &gt; &gt; emlabcpp::convert_view_n </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a622f11a522f1ded8232d2e13e7f41337">view_n()</a>.</p>

</div>
</div>
<a id="a54b28822529dd798c4e0f74f6d38f7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b28822529dd798c4e0f74f6d38f7fb">&#9670;&nbsp;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::copy </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>.</p>

</div>
</div>
<a id="a89767bdacebf048b6e8cc6a17b9663a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89767bdacebf048b6e8cc6a17b9663a0">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::cos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns cosinus of the quantity as scalar. </p>

</div>
</div>
<a id="a036ecd2b344a56d6473500952c3c9db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036ecd2b344a56d6473500952c3c9db8">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::count </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the predicate 'f(x)' to each element of container 'cont' and returns the count of items, for which f(x) returned 'true'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a5cd840c8670b877825d96bf91e62c76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd840c8670b877825d96bf91e62c76c">&#9670;&nbsp;</a></span>cross_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::cross_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates cross product between points A and B. </p>

</div>
</div>
<a id="a22d3558f494b4daf086216cedf167ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d3558f494b4daf086216cedf167ba7">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#a2c089201bec45628e321b5afa38d169b">const_pointer</a> emlabcpp::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to first item of the storage. </p>

</div>
</div>
<a id="a7dcf3cf10bd4814024f7177751b63c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcf3cf10bd4814024f7177751b63c26">&#9670;&nbsp;</a></span>data_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;data_container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::data_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data()</a>, and <a class="el" href="namespaceemlabcpp.html#a622f11a522f1ded8232d2e13e7f41337">view_n()</a>.</p>

</div>
</div>
<a id="a971147b99a5b38779174a4a02d0099b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971147b99a5b38779174a4a02d0099b3">&#9670;&nbsp;</a></span>decode_cobs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte* &gt; &gt; emlabcpp::decode_cobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte const * &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer. </p>
<p>Note that this does not expect 0 at the end. </p>

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1view.html#a307e340890bedc068c2cac28e2f86896">emlabcpp::view&lt; Iterator, EndIterator &gt;::end()</a>, <a class="el" href="classemlabcpp_1_1view.html#a941c1005a79b0b9725e0d6a355b327cb">emlabcpp::view&lt; Iterator, EndIterator &gt;::front()</a>, <a class="el" href="structemlabcpp_1_1cobs__decoder.html#a6d8da3062959c10c473656800f1adef9">emlabcpp::cobs_decoder::iter()</a>, and <a class="el" href="namespaceemlabcpp.html#a231279793ce500e80c1bbb0848ed83c6">tail()</a>.</p>

</div>
</div>
<a id="afecb966a998ea6497e7b378bca2681c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afecb966a998ea6497e7b378bca2681c8">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;decomposable_0 T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::tuple emlabcpp::decompose </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab02c8301ef4db0c17e59d9e6b100420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02c8301ef4db0c17e59d9e6b100420a">&#9670;&nbsp;</a></span>delete_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::delete_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deconstructs an item at position i. </p>

</div>
</div>
<a id="a23f5ee359c0603a72727e357d9c99947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f5ee359c0603a72727e357d9c99947">&#9670;&nbsp;</a></span>dimensional_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::dimensional_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a C, where C[i] = max(A[i], B[i]) holds for 0 &lt;= i &lt; N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max()</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a52ff7aa782e3d7ec9c04000f324c0e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ff7aa782e3d7ec9c04000f324c0e9f">&#9670;&nbsp;</a></span>dimensional_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::dimensional_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a C, where C[i] = min(A[i], B[i]) holds for 0 &lt;= i &lt; N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac6a2f5b7b14c057c158d28c8e7538839">min()</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a358cff2d1682d9845caa4aee8d958365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358cff2d1682d9845caa4aee8d958365">&#9670;&nbsp;</a></span>dimensional_min_max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunction  = std::identity, typename Derived  = std::decay_t&lt; mapped_t&lt; Container, UnaryFunction &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; Derived &gt; emlabcpp::dimensional_min_max_elem </td>
          <td>(</td>
          <td class="paramtype">Container const &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acb93db9f593c9eb758f2801f88f7d05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb93db9f593c9eb758f2801f88f7d05b">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp()</a>, <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, and <a class="el" href="namespaceemlabcpp.html#a3caad1b27b4b2959c43e9aa435558c35">length2_of()</a>.</p>

</div>
</div>
<a id="aee2d79916f92a116f6478fb928bd346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2d79916f92a116f6478fb928bd346d">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns euclidian distance of point A from point B. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>, and <a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum()</a>.</p>

</div>
</div>
<a id="ae65497bc8d43a6c5dd1652df3be235c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae65497bc8d43a6c5dd1652df3be235c5">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a068a535d76f319e21113bceb0fdb8fbe">line</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acb93db9f593c9eb758f2801f88f7d05b">distance_of()</a>.</p>

</div>
</div>
<a id="a7b1e6e1d604ab0623e703f92b9f8d420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b1e6e1d604ab0623e703f92b9f8d420">&#9670;&nbsp;</a></span>distance_of() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a> emlabcpp::distance_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns PoseDistance between provided poses </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1733dfd1ee4b7a05c2b14b5a003a975e">angle_shortest_path()</a>, <a class="el" href="namespaceemlabcpp.html#acb93db9f593c9eb758f2801f88f7d05b">distance_of()</a>, <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a1cf7a47f1070c2934c537d138d405cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cf7a47f1070c2934c537d138d405cf5">&#9670;&nbsp;</a></span>dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b56a9133d031451181abceacdbed8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b56a9133d031451181abceacdbed8a7">&#9670;&nbsp;</a></span>dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::dot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the dot product between A and B. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum()</a>.</p>

</div>
</div>
<a id="ab124463ea669779e32ea4428088a01c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab124463ea669779e32ea4428088a01c4">&#9670;&nbsp;</a></span>EMLABCPP_GENERATE_DECOMPOSE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::EMLABCPP_GENERATE_DECOMPOSE </td>
          <td>(</td>
          <td class="paramtype">16&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a0&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a1&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a2&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a3&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a4&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a5&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a6&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a7&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a8&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a9&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a10&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a11&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a12&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a13&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a14&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">a15&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6a005d416169624e48fd25482bb644b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a005d416169624e48fd25482bb644b">&#9670;&nbsp;</a></span>emplace_item()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T&amp; emlabcpp::emplace_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an item at position i with arguments args... </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>.</p>

</div>
</div>
<a id="a5310f80a7f1ae10cd74f8028193511c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5310f80a7f1ae10cd74f8028193511c2">&#9670;&nbsp;</a></span>encode_cobs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte* &gt; &gt; emlabcpp::encode_cobs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte const * &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; std::byte * &gt;&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encodes data from source range into target buffer with Consistent Overhead Byte Stuffing (COBS) encoding, returns bool indicating whenever conversion succeeded and subview used for conversion from target buffer. </p>
<p>Note that this does not store 0 at the end. </p>

<p class="reference">References <a class="el" href="classemlabcpp_1_1cobs__encoder.html#a94a98c6c87ff20fdcb660fc27506037a">emlabcpp::cobs_encoder::insert()</a>.</p>

</div>
</div>
<a id="afe935e56d6376df9f87d0d015a3baecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe935e56d6376df9f87d0d015a3baecc">&#9670;&nbsp;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::enumerate </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a41ab261a0f296f3c9862e59e12339885">zip()</a>.</p>

</div>
</div>
<a id="a504dbf8012c154e4c54aae3af67e08c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a504dbf8012c154e4c54aae3af67e08c9">&#9670;&nbsp;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container LhContainer, range_container RhContainer, typename BinaryPredicateCallable  = std::equal_to&lt; void &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::equal </td>
          <td>(</td>
          <td class="paramtype">LhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>rh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryPredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::equal_to&lt;&#160;void&#160;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if containers 'lh' and 'rh' has same size and calls to predicate <code>f</code> - <code>f(lh[i],rh[i])</code> return true for each item. </p>
<p>Default callable is equality. all 0 &lt;= i &lt; size() </p>

</div>
</div>
<a id="a69958489560ea5ebfccc956fbba6a0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69958489560ea5ebfccc956fbba6a0cb">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; emlabcpp::expand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1min__max.html#a90498ad87fa97accc4466641e268ff51">emlabcpp::min_max&lt; T &gt;::max()</a>, and <a class="el" href="structemlabcpp_1_1min__max.html#a9019878a5c7b00b869912bf4903f4909">emlabcpp::min_max&lt; T &gt;::min()</a>.</p>

</div>
</div>
<a id="a76527f9e9f64c2786307e3cbc9153c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76527f9e9f64c2786307e3cbc9153c73">&#9670;&nbsp;</a></span>f()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::f </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d26d2adcae9ef476f4a0b2136b9352d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d26d2adcae9ef476f4a0b2136b9352d">&#9670;&nbsp;</a></span>filled()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::filled </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an array filled with value <code>x</code> </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="ac599d73fbac6433f70ba199e29e247e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac599d73fbac6433f70ba199e29e247e0">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds first item in container 'cont' that is equal to 'item', returns iterator for container, or index for tuples. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>.</p>

</div>
</div>
<a id="adad2aaee725330a629c1fa9af8cf7e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad2aaee725330a629c1fa9af8cf7e37">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::find_if </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterator for first item, for which call to predicate f(*iter) holds true. </p>
<p>end() iterator is returned otherwise. The end() iterator is taken once, before the container is iterated. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a23af197a97477d855276e1d81578cace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23af197a97477d855276e1d81578cace">&#9670;&nbsp;</a></span>find_if_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename PredicateCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::find_if_index </td>
          <td>(</td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N until first call that returns true. </p>
<p>Function returns the index on which predicate returned true. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a9671d53ec08de7c34437cf24d07aee0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9671d53ec08de7c34437cf24d07aee0c">&#9670;&nbsp;</a></span>for_cross_joint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container LhContainer, container RhContainer, typename BinaryCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_cross_joint </td>
          <td>(</td>
          <td class="paramtype">LhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>lh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RhContainer &amp;&amp;&#160;</td>
          <td class="paramname"><em>rh_cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies binary callable 'f(x,y)' to each combination of items <code>x</code> from <code>lh_cont</code> and <code>y</code> from <code>rh_cont</code> </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, and <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>.</p>

</div>
</div>
<a id="a685395cc470dfed697a40d2c718af4e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685395cc470dfed697a40d2c718af4e9">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f' to each element of container 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a5214a69e44441c91729255e5934ce985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5214a69e44441c91729255e5934ce985">&#9670;&nbsp;</a></span>for_each_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename NullCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::for_each_index </td>
          <td>(</td>
          <td class="paramtype">NullCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes unary callable <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to N. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="aa6f0a0ef952603bbd6448aca8b102dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f0a0ef952603bbd6448aca8b102dfc">&#9670;&nbsp;</a></span>function_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto MemberFunctionPtr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1function__view">emlabcpp::function_view</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1member__function.html">member_function</a>&lt; MemberFunctionPtr &gt;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="namespaceemlabcpp.html#classemlabcpp_1_1function__view">function_view</a>&lt; typename <a class="el" href="structemlabcpp_1_1member__function.html">member_function</a>&lt; MemberFunctionPtr &gt;::signature &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59097c60aaf5eda7d31e4a2bc9161d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59097c60aaf5eda7d31e4a2bc9161d8d">&#9670;&nbsp;</a></span>get_triangle_sphere_center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::get_triangle_sphere_center </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5cd840c8670b877825d96bf91e62c76c">cross_product()</a>, <a class="el" href="namespaceemlabcpp.html#a6eb0a9d462d8ff0ccbf431c08c7f6595">normalized()</a>, <a class="el" href="namespaceemlabcpp.html#a0c12c6cbb44c2e1859d1d358f5669b69">point_cast()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a565474a8d7bb938dd256fdb548c6f6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565474a8d7bb938dd256fdb548c6f6ff">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::init </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips last item of container. </p>

</div>
</div>
<a id="aa5c68a5e49e40d77ea688170d077b6a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c68a5e49e40d77ea688170d077b6a3">&#9670;&nbsp;</a></span>inverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="ada1a8c1a727af2aea597eae9a59a8836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1a8c1a727af2aea597eae9a59a8836">&#9670;&nbsp;</a></span>inverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28a8dbe9b7a2ab048215d4c090f06b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a8dbe9b7a2ab048215d4c090f06b6e">&#9670;&nbsp;</a></span>inverse_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::inverse_transform </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa5c68a5e49e40d77ea688170d077b6a3">inverse()</a>, and <a class="el" href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">transform()</a>.</p>

</div>
</div>
<a id="a417dc63bcfd0f3fe1314388f1d2515d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417dc63bcfd0f3fe1314388f1d2515d3">&#9670;&nbsp;</a></span>joined()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container, typename T , container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::joined </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function applies callable <code>f</code> to each item in container <code>cont</code> and contacts results with operator+, <code>val</code> is used as a separator between the items. </p>
<p>Returns <code>f(cont[0]) + val + f(cont[1]) + val + ... + val + f(cont[n]);</code>. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a231279793ce500e80c1bbb0848ed83c6">tail()</a>.</p>

</div>
</div>
<a id="a3caad1b27b4b2959c43e9aa435558c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caad1b27b4b2959c43e9aa435558c35">&#9670;&nbsp;</a></span>length2_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::length2_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns squared distance of A from [0,0,0], this is a squared length of vector represented by A. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#a9b9eb800885b61e8071ef11e69debdf6">pow()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum()</a>.</p>

</div>
</div>
<a id="a5c8be9302783a0f5b41cc763d1029728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8be9302783a0f5b41cc763d1029728">&#9670;&nbsp;</a></span>length_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::length_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns distance of A from [0,0,0], this is a length of vector represented by A. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a3caad1b27b4b2959c43e9aa435558c35">length2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="a8bc890d7b63d24b90427ec7efcadeebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc890d7b63d24b90427ec7efcadeebb">&#9670;&nbsp;</a></span>lin_interp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::lin_interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>linear interpolation between base se and goal pose, with factor 0 'base' is returned, with factor 1 'goal' is returned. </p>
<p>With factor 0.5, pose between 'base' and 'goal' pose is returned </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, and <a class="el" href="namespaceemlabcpp.html#a6f2fc42d6975a0e858e1a7fec61902c4">slerp()</a>.</p>

</div>
</div>
<a id="a5ebcdaef801eab209d5572706977fec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebcdaef801eab209d5572706977fec8">&#9670;&nbsp;</a></span>lin_interp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::lin_interp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>goal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="aadd2e186f6fcbc505b519cd701ca271a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd2e186f6fcbc505b519cd701ca271a">&#9670;&nbsp;</a></span>lineary_interpolate_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; &gt; emlabcpp::lineary_interpolate_path </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ipath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acb93db9f593c9eb758f2801f88f7d05b">distance_of()</a>, <a class="el" href="namespaceemlabcpp.html#a8bc890d7b63d24b90427ec7efcadeebb">lin_interp()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a0d079397f6eee1951635d6f718632a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d079397f6eee1951635d6f718632a47">&#9670;&nbsp;</a></span>lineary_interpolate_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; emlabcpp::lineary_interpolate_path </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structemlabcpp_1_1pose.html">pose</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>ipath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acb93db9f593c9eb758f2801f88f7d05b">distance_of()</a>, <a class="el" href="namespaceemlabcpp.html#a8bc890d7b63d24b90427ec7efcadeebb">lin_interp()</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a95b7c5f71b2d2128143bbd09bc6cb341">steps()</a>.</p>

</div>
</div>
<a id="ae8555060e43c2b8cdd8d91bb248b9a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8555060e43c2b8cdd8d91bb248b9a6d">&#9670;&nbsp;</a></span>map_f()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;impl::map_f_collectable ResultContainer, container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultContainer emlabcpp::map_f </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls callable <code>f(x)</code> for each item in container 'cont' (or tuple) and stores result in 'ResultContainer', which is returned. </p>
<p>The behavior depends on what kind of 'ResultContainer' is used, rules are in this order:</p><ol type="1">
<li>std::array is constructed and <code>res[i] = f(cont[i])</code> is used for i = 0...N</li>
<li>if 'ResultContainer' has <code>push_back(x)</code> method, that is used to insert result of calls to <code>f(x)</code></li>
<li><code>insert(x)</code> method is used to insert result of calls to <code>f(x)</code> </li>
</ol>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a1911a0fc83869772cacfc4d21772268f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1911a0fc83869772cacfc4d21772268f">&#9670;&nbsp;</a></span>map_f_to_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, range_container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::map_f_to_a </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls callable <code>f(cont[i])</code> for i = 0...N and stores the result in array of an size N. </p>
<p>Calls callable f(cont[i]) for i = 0...N and stores the result in array of an appropiate size.</p>
<p>The function requires size 'N' as template parameter</p>
<p>THe size <code>N</code> is infered from container. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a0abef993d302d6b6d93fe877ca62491c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abef993d302d6b6d93fe877ca62491c">&#9670;&nbsp;</a></span>map_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;additive_operators T, arithmetic_operators U&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr U emlabcpp::map_range </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>from_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>to_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps input value 'input' from input range to equivalent value in output range </p>

</div>
</div>
<a id="a57181a407fd6f29a50664f8ba4cb44cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57181a407fd6f29a50664f8ba4cb44cd">&#9670;&nbsp;</a></span>match()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Variant , typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::match </td>
          <td>(</td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">visit()</a>.</p>

</div>
</div>
<a id="ab077da8cbabe4cc68820537ddc602b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab077da8cbabe4cc68820537ddc602b91">&#9670;&nbsp;</a></span>matcher()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Callables&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structemlabcpp_1_1matcher.html">emlabcpp::matcher</a> </td>
          <td>(</td>
          <td class="paramtype">Callables &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="structemlabcpp_1_1matcher.html">matcher</a>&lt; std::decay_t&lt; Callables &gt;... &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eab1ea813bee66236fa93054eb0fae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eab1ea813bee66236fa93054eb0fae5">&#9670;&nbsp;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with maximum value of one of the quantities. </p>

</div>
</div>
<a id="abe9cf42b0add3aa7eac2b215455f98ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9cf42b0add3aa7eac2b215455f98ed">&#9670;&nbsp;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a3a1cce893154570d1d004eff0eae44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3a1cce893154570d1d004eff0eae44">&#9670;&nbsp;</a></span>max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::max_elem </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x)' to each element of container 'cont', returns the largest return value of 'f(x)' calls. </p>
<p>Returns lowest value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, and <a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max()</a>.</p>

</div>
</div>
<a id="ad798db07be925b58001fd00feb4f721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad798db07be925b58001fd00feb4f721d">&#9670;&nbsp;</a></span>merge_arrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arr , typename... Arrs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::merge_arrays </td>
          <td>(</td>
          <td class="paramtype">Arr &amp;&amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>arrs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expects multiple std::arrays on input, and merges all together into one std::array instance. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a6919f10a6a4596b7b33d935ef44c8b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6919f10a6a4596b7b33d935ef44c8b1c">&#9670;&nbsp;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quantity with minimum value of one of the quantities. </p>

</div>
</div>
<a id="ac6a2f5b7b14c057c158d28c8e7538839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a2f5b7b14c057c158d28c8e7538839">&#9670;&nbsp;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived const&amp; emlabcpp::min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0854cc8f63fb866604cdba86751aa661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0854cc8f63fb866604cdba86751aa661">&#9670;&nbsp;</a></span>min_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::min_elem </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x) to each element of container 'cont&lsquo;, returns the smallest return value of 'f(x)&rsquo; calls. </p>
<p>Returns maximum value of the return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max()</a>, and <a class="el" href="namespaceemlabcpp.html#ac6a2f5b7b14c057c158d28c8e7538839">min()</a>.</p>

</div>
</div>
<a id="ab5e56e63d61e9a15632f19d5cfc1f6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e56e63d61e9a15632f19d5cfc1f6b5">&#9670;&nbsp;</a></span>min_max_elem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; emlabcpp::min_max_elem </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies unary callable 'f(x)' to each element of container 'cont', returns the largest and the smallest return value. </p>
<p>of 'f(x)' calls. Returns the default value of the 'f(x)' return type if container is empty. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a685395cc470dfed697a40d2c718af4e9">for_each()</a>, <a class="el" href="structstd_1_1numeric__limits_3_01T_01_4.html#ab2251fa06cfdeeb61d213db89ad08554">std::numeric_limits&lt; T &gt;::lowest()</a>, <a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max()</a>, <a class="el" href="namespaceemlabcpp.html#ac6a2f5b7b14c057c158d28c8e7538839">min()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a37c8cfdb013071f0e1eb609c257eb9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c8cfdb013071f0e1eb609c257eb9d0">&#9670;&nbsp;</a></span>none_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::none_of </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if call to predicate 'f(x)' returns false for all items in 'cont'. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a59476e1a770a7c69e3ec745f031f50c5">any_of()</a>, and <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="ad8e6b76b80a1aa107e0babd62f5f7af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e6b76b80a1aa107e0babd62f5f7af4">&#9670;&nbsp;</a></span>norm2_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::norm2_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>.</p>

</div>
</div>
<a id="a07195d9b1972b37655b1c9a0b543d52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07195d9b1972b37655b1c9a0b543d52b">&#9670;&nbsp;</a></span>normal_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::normal_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>tri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5cd840c8670b877825d96bf91e62c76c">cross_product()</a>.</p>

</div>
</div>
<a id="ac8ae9fabf0beb535e1dc1c08b3d0b7a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ae9fabf0beb535e1dc1c08b3d0b7a6">&#9670;&nbsp;</a></span>normal_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; emlabcpp::normal_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 2 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a normal to a point A in two dimensions. </p>

</div>
</div>
<a id="a6eb0a9d462d8ff0ccbf431c08c7f6595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb0a9d462d8ff0ccbf431c08c7f6595">&#9670;&nbsp;</a></span>normalized()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::normalized </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates normalized version of A, this means that length(A) equals to 1. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5c8be9302783a0f5b41cc763d1029728">length_of()</a>.</p>

</div>
</div>
<a id="ae44a5c70f711a903c1f9bdff06220948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44a5c70f711a903c1f9bdff06220948">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>negation of operator== between poses </p>

</div>
</div>
<a id="a50e0ecd7c170c87559b9de62a47df77a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e0ecd7c170c87559b9de62a47df77a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3614607d86949d19b640d9a33284429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3614607d86949d19b640d9a33284429">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6181af592879c12a867b98e75a8fafef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6181af592879c12a867b98e75a8fafef">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ddd63976678b7a53c3076c5006a15f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddd63976678b7a53c3076c5006a15f5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3573e4ac276034b44026405adacb12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3573e4ac276034b44026405adacb12a4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a00ae6b9af9632567eb99841585b4f897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ae6b9af9632567eb99841585b4f897">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a384e4bb5a921ff231358ff63aeecbe77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384e4bb5a921ff231358ff63aeecbe77">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of <a class="el" href="structemlabcpp_1_1physical__quantity.html" title="physical_quantity represents all physical units defined using the International System of Units and m...">physical_quantity</a> multiplies the internal values and the result is a type, where the exponents of each side of the multiplication are added together. </p>

</div>
</div>
<a id="a330b558b7ae6db318ed36fa2f3aec008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330b558b7ae6db318ed36fa2f3aec008">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a58474e3d150740d1c81193bf6004ac8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58474e3d150740d1c81193bf6004ac8c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of points multiplies each coordinate of A by coordinate of B on same dimension. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a113ae6d930d0d7b6b4cea3e105ef3c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113ae6d930d0d7b6b4cea3e105ef3c89">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of quantity by it's value_type. </p>

</div>
</div>
<a id="ad34df7bcaa03713593d1de138ecf6381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34df7bcaa03713593d1de138ecf6381">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37dd3f09e5ee0c5f34d4890721eedab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37dd3f09e5ee0c5f34d4890721eedab0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cc44ceacc244a528ddbe752ecd54b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc44ceacc244a528ddbe752ecd54b28">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

</div>
</div>
<a id="a389a5cc86ed797a145ffdeccf2782d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389a5cc86ed797a145ffdeccf2782d88">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype">ValueType const&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplication of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="ade8b6f63869b137c01f468f94fe66af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8b6f63869b137c01f468f94fe66af2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator* </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a26a8fb58eec641f5a3825f8c684ff6d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a8fb58eec641f5a3825f8c684ff6d1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of addition a to b, viz += operator. </p>

</div>
</div>
<a id="aa769755c5f91ef62dc9d15f40311e640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa769755c5f91ef62dc9d15f40311e640">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sum of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="a6012e7482c7c10117d1bf94115b8a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6012e7482c7c10117d1bf94115b8a6bb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba061e073dffe44ebd226702b8a9256d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba061e073dffe44ebd226702b8a9256d">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a90457babf1c49444a526a98007a751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a90457babf1c49444a526a98007a751">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Iterators&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt; emlabcpp::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1zip__iterator.html">zip_iterator</a>&lt; Iterators... &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac09a470ff3b24abe911e6d08ec0ea0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09a470ff3b24abe911e6d08ec0ea0c0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of subtraction of A from B, viz -= operator. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="aabc2d56e5b666168195810e2c2fb85db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc2d56e5b666168195810e2c2fb85db">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a result of subtraction a to b, viz += operator. </p>

</div>
</div>
<a id="a81a99b9695c313b1a54ab1fdc47416b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a99b9695c313b1a54ab1fdc47416b9">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides negation of the quantity. </p>

</div>
</div>
<a id="a1c89a86af41d0afc8c294f691f03dba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c89a86af41d0afc8c294f691f03dba3">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtraction of quantities with same Derived and value_type. </p>

</div>
</div>
<a id="a03f578e487d804739e3f02e467df4455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f578e487d804739e3f02e467df4455">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fdcd2bf6efc13dd21e3298c777d4982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fdcd2bf6efc13dd21e3298c777d4982">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len0, int Mass0, int Time0, int Current0, int Temp0, int Mol0, int Li0, int Angle0, int Byte0, int Len1, int Mass1, int Time1, int Current1, int Temp1, int Mol1, int Li1, int Angle1, int Byte1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len0, Mass0, Time0, Current0, Temp0, Mol0, Li0, Angle0, Byte0 &gt;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len1, Mass1, Time1, Current1, Temp1, Mol1, Li1, Angle1, Byte1 &gt;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divison of physical_quantiy divides the internal values and the result is a type, where the exponents of each side of the multiplication are subtracted. </p>

</div>
</div>
<a id="a992eaf6dceaf1c7d3c11238f698ff88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a992eaf6dceaf1c7d3c11238f698ff88c">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a61e7321a7721894fde42b2da9bf2cbd8">arithmetic</a> auto const&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of quantity by it's value_type. </p>

</div>
</div>
<a id="a1917205f8db3c6bf0d76651f4a20ea7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1917205f8db3c6bf0d76651f4a20ea7f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr ValueType emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype">ValueType const&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Division of value_type by quantity returns quantity. </p>

</div>
</div>
<a id="ad26988acd15fa707a1ab1d00f75617b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26988acd15fa707a1ab1d00f75617b6">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , std::size_t N, typename T , typename  = typename std::enable_if_t&lt; std::is_arithmetic_v&lt; T &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Derived emlabcpp::operator/ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vec__point__base.html">vec_point_base</a>&lt; Derived, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each coordinate of A by item 's' of type T, if T satifies std::is_arithmetic. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a81633fa08052523cd4fb5f315a286cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81633fa08052523cd4fb5f315a286cce">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like LhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">LhValueType const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides abillity to compare quantity with non-quantity arithmetic value. </p>

</div>
</div>
<a id="abba96ee23c0c917523f3c8563b8bc748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba96ee23c0c917523f3c8563b8bc748">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a044797e0296bafbfc9cb5ec86bfdb0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044797e0296bafbfc9cb5ec86bfdb0e4">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType , arithmetic_like RhValueType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RhValueType const&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides abillity to compare quantity with non-quantity arithmetic value. </p>

</div>
</div>
<a id="a6044bbf69503a7dfc2107e8928791c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6044bbf69503a7dfc2107e8928791c21">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a9c3126eb05106e9a28a4556d31e6a961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3126eb05106e9a28a4556d31e6a961">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#adad2aaee725330a629c1fa9af8cf7e37">find_if()</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, and <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="ae6154c4150903826b9b84540c27036ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6154c4150903826b9b84540c27036ad">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; emlabcpp::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1string__buffer.html">string_buffer</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>sb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d00c6c3cb52ca970c9752454ce8fddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d00c6c3cb52ca970c9752454ce8fddf">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3006d6f69314abae91dc0740a404ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3006d6f69314abae91dc0740a404ddf">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#af6923c24f500869e457a4ca7f2fb9426">emlabcpp::static_circular_buffer&lt; T, N &gt;::begin()</a>, and <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#aa8165951ae18e5a305ee580be7c749d4">emlabcpp::static_circular_buffer&lt; T, N &gt;::end()</a>.</p>

</div>
</div>
<a id="af6977046b5b7b9ce51390b724488d378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6977046b5b7b9ce51390b724488d378">&#9670;&nbsp;</a></span>operator&lt;=&gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afdc23078b9a73f00019b97989e11ca8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc23078b9a73f00019b97989e11ca8a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compares poses on their position and orientation </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a18552b09d9e56e372ff803166bfa4fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18552b09d9e56e372ff803166bfa4fa8">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae83f29891e0c7be2eee69b89588df758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83f29891e0c7be2eee69b89588df758">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a504dbf8012c154e4c54aae3af67e08c9">equal()</a>.</p>

</div>
</div>
<a id="a45f4b2a0c37593a9fe9fa24e82055731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f4b2a0c37593a9fe9fa24e82055731">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__circular__buffer.html">static_circular_buffer</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#af6923c24f500869e457a4ca7f2fb9426">emlabcpp::static_circular_buffer&lt; T, N &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#aa8165951ae18e5a305ee580be7c749d4">emlabcpp::static_circular_buffer&lt; T, N &gt;::end()</a>, <a class="el" href="namespaceemlabcpp.html#a504dbf8012c154e4c54aae3af67e08c9">equal()</a>, and <a class="el" href="classemlabcpp_1_1static__circular__buffer.html#a1e075ae0be996c278fb28a8afe471fe7">emlabcpp::static_circular_buffer&lt; T, N &gt;::size()</a>.</p>

</div>
</div>
<a id="af3061f1658ea319c507053d8c7eb785f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3061f1658ea319c507053d8c7eb785f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb2649988155d01327137383a7fb2c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2649988155d01327137383a7fb2c90">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorLh , typename IteratorRh &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorLh &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; IteratorRh &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="classemlabcpp_1_1view.html#a35373b7ecce53b42f2b93316496708e1">emlabcpp::view&lt; Iterator, EndIterator &gt;::begin()</a>, <a class="el" href="classemlabcpp_1_1view.html#a307e340890bedc068c2cac28e2f86896">emlabcpp::view&lt; Iterator, EndIterator &gt;::end()</a>, and <a class="el" href="classemlabcpp_1_1view.html#af2e8f0748de03d25eb586ef4fbe0bb13">emlabcpp::view&lt; Iterator, EndIterator &gt;::size()</a>.</p>

</div>
</div>
<a id="a0d39f24887788ae240b808e79d62de84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d39f24887788ae240b808e79d62de84">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac229488d4d6586cd9d9a325efdcb6627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac229488d4d6586cd9d9a325efdcb6627">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; Item, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38e01294f96a5357c8e80f5c27d081b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e01294f96a5357c8e80f5c27d081b3">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#abb1ec622052848f0ddd32df8936a27a8">const_reference</a> emlabcpp::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a1f96077b9c4ba6a57d7dc290fb7670c5">size_type</a> const&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a reference to item at position i. </p>

</div>
</div>
<a id="a6855f415eda103a7b9807510a531e9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6855f415eda103a7b9807510a531e9fd">&#9670;&nbsp;</a></span>point_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::point_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#abcf7f7c11dfd7ca203f3363abfe59318">vector_angle()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a0c12c6cbb44c2e1859d1d358f5669b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c12c6cbb44c2e1859d1d358f5669b69">&#9670;&nbsp;</a></span>point_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::point_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b9eb800885b61e8071ef11e69debdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9eb800885b61e8071ef11e69debdf6">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Power, int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::pow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Power of physical quantity is power of root of it's value and the exponents are multiplied by the value. </p>

</div>
</div>
<a id="a5b62f09ff5468bc513cac30ace3d6c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b62f09ff5468bc513cac30ace3d6c58">&#9670;&nbsp;</a></span>pretty_type_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::pretty_type_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<hr  />
<p> / central function for returning name of type that can demangle if necessary </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="acf5a156c767ed17a892cc7e9b5acd2b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5a156c767ed17a892cc7e9b5acd2b1">&#9670;&nbsp;</a></span>range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [from, to) </p>

</div>
</div>
<a id="ace588590ccd59087b704005a3c04caae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace588590ccd59087b704005a3c04caae">&#9670;&nbsp;</a></span>range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Numeric &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="classemlabcpp_1_1iterators_1_1numeric__iterator.html">iterators::numeric_iterator</a>&lt; Numeric &gt; &gt; emlabcpp::range </td>
          <td>(</td>
          <td class="paramtype">Numeric&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds numeric view over interval [0, to) </p>

</div>
</div>
<a id="aab6fd32a8b3335eec93b94331d4293b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6fd32a8b3335eec93b94331d4293b0">&#9670;&nbsp;</a></span>requires() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; PredicateCallable = std::identity&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns index of an element in tuple 't', for which call to predicate f(x) holds true, otherwise returns index of 'past the end' item - size of the tuple. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, and <a class="el" href="namespaceemlabcpp_1_1impl.html#a72a1ddd6dafcd28180b05c9fcc48bfa8">emlabcpp::impl::find_if_impl()</a>.</p>

</div>
</div>
<a id="a670099942b8cdd3d2cc28760b1717d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670099942b8cdd3d2cc28760b1717d7c">&#9670;&nbsp;</a></span>requires() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Container, container_invocable&lt; Container &gt; UnaryCallable&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!<a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; Container &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;&amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies unary callable 'f' to each element of container 'cont'. </p>

</div>
</div>
<a id="a35de9105fe961a808d8e0f3a2cb58bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35de9105fe961a808d8e0f3a2cb58bf2">&#9670;&nbsp;</a></span>requires() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">!requires(Callable <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>) { { f.template operator()&lt; 0 &gt;() } -&gt; std::same_as&lt; void &gt;;}&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function expectes bounded value as index input and callable. </p>
<p>Based on the value of index, <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> is called with template argument <code>std::size_t</code> with internal value of provided index. Expectes the bounded value to be valid (that is within the range) </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a8d77f50ca9dd31e43365e38debbd42fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d77f50ca9dd31e43365e38debbd42fa">&#9670;&nbsp;</a></span>requires() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bounded_derived IndexType, typename Callable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">requires emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">Callable&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a512f1fd6d6a6aa3d5094088865158e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512f1fd6d6a6aa3d5094088865158e23">&#9670;&nbsp;</a></span>requires() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like LH, matrix_like RH&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">LH::rows&#160;</td>
          <td class="paramname"> = <code>=RH::rows&#160;&amp;&amp;LH::cols==RH::cols</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>.</p>

</div>
</div>
<a id="a9d7b165281b38eb416a5f581aca02c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7b165281b38eb416a5f581aca02c45">&#9670;&nbsp;</a></span>requires() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">2 &amp;&amp;M::cols&#160;</td>
          <td class="paramname"> = <code>=&#160;M::rows</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="ae9679354218890ed9c289c674a125378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9679354218890ed9c289c674a125378">&#9670;&nbsp;</a></span>requires() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname"> = <code>=&#160;1&#160;&amp;&amp;&#160;M::cols&#160;==&#160;1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a9621414bdb005465241465f455e742ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9621414bdb005465241465f455e742ca">&#9670;&nbsp;</a></span>requires() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_like M&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">M::rows&#160;</td>
          <td class="paramname"> = <code>=&#160;2&#160;&amp;&amp;&#160;M::cols&#160;==&#160;2</code></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dcd56ce6fdffb4ebcf8a4c079335d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcd56ce6fdffb4ebcf8a4c079335d8e">&#9670;&nbsp;</a></span>requires() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint16_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac39ed97224e397106e08c6e04012e62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39ed97224e397106e08c6e04012e62a">&#9670;&nbsp;</a></span>requires() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint32_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2acb59e904f4530e0e8d42e98f67bcaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2acb59e904f4530e0e8d42e98f67bcaa">&#9670;&nbsp;</a></span>requires() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint64_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd74c7df9ccef5ce376d2c3fe2ef8908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd74c7df9ccef5ce376d2c3fe2ef8908">&#9670;&nbsp;</a></span>requires() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">sizeof(uint8_t)&#160;</td>
          <td class="paramname"> = <code>=&#160;<a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a39bdb9e4992c495c755d900b23435840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39bdb9e4992c495c755d900b23435840">&#9670;&nbsp;</a></span>requires() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">std::is_enum_v&lt; Enum &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string-like name of the enum value <code>val</code> </p>

</div>
</div>
<a id="a478ead96ff195d7de7ce62ed8b67a9ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478ead96ff195d7de7ce62ed8b67a9ad">&#9670;&nbsp;</a></span>requires() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype">std::same_as&lt; Args, <a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a335b4e955623092b8021cbbb539eaeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335b4e955623092b8021cbbb539eaeda">&#9670;&nbsp;</a></span>requires() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::requires </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#a3d6bbe05fdc4482798a8777fd89bd79c">trivial_for_static_storage</a>&lt; T &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802d2ec172423fb3984b1e88336f6233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802d2ec172423fb3984b1e88336f6233">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeType&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>last_measured</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#aaeebf0506e1b2d30502abdfa3e33073a">emlabcpp::pid&lt; TimeType &gt;::last_measured</a>, and <a class="el" href="structemlabcpp_1_1pid.html#ab22ac70cb2ecdfe8cdd3d4498695ab10">emlabcpp::pid&lt; TimeType &gt;::last_time</a>.</p>

</div>
</div>
<a id="a2fe2d2bf491db344cf04e4c2b9d799b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe2d2bf491db344cf04e4c2b9d799b8">&#9670;&nbsp;</a></span>reversed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::reversed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ad5b78b4d7a2e426170153951069c76cf">referenceable_container</a> auto &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; decltype( std::rbegin( <a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a> ) ) &gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns view to the Container in reverse order. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ac6a5e3253aa7ea8bcd6574b3274c74b6">container</a>.</p>

</div>
</div>
<a id="aeca8ef1b6ac47e1cdf32fcde26d5cd52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca8ef1b6ac47e1cdf32fcde26d5cd52">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa5c68a5e49e40d77ea688170d077b6a3">inverse()</a>.</p>

</div>
</div>
<a id="ac51b871c46d305f812f4bbc657e83fef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51b871c46d305f812f4bbc657e83fef">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pose X is rotated based on quaternion 'quad'. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, and <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>.</p>

</div>
</div>
<a id="a2b86cb426b688da333795c5ceb721f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86cb426b688da333795c5ceb721f03">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa5c68a5e49e40d77ea688170d077b6a3">inverse()</a>.</p>

</div>
</div>
<a id="aedb43931ad079507aa5c8ebf524035c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb43931ad079507aa5c8ebf524035c4">&#9670;&nbsp;</a></span>rotate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::rotate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a0c12c6cbb44c2e1859d1d358f5669b69">point_cast()</a>, <a class="el" href="namespaceemlabcpp.html#ac51b871c46d305f812f4bbc657e83fef">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a21bf2080b111dbe37490823f1faa48a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bf2080b111dbe37490823f1faa48a6">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>scales</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22bdba517ae1cfa5e6b4f2e54e407bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bdba517ae1cfa5e6b4f2e54e407bb1">&#9670;&nbsp;</a></span>select_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">i&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">[&amp;res, &amp;f] &lt; std::size_t i &gt;() { <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>=f.template operator()&lt; i &gt;();}&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, and <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>.</p>

</div>
</div>
<a id="a505109612442935cc682cf92a9d2296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505109612442935cc682cf92a9d2296c">&#9670;&nbsp;</a></span>select_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void emlabcpp::select_index </td>
          <td>(</td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="af502c46ab09d85973cfcaaf05be835ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502c46ab09d85973cfcaaf05be835ac">&#9670;&nbsp;</a></span>shortest_arc_quat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::shortest_arc_quat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5cd840c8670b877825d96bf91e62c76c">cross_product()</a>, <a class="el" href="namespaceemlabcpp.html#a20db02f115d34db629106a39c5194e18">default_epsilon</a>, <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, <a class="el" href="namespaceemlabcpp.html#a6eb0a9d462d8ff0ccbf431c08c7f6595">normalized()</a>, <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a814d6c59042c6b73cca5c9a2272d6316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814d6c59042c6b73cca5c9a2272d6316">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int emlabcpp::sign </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns sign of variable T: -1,0,1 </p>

</div>
</div>
<a id="a5106ef8ad66345637cf8b13dd1fda9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5106ef8ad66345637cf8b13dd1fda9ec">&#9670;&nbsp;</a></span>sin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quantity.html">quantity</a>&lt; Derived, ValueType &gt; const&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns sinus of the quantity as scalar. </p>

</div>
</div>
<a id="a6f2fc42d6975a0e858e1a7fec61902c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2fc42d6975a0e858e1a7fec61902c4">&#9670;&nbsp;</a></span>slerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::slerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> const &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1733dfd1ee4b7a05c2b14b5a003a975e">angle_shortest_path()</a>, <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, and <a class="el" href="namespaceemlabcpp.html#a5106ef8ad66345637cf8b13dd1fda9ec">sin()</a>.</p>

</div>
</div>
<a id="a5519896c5f0324265089711b6a020642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5519896c5f0324265089711b6a020642">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int Len, int Mass, int Time, int Current, int Temp, int Mol, int Li, int Angle, int Byte&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::sqrt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1physical__quantity.html">physical_quantity</a>&lt; Len, Mass, Time, Current, Temp, Mol, Li, Angle, Byte &gt;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Square root of physical quantity is square root of it's value and the exponents are divided in half. </p>

</div>
</div>
<a id="a95b7c5f71b2d2128143bbd09bc6cb341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b7c5f71b2d2128143bbd09bc6cb341">&#9670;&nbsp;</a></span>steps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1pose__distance">pose_distance</a>&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dist_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle_step</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns steps necessary for linear interpolation of distance between poses 'dis', such that: </p>
<ul>
<li>the number of steps is minimized</li>
<li>space distance between interpolated poses is smaller than dist_step</li>
<li>angle distance between interpolated poses is smaller than angle_step </li>
</ul>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a86cfd1cc45e85428b1d42ea979b19b7e">emlabcpp::pose_distance::angle_dist</a>, <a class="el" href="namespaceemlabcpp.html#a746c782172b5cd06a357056a324f437b">emlabcpp::pose_distance::dist</a>, and <a class="el" href="namespaceemlabcpp.html#abe9cf42b0add3aa7eac2b215455f98ed">max()</a>.</p>

</div>
</div>
<a id="af06cdf4e6872ac961315f173c9d21aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af06cdf4e6872ac961315f173c9d21aa5">&#9670;&nbsp;</a></span>string_serialize_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator , typename EndIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::string_serialize_view </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator, EndIterator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ae5bc0fd1be635cd2666c78c8d69fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae5bc0fd1be635cd2666c78c8d69fae">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::sum </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies f(x) to each item of container 'cont', returns the sum of all the return values of each call to 'f(x)' and 'init' item. </p>

</div>
</div>
<a id="a736be2315b7c53a88f64e165cbeb3fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736be2315b7c53a88f64e165cbeb3fab">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1static__vector.html">static_vector</a>&lt; T, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a231279793ce500e80c1bbb0848ed83c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231279793ce500e80c1bbb0848ed83c6">&#9670;&nbsp;</a></span>tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;referenceable_container Container, typename Iterator  = iterator_of_t&lt; Container &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iterator &gt; emlabcpp::tail </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int const&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns range over Container, which skips first item of container. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp_1_1cfg.html#a8e03f9106771ab434a50622f4432bee0">emlabcpp::cfg::next()</a>.</p>

</div>
</div>
<a id="abf4e8ebb24e5ef876532d4b038ca322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4e8ebb24e5ef876532d4b038ca322a">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1min__max.html#a90498ad87fa97accc4466641e268ff51">emlabcpp::min_max&lt; T &gt;::max()</a>, <a class="el" href="structemlabcpp_1_1min__max.html#a9019878a5c7b00b869912bf4903f4909">emlabcpp::min_max&lt; T &gt;::min()</a>, and <a class="el" href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">transform()</a>.</p>

</div>
</div>
<a id="a7324e7c913729faf1c4cf85b8e2f8252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7324e7c913729faf1c4cf85b8e2f8252">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Point A is rotated based on 'transformation' orientation and than moved based on 'transformation' position. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, <a class="el" href="namespaceemlabcpp.html#ac51b871c46d305f812f4bbc657e83fef">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a7827b96d4e730d02704e7e77d6deeb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7827b96d4e730d02704e7e77d6deeb4c">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structemlabcpp_1_1pose.html">pose</a> emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pose X is rotated based on 'transformation' orientation and than moved based on 'transformation' position. </p>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, and <a class="el" href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">transform()</a>.</p>

</div>
</div>
<a id="a7405050872ccfca2a64cb049e4def265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7405050872ccfca2a64cb049e4def265">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#af17d6009cc0a80e2faa67f36d49a1e64">triangle</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a7324e7c913729faf1c4cf85b8e2f8252">transform()</a>.</p>

</div>
</div>
<a id="a5488ffa871becfb4a72d72495c20cb90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5488ffa871becfb4a72d72495c20cb90">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; const &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pose.html">pose</a> const &amp;&#160;</td>
          <td class="paramname"><em>transformation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pose.html#a91718e2267586a129cfe03c3e67641f9">emlabcpp::pose::orientation</a>, <a class="el" href="structemlabcpp_1_1pose.html#a61e29575c2f82392bb0ad93a9d80e576">emlabcpp::pose::position</a>, <a class="el" href="namespaceemlabcpp.html#ac51b871c46d305f812f4bbc657e83fef">rotate()</a>, and <a class="el" href="namespaceemlabcpp.html#abf5b72176081094d23e7ba44b307bbcb">vector_cast()</a>.</p>

</div>
</div>
<a id="a323c6de62f296a43d492b2468514f8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a323c6de62f296a43d492b2468514f8e8">&#9670;&nbsp;</a></span>trim_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt; emlabcpp::trim_view </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the view over over Container, where we ignore first r*size/2 items and last r*size/2 items. </p>
<p>This can be used to get the dataset without first/last 5% for example, by using r=0.1 </p>

</div>
</div>
<a id="aa8b8f5742901528282a9da6b8317e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8b8f5742901528282a9da6b8317e7b5">&#9670;&nbsp;</a></span>tuple_zip_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TuplesTuple , std::size_t... ItemIndexes, std::size_t... TupleIndexes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::tuple_zip_impl </td>
          <td>(</td>
          <td class="paramtype">TuplesTuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tpls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; ItemIndexes... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; TupleIndexes... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a35f12faf6930621f03dcddf5e18a16b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f12faf6930621f03dcddf5e18a16b1">&#9670;&nbsp;</a></span>until_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, typename PredicateCallable &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::until_index </td>
          <td>(</td>
          <td class="paramtype">PredicateCallable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes predicate <code><a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f()</a></code> with template argument of type 'std::size_t', which ranges from 0 to i until first call that returns true. </p>
<p>Function returns whenever the <code>f</code> was called or not. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>.</p>

</div>
</div>
<a id="a7bb8b8ced9bb2a501cc61ced29e7801d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb8b8ced9bb2a501cc61ced29e7801d">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float emlabcpp::update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TimeType&#160;</td>
          <td class="paramname"><em>now</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>measured</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this reularly, the meaning of time value 'now' is up to you, just be consistent. </p>
<p>Algorithm changes it's internal value output to the value that should be set to a 'thing' that controls measured_ value. It tries to control the 'thing' so the measured eventually converges to 'desired' value</p>
<p>improvements from naive PID:</p><ul>
<li>we work with derivation of measured, not error (error jumps in case you change desired value a lot)</li>
<li>we store i_sum entirely (i * sum_) instead of just the sum_, makes it easier to change the scale of i (imagine what happens when you store sum_, use i*sum_ in the formula nad change i from 1 to 100) </li>
</ul>

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp()</a>, <a class="el" href="namespaceemlabcpp.html#a096dcb0c9bf6af343c832bebada97419">emlabcpp::pid_config::coefficients</a>, <a class="el" href="namespaceemlabcpp.html#a655b9d57207a6513eefd69f5099fdae2">emlabcpp::pid_coefficients::d</a>, <a class="el" href="namespaceemlabcpp.html#a99ba17ee27bed7c782d9364b7b614eae">emlabcpp::pid_coefficients::i</a>, <a class="el" href="structemlabcpp_1_1pid.html#aea36c0fe6d20f767789035378d57fb44">emlabcpp::pid&lt; TimeType &gt;::i_sum</a>, <a class="el" href="structemlabcpp_1_1pid.html#aaeebf0506e1b2d30502abdfa3e33073a">emlabcpp::pid&lt; TimeType &gt;::last_measured</a>, <a class="el" href="structemlabcpp_1_1pid.html#ab22ac70cb2ecdfe8cdd3d4498695ab10">emlabcpp::pid&lt; TimeType &gt;::last_time</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>, and <a class="el" href="namespaceemlabcpp.html#ac0b0048d94d97cc9884974fe74898b69">emlabcpp::pid_coefficients::p</a>.</p>

</div>
</div>
<a id="aadc080f9334a6fec6101a6d803f7cb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc080f9334a6fec6101a6d803f7cb28">&#9670;&nbsp;</a></span>update_limits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::update_limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1min__max.html">min_max</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp()</a>, <a class="el" href="structemlabcpp_1_1pid.html#aea36c0fe6d20f767789035378d57fb44">emlabcpp::pid&lt; TimeType &gt;::i_sum</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, and <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>.</p>

</div>
</div>
<a id="ac578d4bcbce0973184093fa8cce2da33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac578d4bcbce0973184093fa8cce2da33">&#9670;&nbsp;</a></span>update_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TimeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void emlabcpp::update_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structemlabcpp_1_1pid.html">pid</a>&lt; TimeType &gt; &amp;&#160;</td>
          <td class="paramname"><em>pid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="structemlabcpp_1_1pid.html#ac81be85280e2268e736ade9acbb90620">emlabcpp::pid&lt; TimeType &gt;::cfg</a>, <a class="el" href="namespaceemlabcpp.html#a90f7d96e0c4be50762f3e1b7c53335f6">clamp()</a>, <a class="el" href="namespaceemlabcpp.html#a22314e3c7c4363b32d39914c8c473c3c">emlabcpp::pid_config::limits</a>, and <a class="el" href="structemlabcpp_1_1pid.html#ab5e5a22b5a3441963e207390ef66eb8e">emlabcpp::pid&lt; TimeType &gt;::output</a>.</p>

</div>
</div>
<a id="a50045da8445468706c19455b429cdfcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50045da8445468706c19455b429cdfcc">&#9670;&nbsp;</a></span>variance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;container Container, container_invocable&lt; Container &gt; UnaryCallable = std::identity, typename T  = std::decay_t&lt; mapped_t&lt; Container, UnaryCallable &gt; &gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T emlabcpp::variance </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&amp;&#160;</td>
          <td class="paramname"><em>cont</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em> = <code>std::identity()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies callable 'f(x)' to each element of container 'cont' and returns the variance of values returned from the call. </p>
<p>The <code>f</code> is applied twice to each element. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a51a3dac72157f60685dedced4c681643">avg()</a>, <a class="el" href="namespaceemlabcpp.html#aff8d314e21017873e9895791defe0635">cont_size()</a>, <a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, <a class="el" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>, and <a class="el" href="namespaceemlabcpp.html#a3ae5bc0fd1be635cd2666c78c8d69fae">sum()</a>.</p>

</div>
</div>
<a id="abcf7f7c11dfd7ca203f3363abfe59318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf7f7c11dfd7ca203f3363abfe59318">&#9670;&nbsp;</a></span>vector_angle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::vector_angle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a1cf7a47f1070c2934c537d138d405cf5">dot()</a>, <a class="el" href="namespaceemlabcpp.html#a3caad1b27b4b2959c43e9aa435558c35">length2_of()</a>, and <a class="el" href="namespaceemlabcpp.html#a5519896c5f0324265089711b6a020642">sqrt()</a>.</p>

</div>
</div>
<a id="abf5b72176081094d23e7ba44b307bbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5b72176081094d23e7ba44b307bbcb">&#9670;&nbsp;</a></span>vector_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; emlabcpp::vector_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b726ddab4f550f3e186f177243cb09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b726ddab4f550f3e186f177243cb09b">&#9670;&nbsp;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container Container&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classemlabcpp_1_1view.html">emlabcpp::view</a> </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td> -&gt;  <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; <a class="el" href="namespaceemlabcpp.html#a98ab53b012e339a9621604b203df856e">iterator_of_t</a>&lt; Container &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The container deduction guide uses iterator_of_t. </p>

</div>
</div>
<a id="a622f11a522f1ded8232d2e13e7f41337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a622f11a522f1ded8232d2e13e7f41337">&#9670;&nbsp;</a></span>view_n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1view.html">view</a>&lt; Iter &gt; emlabcpp::view_n </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t const&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates view over 'n' items of dataset starting at 'begin' This does not check validity of the range! </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp_1_1cfg.html#a8e03f9106771ab434a50622f4432bee0">emlabcpp::cfg::next()</a>.</p>

</div>
</div>
<a id="a6e4b7b6dd8a3a27f7f7bcea52f265b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4b7b6dd8a3a27f7f7bcea52f265b2c">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::visit </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplementation of <code>std::visit</code>. </p>
<p>This one trades worse complexity (linear) in favor of less assembly generated. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a5526fd1c86103b5f5be71eb8083d84ea">visit_index()</a>.</p>

</div>
</div>
<a id="a5526fd1c86103b5f5be71eb8083d84ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5526fd1c86103b5f5be71eb8083d84ea">&#9670;&nbsp;</a></span>visit_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Visitor , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype( auto ) emlabcpp::visit_index </td>
          <td>(</td>
          <td class="paramtype">Visitor &amp;&amp;&#160;</td>
          <td class="paramname"><em>vis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Variant const &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37d26ba6fb062781759f8b5f013fb82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d26ba6fb062781759f8b5f013fb82f">&#9670;&nbsp;</a></span>volume_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::volume_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classemlabcpp_1_1simplex.html">simplex</a>&lt; <a class="el" href="classemlabcpp_1_1point.html">point</a>&lt; <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>simplex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a636ba3f9919efa31f356bb6bca5e290d">abs()</a>, <a class="el" href="namespaceemlabcpp.html#a54b28822529dd798c4e0f74f6d38f7fb">copy()</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#acf5a156c767ed17a892cc7e9b5acd2b1">range()</a>, and <a class="el" href="classemlabcpp_1_1simplex.html#a1d4f76faf3b981d25919fdfd3f7c21da">emlabcpp::simplex&lt; Item, N &gt;::size()</a>.</p>

</div>
</div>
<a id="a41ab261a0f296f3c9862e59e12339885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41ab261a0f296f3c9862e59e12339885">&#9670;&nbsp;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;range_container... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>cont</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a view of zip iterators for specified containers. </p>
<p>Beware that the function does not check that containers have same size of ranges. If the size differs, increments of begin iterator will never equal to the end iterator. </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#a4b726ddab4f550f3e186f177243cb09b">view()</a>.</p>

</div>
</div>
<a id="a81d4ae07c2d875b52377456faf19fe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d4ae07c2d875b52377456faf19fe92">&#9670;&nbsp;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;gettable_container Tuple, gettable_container... Tuples&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::zip </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>frst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuples &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tpls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips a set of gettable containers of same size into a tuples. </p>
<p>zip(tuple&lt;A,B&gt;(), tuple&lt;C,D&gt;()) -&gt; tuple&lt;tuple&lt;A,C&gt;, &lt;tuple&lt;B,d&gt;&gt;; </p>

<p class="reference">References <a class="el" href="namespaceemlabcpp.html#aa8b8f5742901528282a9da6b8317e7b5">tuple_zip_impl()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1ba98b073e1c4277207d152957581b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba98b073e1c4277207d152957581b84">&#9670;&nbsp;</a></span>additive_operators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::additive_operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, T b ) {</div>
<div class="line">        { a + b } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">        { a - b } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_1_1impl_html_aa391ac6fa79be363f91ee9cbe2e4c578"><div class="ttname"><a href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">emlabcpp::impl::requires</a></div><div class="ttdeci">requires(!range_container&lt; Container &gt;) std</div><div class="ttdef"><b>Definition:</b> impl.h:81</div></div>
</div><!-- fragment --><hr  />
<p> arithmetic related concepts </p>

</div>
</div>
<a id="a5a66cad0d4226d39ffd692e16bcfc076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a66cad0d4226d39ffd692e16bcfc076">&#9670;&nbsp;</a></span>alternative_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Variant &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::alternative_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []&lt; <span class="keyword">typename</span>... Ts &gt;( std::variant&lt; Ts... &gt;* ) {</div>
<div class="line">        <span class="keywordflow">return</span> ( std::same_as&lt; T, Ts &gt; || ... );</div>
<div class="line">}( <span class="keyword">static_cast&lt;</span> Variant* <span class="keyword">&gt;</span>( nullptr ) )</div>
</div><!-- fragment -->
<p>Thanks for the solution goes to PJBoy@libera. </p>
<hr  />
 
</div>
</div>
<a id="ae5e4923a149af384640fe5d3759dcc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e4923a149af384640fe5d3759dcc9a">&#9670;&nbsp;</a></span>are_same_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::are_same_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1are__same">are_same</a>&lt; Ts... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ba46126744139719b93ebacd0adcbf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba46126744139719b93ebacd0adcbf2">&#9670;&nbsp;</a></span>args</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args const&amp; emlabcpp::args</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        min_max&lt; T &gt; <a class="code" href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">res</a>{ head }</div>
<div class="ttc" id="anamespaceemlabcpp_html_a9f3571963bbe0982f9987b78b111c626"><div class="ttname"><a href="namespaceemlabcpp.html#a9f3571963bbe0982f9987b78b111c626">emlabcpp::res</a></div><div class="ttdeci">T res</div><div class="ttdef"><b>Definition:</b> algorithm.h:505</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a61e7321a7721894fde42b2da9bf2cbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e7321a7721894fde42b2da9bf2cbd8">&#9670;&nbsp;</a></span>arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic = std::integral&lt; T &gt; || std::floating_point&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70c87fb6240fb7ebbfbb27d7b25b999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70c87fb6240fb7ebbfbb27d7b25b999">&#9670;&nbsp;</a></span>arithmetic_assignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_assignment</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, T b ) {</div>
<div class="line">        { a += b };</div>
<div class="line">        { a -= b };</div>
<div class="line">        { a /= b };</div>
<div class="line">        { a *= b };</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5494e6f6f24a2fd7e7ccfaecb31944b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5494e6f6f24a2fd7e7ccfaecb31944b3">&#9670;&nbsp;</a></span>arithmetic_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_like = <a class="el" href="namespaceemlabcpp.html#a94924279b38cf1803ee0f01cb4889b24">arithmetic_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#aa70c87fb6240fb7ebbfbb27d7b25b999">arithmetic_assignment</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a94924279b38cf1803ee0f01cb4889b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94924279b38cf1803ee0f01cb4889b24">&#9670;&nbsp;</a></span>arithmetic_operators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::arithmetic_operators = <a class="el" href="namespaceemlabcpp.html#a1ba98b073e1c4277207d152957581b84">additive_operators</a>&lt; T &gt; &amp;&amp; <a class="el" href="namespaceemlabcpp.html#a5de77964b77f4e30ef2e570442171e8c">multiplicative_operators</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b5a68de4881301e46697c48654d8477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5a68de4881301e46697c48654d8477">&#9670;&nbsp;</a></span>bounded_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto emlabcpp::bounded_constant = <a class="el" href="classemlabcpp_1_1bounded.html">bounded</a>&lt; std::size_t, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a>, <a class="el" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a> &gt;{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple type alias for bounded index constants. </p>

</div>
</div>
<a id="add79493bcf07bd4c54afffe3a0f3ee00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add79493bcf07bd4c54afffe3a0f3ee00">&#9670;&nbsp;</a></span>bounded_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::bounded_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a136e8541fc31cc1b24989ded96168d29">detail::bounded_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept that matchestype deriving from bounded. </p>

</div>
</div>
<a id="ac6a5e3253aa7ea8bcd6574b3274c74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a5e3253aa7ea8bcd6574b3274c74b6">&#9670;&nbsp;</a></span>container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container = <a class="el" href="namespaceemlabcpp.html#a904e4439ee5b6a29ec1c9a5a6d404c55">range_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#adb54eee14fc87e50de7f6ed35ad1aba0">gettable_container</a>&lt; T &gt; || <a class="el" href="namespaceemlabcpp.html#a6d100afeb63e0735bf1abe40e8f1dda3">data_container</a>&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeb742c691973ef2d34b0ace4d8eef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb742c691973ef2d34b0ace4d8eef15">&#9670;&nbsp;</a></span>container_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryCallable , typename Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::container_invocable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> ) { <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>( *cont.begin() ); } ||</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont ) { std::tuple_size&lt; std::decay_t&lt; Container &gt; &gt;::value == 0; } ||</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Container cont, <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> ) {</div>
<div class="line">            </div>
<div class="line">            <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>( std::get&lt; 0 &gt;( cont ) );</div>
<div class="line">    }</div>
<div class="ttc" id="anamespaceemlabcpp_html_ac1cdce6706f4b40d478521925ca85f8a"><div class="ttname"><a href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">emlabcpp::UnaryCallable</a></div><div class="ttdeci">UnaryCallable</div><div class="ttdef"><b>Definition:</b> types.h:54</div></div>
<div class="ttc" id="anamespaceemlabcpp_html_ae863a37ceeaded64e65fc9ac024f70d9"><div class="ttname"><a href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">emlabcpp::f</a></div><div class="ttdeci">UnaryCallable &amp;&amp; f</div><div class="ttdef"><b>Definition:</b> algorithm.h:161</div></div>
</div><!-- fragment --><hr  />
<p> invocable related concepts </p>

</div>
</div>
<a id="a6d100afeb63e0735bf1abe40e8f1dda3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d100afeb63e0735bf1abe40e8f1dda3">&#9670;&nbsp;</a></span>data_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::data_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    (</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { <a class="code" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">data</a>( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { <a class="code" href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">std::data</a>( a ); } ) &amp;&amp;</div>
<div class="line">    (</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { size( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { std::size( a ); } )</div>
<div class="ttc" id="anamespaceemlabcpp_html_a22d3558f494b4daf086216cedf167ba7"><div class="ttname"><a href="namespaceemlabcpp.html#a22d3558f494b4daf086216cedf167ba7">emlabcpp::data</a></div><div class="ttdeci">constexpr pointer data() noexcept</div><div class="ttdoc">Returns pointer to first item of the storage.</div><div class="ttdef"><b>Definition:</b> static_storage.h:108</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ebf6dfb3da372e9238ce6f14be53edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ebf6dfb3da372e9238ce6f14be53edd">&#9670;&nbsp;</a></span>data_container_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::data_container_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    data_container&lt; T &gt; &amp;&amp; std::same_as&lt; typename T::value_type, ValueType &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ec222a8d7edb4ed19a7049e9ad809d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec222a8d7edb4ed19a7049e9ad809d0">&#9670;&nbsp;</a></span>data_container_with_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename DataIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::data_container_with_iter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    data_container&lt; T &gt; &amp;&amp; std::convertible_to&lt; data_iterator_of_t&lt; T &gt;, DataIterator &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a771ceb5d56ed0208c7974b576c6dadc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771ceb5d56ed0208c7974b576c6dadc0">&#9670;&nbsp;</a></span>decomposable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::decomposable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= std::is_class_v&lt; std::decay_t&lt; T &gt; &gt; &amp;&amp; !gettable_container&lt; T &gt; &amp;&amp;</div>
<div class="line">                       ( detail::decompose_count&lt; T &gt;() &gt;= 0 )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad6adfccd266cb01c6cfd376ea222c110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6adfccd266cb01c6cfd376ea222c110">&#9670;&nbsp;</a></span>decomposable_0</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::decomposable_0 = <a class="el" href="namespaceemlabcpp.html#a771ceb5d56ed0208c7974b576c6dadc0">decomposable</a>&lt; T &gt; &amp;&amp; ( <a class="el" href="namespaceemlabcpp_1_1detail.html#a10e61621464f2e4cc1316387d1b70b19">detail::decompose_count</a>&lt; T &gt;() == 0 )</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20db02f115d34db629106a39c5194e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20db02f115d34db629106a39c5194e18">&#9670;&nbsp;</a></span>default_epsilon</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr float emlabcpp::default_epsilon = 1.19e-07<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3895ca2fd367021e74c1915f724c0242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3895ca2fd367021e74c1915f724c0242">&#9670;&nbsp;</a></span>element_of</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::element_of</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= []&lt; <span class="keyword">typename</span>... Ts &gt;( std::tuple&lt; Ts... &gt;* ) {</div>
<div class="line">        <span class="keywordflow">return</span> ( std::same_as&lt; T, Ts &gt; || ... );</div>
<div class="line">}( <span class="keyword">static_cast&lt;</span> Tuple* <span class="keyword">&gt;</span>( nullptr ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae863a37ceeaded64e65fc9ac024f70d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae863a37ceeaded64e65fc9ac024f70d9">&#9670;&nbsp;</a></span>f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto emlabcpp::f</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        std::apply(</div>
<div class="line">            [&amp;<a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>]&lt; <span class="keyword">typename</span>... Items &gt;( Items&amp;&amp;... items ) {</div>
<div class="line">                    ( <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>( std::forward&lt; Items &gt;( items ) ), ... );</div>
<div class="line">            },</div>
<div class="line">            std::forward&lt; Container &gt;( cont ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="adb54eee14fc87e50de7f6ed35ad1aba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb54eee14fc87e50de7f6ed35ad1aba0">&#9670;&nbsp;</a></span>gettable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::gettable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) {</div>
<div class="line">        { std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<p> container related concepts </p>

</div>
</div>
<a id="adaca063c7275419f3999bd854c88de3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaca063c7275419f3999bd854c88de3d">&#9670;&nbsp;</a></span>has_static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::has_static_size_v = <a class="el" href="namespaceemlabcpp.html#a8114b1d4bc758992dd14a1d64bd454c5">static_sized</a>&lt; T &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<hr  />
<p> has_static_size&lt;T&gt;::value is true in case type T have size deduceable at compile time </p>

</div>
</div>
<a id="a5219e24bd076b3c65f56c69b9025dd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5219e24bd076b3c65f56c69b9025dd69">&#9670;&nbsp;</a></span>invocable_returning</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename UnaryCallable , typename ReturnValue , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::invocable_returning</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( <a class="code" href="namespaceemlabcpp.html#ac1cdce6706f4b40d478521925ca85f8a">UnaryCallable</a> <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, Args... <a class="code" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a> ) {</div>
<div class="line">        { <a class="code" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>( <a class="code" href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">args</a>... ) } -&gt; std::same_as&lt; ReturnValue &gt;;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_html_a5ba46126744139719b93ebacd0adcbf2"><div class="ttname"><a href="namespaceemlabcpp.html#a5ba46126744139719b93ebacd0adcbf2">emlabcpp::args</a></div><div class="ttdeci">Args const  &amp; args</div><div class="ttdef"><b>Definition:</b> min_max.h:83</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d463be90e36b5d5be447e407fca17bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d463be90e36b5d5be447e407fca17bf">&#9670;&nbsp;</a></span>is_std_array_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_array_v = <a class="el" href="structemlabcpp_1_1is__std__array.html">is_std_array</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a633f5fea14133c23b25a75cd57a8805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633f5fea14133c23b25a75cd57a8805d">&#9670;&nbsp;</a></span>is_std_tuple_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_tuple_v = <a class="el" href="structemlabcpp_1_1is__std__tuple.html">is_std_tuple</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5277a3e558d32758ca0e4770ed5e1eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5277a3e558d32758ca0e4770ed5e1eb">&#9670;&nbsp;</a></span>is_std_vector_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_std_vector_v = <a class="el" href="structemlabcpp_1_1is__std__vector.html">is_std_vector</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8278be24d125a68a1d021a5a6744e794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8278be24d125a68a1d021a5a6744e794">&#9670;&nbsp;</a></span>is_string_buffer_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::is_string_buffer_v = <a class="el" href="structemlabcpp_1_1bits_1_1is__string__buffer.html">bits::is_string_buffer</a>&lt; T &gt;::value</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff43a196db9cecc357e6f4452638b32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff43a196db9cecc357e6f4452638b32f">&#9670;&nbsp;</a></span>is_view_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::is_view_v = <a class="el" href="structemlabcpp_1_1is__view.html">is_view</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71244dcc912784b08768c6ae041c37bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71244dcc912784b08768c6ae041c37bc">&#9670;&nbsp;</a></span>matrix_like</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename M &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::matrix_like</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">requires</a>( M m, std::size_t i, std::size_t j ) {</div>
<div class="line">        { M::rows } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">        { M::cols } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">        { m[i][j] } -&gt; std::convertible_to&lt; typename M::value_type &gt;;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceemlabcpp_html_ae9679354218890ed9c289c674a125378"><div class="ttname"><a href="namespaceemlabcpp.html#ae9679354218890ed9c289c674a125378">emlabcpp::requires</a></div><div class="ttdeci">requires(M::rows==1 &amp;&amp;M::cols==1) const expr matrix&lt; M</div><div class="ttdef"><b>Definition:</b> matrix.h:361</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5de77964b77f4e30ef2e570442171e8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5de77964b77f4e30ef2e570442171e8c">&#9670;&nbsp;</a></span>multiplicative_operators</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::multiplicative_operators</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, T b ) {</div>
<div class="line">        { a / b } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">        { a* b } -&gt; std::convertible_to&lt; T &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aefd95e49f36531f3571bdf192561e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd95e49f36531f3571bdf192561e42c">&#9670;&nbsp;</a></span>N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::N</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keyword">static</span> constexpr std::size_t capacity = <a class="code" href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">N</a></div>
<div class="ttc" id="anamespaceemlabcpp_html_aefd95e49f36531f3571bdf192561e42c"><div class="ttname"><a href="namespaceemlabcpp.html#aefd95e49f36531f3571bdf192561e42c">emlabcpp::N</a></div><div class="ttdeci">N</div><div class="ttdef"><b>Definition:</b> static_storage.h:97</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b7fdeaa7689b2455a087e965cbc7b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7fdeaa7689b2455a087e965cbc7b3d">&#9670;&nbsp;</a></span>neutral_quat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1quaternion.html">quaternion</a> emlabcpp::neutral_quat { 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 0.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a>, 1.<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaf0a89b5a964961b194ce7d5e97a1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf0a89b5a964961b194ce7d5e97a1e3">&#9670;&nbsp;</a></span>nothrow_add_assign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::nothrow_add_assign</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Derived d ) {</div>
<div class="line">        { d += 1 } noexcept;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0831a15e8671ef24b4c603958370ab09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0831a15e8671ef24b4c603958370ab09">&#9670;&nbsp;</a></span>nothrow_dereference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::nothrow_dereference</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Derived d ) {</div>
<div class="line">        { *d } noexcept;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a69ec76f710bc498a013e2fa20298970d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69ec76f710bc498a013e2fa20298970d">&#9670;&nbsp;</a></span>nothrow_equality_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::nothrow_equality_compare</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Derived d ) {</div>
<div class="line">        { d == d } noexcept;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a775a31358529928338b5586452f6050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775a31358529928338b5586452f6050f">&#9670;&nbsp;</a></span>nothrow_sub_assign</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::nothrow_sub_assign</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Derived d ) {</div>
<div class="line">        { d -= 1 } noexcept;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa93c323b76c99b1a173d6233b5023006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93c323b76c99b1a173d6233b5023006">&#9670;&nbsp;</a></span>nothrow_threeway_compare</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::nothrow_threeway_compare</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( Derived d ) {</div>
<div class="line">        { d &lt;=&gt; d } noexcept;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa360bfc94fbbd8ed260477cbc7016b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa360bfc94fbbd8ed260477cbc7016b27">&#9670;&nbsp;</a></span>ostreamable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::ostreamable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( std::ostream&amp; os, T item ) {</div>
<div class="line">        { os &lt;&lt; item } -&gt; std::convertible_to&lt; std::ostream&amp; &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a27325f314502897567307b29b2b03776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27325f314502897567307b29b2b03776">&#9670;&nbsp;</a></span>ostreamlike</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::ostreamlike</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= !std::is_array_v&lt; T &gt; &amp;&amp; <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T val ) {</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint8_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint16_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, uint32_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int8_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int16_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, int32_t &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, float &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, double &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, bool &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, void const* &gt;;</div>
<div class="line">        <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a> detail::directly_streamable_for&lt; T, std::nullptr_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7cac9e89744ae1ec8ad817df33d291f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cac9e89744ae1ec8ad817df33d291f1">&#9670;&nbsp;</a></span>pi</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a> emlabcpp::pi = <a class="el" href="namespaceemlabcpp.html#afa050c988b29285083320111dc7b90ca">angle</a>{ 3.14159265358979323846<a class="el" href="namespaceemlabcpp.html#ae863a37ceeaded64e65fc9ac024f70d9">f</a> }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constants of units that are relevant for us. </p>

</div>
</div>
<a id="a869ab03f1bd49e1adc49de513ad86ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a869ab03f1bd49e1adc49de513ad86ba4">&#9670;&nbsp;</a></span>quantity_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::quantity_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#a8d15c50b2bbbeeaa8bdc5d694b52730c">detail::quantity_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concept satisfies any type <code>T</code> that inherits from any form of <code>quantity&lt;U&gt;</code>. </p>

</div>
</div>
<a id="a904e4439ee5b6a29ec1c9a5a6d404c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904e4439ee5b6a29ec1c9a5a6d404c55">&#9670;&nbsp;</a></span>range_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    ( (</div>
<div class="line">          <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { begin( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { std::begin( a ); } ) &amp;&amp;</div>
<div class="line">      (</div>
<div class="line">          <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { end( a ); } || <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) { std::end( a ); } ) ) ||</div>
<div class="line">    std::is_bounded_array_v&lt; T &gt;</div>
</div><!-- fragment -->
<p>so, std::ranges::range is meh because it expects return of begin() being input_output_iterator, which has to be def.constructible </p>

</div>
</div>
<a id="ae70f5be4da9ac6f367034af1f5028827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70f5be4da9ac6f367034af1f5028827">&#9670;&nbsp;</a></span>range_container_with</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container_with</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    range_container&lt; T &gt; &amp;&amp; std::same_as&lt; typename T::value_type, ValueType &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac04004185c5cfd085f40f3ab99321b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac04004185c5cfd085f40f3ab99321b5c">&#9670;&nbsp;</a></span>range_container_with_iter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::range_container_with_iter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    range_container&lt; T &gt; &amp;&amp; std::convertible_to&lt; iterator_of_t&lt; T &gt;, Iterator &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5b78b4d7a2e426170153951069c76cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b78b4d7a2e426170153951069c76cf">&#9670;&nbsp;</a></span>referenceable_container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::referenceable_container</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    is_view&lt; T &gt;::value || ( range_container&lt; T &gt; &amp;&amp; !std::is_rvalue_reference_v&lt; T &gt; )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f3571963bbe0982f9987b78b111c626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3571963bbe0982f9987b78b111c626">&#9670;&nbsp;</a></span>res</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">return emlabcpp::res {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e65fd6d417642b969b05ca5af4a6d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e65fd6d417642b969b05ca5af4a6d8a">&#9670;&nbsp;</a></span>some</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::some = std::same_as&lt; std::remove_cv_t&lt; T &gt;, U &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e849ebc932caa63f7e1e6c67d0c2f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e849ebc932caa63f7e1e6c67d0c2f7b">&#9670;&nbsp;</a></span>static_size_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t emlabcpp::static_size_v = <a class="el" href="structemlabcpp_1_1static__size.html">static_size</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Marked deprecated on 19.4.2021. </p>

</div>
</div>
<a id="a8114b1d4bc758992dd14a1d64bd454c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8114b1d4bc758992dd14a1d64bd454c5">&#9670;&nbsp;</a></span>static_sized</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::static_sized</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a ) {</div>
<div class="line">        { std::tuple_size&lt; std::decay_t&lt; T &gt; &gt;::value } -&gt; std::convertible_to&lt; std::size_t &gt;;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d6bbe05fdc4482798a8777fd89bd79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6bbe05fdc4482798a8777fd89bd79c">&#9670;&nbsp;</a></span>trivial_for_static_storage</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::trivial_for_static_storage</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    std::is_trivially_default_constructible_v&lt; T &gt; &amp;&amp; std::is_trivially_destructible_v&lt; T &gt;</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8574533cb7c969125a6fde8f5063eff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8574533cb7c969125a6fde8f5063eff2">&#9670;&nbsp;</a></span>tuple_has_type_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Us&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool emlabcpp::tuple_has_type_v = <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1tuple__has__type">tuple_has_type</a>&lt; T, Us... &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1cdce6706f4b40d478521925ca85f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1cdce6706f4b40d478521925ca85f8a">&#9670;&nbsp;</a></span>UnaryCallable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">emlabcpp::UnaryCallable</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">        <span class="keyword">using</span> type = decltype( std::declval&lt; UnaryCallable &gt;()(</div>
<div class="line">            std::get&lt; 0 &gt;( std::declval&lt; Container &gt;() ) ) )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a183135aadf6bd4c3bd69d06b05b50407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183135aadf6bd4c3bd69d06b05b50407">&#9670;&nbsp;</a></span>vec_point_derived</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::vec_point_derived = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a>( T val ) { <a class="el" href="namespaceemlabcpp_1_1detail.html#ad070e5f134da4c8624be6ca42a870066">detail::vec_point_derived_test</a>( val ); }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24f6b4dc0a35260a281aa436f5401cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f6b4dc0a35260a281aa436f5401cce">&#9670;&nbsp;</a></span>with_push_back</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_push_back</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    <a class="code" href="namespaceemlabcpp_1_1impl.html#aa391ac6fa79be363f91ee9cbe2e4c578">requires</a>( T a, <span class="keyword">typename</span> <a class="code" href="namespaceemlabcpp_1_1testing.html#a7eba021904701a30cd427b798483dc5f">T::value_type</a> b ) { a.push_back( std::move( b ) ); }</div>
<div class="ttc" id="anamespaceemlabcpp_1_1testing_html_a7eba021904701a30cd427b798483dc5f"><div class="ttname"><a href="namespaceemlabcpp_1_1testing.html#a7eba021904701a30cd427b798483dc5f">emlabcpp::testing::value_type</a></div><div class="ttdeci">std::variant&lt; int64_t, float, bool, string_buffer &gt; value_type</div><div class="ttdef"><b>Definition:</b> base.h:51</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afc8fd33adfcfe872f4402d4b61b41113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8fd33adfcfe872f4402d4b61b41113">&#9670;&nbsp;</a></span>with_signature</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_signature = std::same_as&lt; typename <a class="el" href="namespaceemlabcpp.html#structemlabcpp_1_1signature__of">signature_of</a>&lt; T &gt;::signature, Signature &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af124e29aa89adc5fce430ee7fdda3cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af124e29aa89adc5fce430ee7fdda3cc4">&#9670;&nbsp;</a></span>with_value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept emlabcpp::with_value_type = <a class="el" href="namespaceemlabcpp.html#aab6fd32a8b3335eec93b94331d4293b0">requires</a> { typename T::value_type; }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3933e60ced207f516b389cc37ab278de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3933e60ced207f516b389cc37ab278de">&#9670;&nbsp;</a></span>x_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::x_axis { 1, 0, 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>instances of constants in the code for X/Y/Z axis </p>

</div>
</div>
<a id="aaf41298fd59d19888d3fee5cea2fe4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf41298fd59d19888d3fee5cea2fe4d8">&#9670;&nbsp;</a></span>y_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::y_axis { 0, 1, 0 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9562476a49ff3f90e84d658dd3bafbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9562476a49ff3f90e84d658dd3bafbb9">&#9670;&nbsp;</a></span>z_axis</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classemlabcpp_1_1vector.html">vector</a>&lt; 3 &gt; emlabcpp::z_axis { 0, 0, 1 }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceemlabcpp.html">emlabcpp</a></li>
    <li class="footer">Generated on Fri Aug 29 2025 17:10:52 for emlabcpp by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
